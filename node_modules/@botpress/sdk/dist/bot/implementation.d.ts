import type { Server } from 'node:http';
import { BasePlugin, PluginImplementation } from '../plugin';
import * as utils from '../utils';
import { BaseBot } from './common';
import { MessageHandlers, EventHandlers, StateExpiredHandlers, HookHandlers, WorkflowHandlers, MessageHandlersMap, EventHandlersMap, StateExpiredHandlersMap, HookHandlersMap, WorkflowHandlersMap, UnimplementedActionHandlers, InjectedBotHandlers } from './server';
export type BotImplementationProps<TBot extends BaseBot = BaseBot, TPlugins extends Record<string, BasePlugin> = {}> = {
    actions: UnimplementedActionHandlers<TBot, TPlugins>;
    plugins: {
        [K in utils.types.StringKeys<TPlugins>]: PluginImplementation<TPlugins[K]>;
    };
};
export declare class BotImplementation<TBot extends BaseBot = BaseBot, TPlugins extends Record<string, BasePlugin> = {}> implements InjectedBotHandlers<TBot> {
    readonly props: BotImplementationProps<TBot, TPlugins>;
    private _actionHandlers;
    private _messageHandlers;
    private _eventHandlers;
    private _stateExpiredHandlers;
    private _hookHandlers;
    private _workflowHandlers;
    private _plugins;
    private _registerOrder;
    constructor(props: BotImplementationProps<TBot, TPlugins>);
    get actionHandlers(): InjectedBotHandlers<TBot>['actionHandlers'];
    get messageHandlers(): InjectedBotHandlers<TBot>['messageHandlers'];
    get eventHandlers(): InjectedBotHandlers<TBot>['eventHandlers'];
    get stateExpiredHandlers(): InjectedBotHandlers<TBot>['stateExpiredHandlers'];
    get hookHandlers(): InjectedBotHandlers<TBot>['hookHandlers'];
    get workflowHandlers(): InjectedBotHandlers<TBot>['workflowHandlers'];
    readonly on: {
        message: <T extends utils.types.StringKeys<MessageHandlersMap<TBot>>>(type: T, handler: MessageHandlers<TBot>[T]) => void;
        event: <T extends utils.types.StringKeys<EventHandlersMap<TBot>>>(type: T, handler: EventHandlers<TBot>[T]) => void;
        stateExpired: <T extends utils.types.StringKeys<StateExpiredHandlersMap<TBot>>>(type: T, handler: StateExpiredHandlers<TBot>[T]) => void;
        beforeIncomingEvent: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["before_incoming_event"]>>(type: T, handler: HookHandlers<TBot>["before_incoming_event"][T]) => void;
        beforeIncomingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["before_incoming_message"]>>(type: T, handler: HookHandlers<TBot>["before_incoming_message"][T]) => void;
        beforeOutgoingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["before_outgoing_message"]>>(type: T, handler: HookHandlers<TBot>["before_outgoing_message"][T]) => void;
        beforeOutgoingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["before_outgoing_call_action"]>>(type: T, handler: HookHandlers<TBot>["before_outgoing_call_action"][T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        beforeIncomingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["before_incoming_call_action"]>>(type: T, handler: HookHandlers<TBot>["before_incoming_call_action"][T]) => void;
        afterIncomingEvent: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["after_incoming_event"]>>(type: T, handler: HookHandlers<TBot>["after_incoming_event"][T]) => void;
        afterIncomingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["after_incoming_message"]>>(type: T, handler: HookHandlers<TBot>["after_incoming_message"][T]) => void;
        afterOutgoingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["after_outgoing_message"]>>(type: T, handler: HookHandlers<TBot>["after_outgoing_message"][T]) => void;
        afterOutgoingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["after_outgoing_call_action"]>>(type: T, handler: HookHandlers<TBot>["after_outgoing_call_action"][T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        afterIncomingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TBot>["after_incoming_call_action"]>>(type: T, handler: HookHandlers<TBot>["after_incoming_call_action"][T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        workflowStart: <T extends utils.types.StringKeys<WorkflowHandlersMap<TBot>["started"]>>(type: T, handler: WorkflowHandlers<TBot>[T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        workflowContinue: <T extends utils.types.StringKeys<WorkflowHandlersMap<TBot>["continued"]>>(type: T, handler: WorkflowHandlers<TBot>[T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        workflowTimeout: <T extends utils.types.StringKeys<WorkflowHandlersMap<TBot>["timed_out"]>>(type: T, handler: WorkflowHandlers<TBot>[T]) => void;
    };
    readonly handler: (req: import("../serve").Request) => Promise<import("../serve").Response | void>;
    readonly start: (port?: number) => Promise<Server>;
}
