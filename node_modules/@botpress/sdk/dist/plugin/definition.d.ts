import { StateDefinition as BotStateDefinition, EventDefinition as BotEventDefinition, ConfigurationDefinition as BotConfigurationDefinition, UserDefinition, ConversationDefinition, MessageDefinition, ActionDefinition as BotActionDefinition, TableDefinition as BotTableDefinition, WorkflowDefinition } from '../bot/definition';
import { IntegrationPackage, InterfacePackage } from '../package';
import * as typeUtils from '../utils/type-utils';
import { ZuiObjectSchema, ZuiObjectOrRefSchema, z } from '../zui';
export { UserDefinition, ConversationDefinition, MessageDefinition, IntegrationConfigInstance, WorkflowDefinition, } from '../bot/definition';
type BaseConfig = ZuiObjectOrRefSchema;
type BaseStates = Record<string, ZuiObjectOrRefSchema>;
type BaseEvents = Record<string, ZuiObjectOrRefSchema>;
type BaseActions = Record<string, ZuiObjectOrRefSchema>;
type BaseInterfaces = Record<string, InterfacePackage>;
type BaseIntegrations = Record<string, IntegrationPackage>;
type BaseTables = Record<string, ZuiObjectOrRefSchema>;
type BaseWorkflows = Record<string, ZuiObjectSchema>;
export type TableDefinition<TTable extends BaseTables[string] = BaseTables[string]> = typeUtils.Merge<BotTableDefinition, {
    schema: TTable;
}>;
export type ConfigurationDefinition<TConfig extends BaseConfig = BaseConfig> = typeUtils.Merge<BotConfigurationDefinition, {
    schema: TConfig;
}>;
export type StateDefinition<TState extends BaseStates[string] = BaseStates[string]> = typeUtils.Merge<BotStateDefinition, {
    schema: TState;
}>;
export type EventDefinition<TEvent extends BaseEvents[string] = BaseEvents[string]> = typeUtils.Merge<BotEventDefinition, {
    schema: TEvent;
}>;
export type ActionDefinition<TAction extends BaseActions[string] = BaseActions[string]> = typeUtils.Merge<BotActionDefinition, {
    input: {
        schema: TAction;
    };
    output: {
        schema: ZuiObjectOrRefSchema;
    };
}>;
export type RecurringEventDefinition<TEvents extends BaseEvents = BaseEvents> = {
    [K in keyof TEvents]: {
        type: K;
        payload: z.infer<TEvents[K]>;
        schedule: {
            cron: string;
        };
    };
}[keyof TEvents];
export type ZuiSchemaWithEntityReferences<TInterfaces extends BaseInterfaces, TReturnType extends ZuiObjectOrRefSchema> = ((props: {
    entities: {
        [TInterfaceAlias in keyof TInterfaces]: {
            [TEntityName in keyof TInterfaces[TInterfaceAlias]['definition']['entities']]: z.ZodRef;
        };
    };
}) => TReturnType) | TReturnType;
type GenericDefinition<TInterfaces extends BaseInterfaces, TDefinition extends {
    schema: ZuiObjectOrRefSchema;
}> = typeUtils.Merge<TDefinition, {
    schema: ZuiSchemaWithEntityReferences<TInterfaces, TDefinition['schema']>;
}>;
type GenericNestedDefinition<TInterfaces extends BaseInterfaces, TDefinition extends {
    [k: string]: any;
}, TKeys extends string> = Omit<TDefinition, TKeys> & {
    [TKey in TKeys]: Omit<TDefinition[TKey], 'schema'> & {
        schema: ZuiSchemaWithEntityReferences<TInterfaces, TDefinition[TKey]['schema']>;
    };
};
export type PluginDefinitionProps<TName extends string = string, TVersion extends string = string, TConfig extends BaseConfig = BaseConfig, TStates extends BaseStates = BaseStates, TEvents extends BaseEvents = BaseEvents, TActions extends BaseActions = BaseActions, TInterfaces extends BaseInterfaces = BaseInterfaces, TIntegrations extends BaseIntegrations = BaseIntegrations, TTables extends BaseTables = BaseTables, TWorkflows extends BaseWorkflows = BaseWorkflows> = {
    name: TName;
    version: TVersion;
    title?: string;
    description?: string;
    icon?: string;
    readme?: string;
    attributes?: Record<string, string>;
    integrations?: TIntegrations;
    interfaces?: TInterfaces;
    user?: UserDefinition;
    conversation?: ConversationDefinition;
    message?: MessageDefinition;
    states?: {
        [K in keyof TStates]: GenericDefinition<TInterfaces, StateDefinition<TStates[K]>>;
    };
    configuration?: GenericDefinition<TInterfaces, ConfigurationDefinition<TConfig>>;
    events?: {
        [K in keyof TEvents]: GenericDefinition<TInterfaces, EventDefinition<TEvents[K]>>;
    };
    recurringEvents?: Record<string, RecurringEventDefinition<TEvents>>;
    actions?: {
        [K in keyof TActions]: GenericNestedDefinition<TInterfaces, ActionDefinition<TActions[K]>, 'input' | 'output'>;
    };
    tables?: {
        [K in keyof TTables]: GenericDefinition<TInterfaces, TableDefinition<TTables[K]>>;
    };
    /**
     * # EXPERIMENTAL
     * This API is experimental and may change in the future.
     */
    workflows?: {
        [K in keyof TWorkflows]: WorkflowDefinition<TWorkflows[K]>;
    };
    __advanced?: {
        useLegacyZuiTransformer?: boolean;
    };
};
export declare class PluginDefinition<TName extends string = string, TVersion extends string = string, TConfig extends BaseConfig = BaseConfig, TStates extends BaseStates = BaseStates, TEvents extends BaseEvents = BaseEvents, TActions extends BaseActions = BaseActions, TInterfaces extends BaseInterfaces = BaseInterfaces, TIntegrations extends BaseIntegrations = BaseIntegrations, TTables extends BaseTables = BaseTables, TWorkflows extends BaseWorkflows = BaseWorkflows> {
    readonly props: PluginDefinitionProps<TName, TVersion, TConfig, TStates, TEvents, TActions, TInterfaces, TIntegrations, TTables, TWorkflows>;
    readonly name: this['props']['name'];
    readonly version: this['props']['version'];
    readonly title: this['props']['title'];
    readonly description: this['props']['description'];
    readonly icon: this['props']['icon'];
    readonly readme: this['props']['readme'];
    readonly attributes: this['props']['attributes'];
    readonly integrations: this['props']['integrations'];
    readonly interfaces: this['props']['interfaces'];
    readonly user: this['props']['user'];
    readonly conversation: this['props']['conversation'];
    readonly message: this['props']['message'];
    readonly states: {
        [K in keyof TStates]: StateDefinition<TStates[K]>;
    };
    readonly configuration?: ConfigurationDefinition<TConfig>;
    readonly events: {
        [K in keyof TEvents]: EventDefinition<TEvents[K]>;
    };
    readonly recurringEvents: this['props']['recurringEvents'];
    readonly actions: {
        [K in keyof TActions]: ActionDefinition<TActions[K]>;
    };
    readonly tables: {
        [K in keyof TTables]: TableDefinition<TTables[K]>;
    };
    readonly workflows: this['props']['workflows'];
    readonly __advanced: this['props']['__advanced'];
    constructor(props: PluginDefinitionProps<TName, TVersion, TConfig, TStates, TEvents, TActions, TInterfaces, TIntegrations, TTables, TWorkflows>);
    /**
     * Returns a copy of the plugin definition where all entity references are
     * resolved to the base entity schema defined by the interface. This does not
     * include any additional properties that may be added to the entity by the
     * backing integration.
     *
     * If `intersectWithUnknownRecord` is `true` (default), the entity schemas
     * will be intersected with `z.record(z.string(), z.unknown())` to make it
     * explicit that the backing integration may have added additional properties.
     */
    dereferenceEntities({ intersectWithUnknownRecord }?: {
        intersectWithUnknownRecord?: boolean;
    }): this;
    private _buildZuiReferenceMap;
    private _dereferenceZuiSchema;
    private _dereferenceDefinitionSchemas;
    private _dereferenceActionDefinitionSchemas;
}
