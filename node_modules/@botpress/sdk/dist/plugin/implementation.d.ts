import type { MessageHandlersMap as BotMessageHandlersMap, EventHandlersMap as BotEventHandlersMap, StateExpiredHandlersMap as BotStateExpiredHandlersMap, HookHandlersMap as BotHookHandlersMap, WorkflowHandlersMap as BotWorkflowHandlersMap, ActionHandlersMap as BotActionHandlersMap, BotHandlers } from '../bot';
import * as utils from '../utils';
import { BasePlugin, PluginRuntimeProps } from './common';
import { ActionHandlers, MessageHandlers, EventHandlers, StateExpiredHandlers, HookHandlers, WorkflowHandlers, MessageHandlersMap, EventHandlersMap, StateExpiredHandlersMap, HookHandlersMap, WorkflowHandlersMap } from './server/types';
export type PluginImplementationProps<TPlugin extends BasePlugin = BasePlugin> = {
    actions: ActionHandlers<TPlugin>;
};
export declare class PluginImplementation<TPlugin extends BasePlugin = BasePlugin> implements BotHandlers<TPlugin> {
    readonly props: PluginImplementationProps<TPlugin>;
    private _runtimeProps;
    private _actionHandlers;
    private _messageHandlers;
    private _eventHandlers;
    private _stateExpiredHandlers;
    private _hookHandlers;
    private _workflowHandlers;
    private _registerOrder;
    constructor(props: PluginImplementationProps<TPlugin>);
    initialize(props: PluginRuntimeProps<TPlugin>): this;
    private get _runtime();
    private _getTools;
    get actionHandlers(): BotActionHandlersMap<TPlugin>;
    get messageHandlers(): BotMessageHandlersMap<TPlugin>;
    get eventHandlers(): BotEventHandlersMap<TPlugin>;
    get stateExpiredHandlers(): BotStateExpiredHandlersMap<TPlugin>;
    get hookHandlers(): BotHookHandlersMap<TPlugin>;
    get workflowHandlers(): BotWorkflowHandlersMap<TPlugin>;
    readonly on: {
        message: <T extends utils.types.StringKeys<MessageHandlersMap<TPlugin>>>(type: T, handler: MessageHandlers<TPlugin>[T]) => void;
        event: <T extends utils.types.StringKeys<EventHandlersMap<TPlugin>>>(type: T, handler: EventHandlers<TPlugin>[T]) => void;
        stateExpired: <T extends utils.types.StringKeys<StateExpiredHandlersMap<TPlugin>>>(type: T, handler: StateExpiredHandlers<TPlugin>[T]) => void;
        beforeIncomingEvent: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["before_incoming_event"]>>(type: T, handler: HookHandlers<TPlugin>["before_incoming_event"][T]) => void;
        beforeIncomingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["before_incoming_message"]>>(type: T, handler: HookHandlers<TPlugin>["before_incoming_message"][T]) => void;
        beforeOutgoingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["before_outgoing_message"]>>(type: T, handler: HookHandlers<TPlugin>["before_outgoing_message"][T]) => void;
        beforeOutgoingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["before_outgoing_call_action"]>>(type: T, handler: HookHandlers<TPlugin>["before_outgoing_call_action"][T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        beforeIncomingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["before_incoming_call_action"]>>(type: T, handler: HookHandlers<TPlugin>["before_incoming_call_action"][T]) => void;
        afterIncomingEvent: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["after_incoming_event"]>>(type: T, handler: HookHandlers<TPlugin>["after_incoming_event"][T]) => void;
        afterIncomingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["after_incoming_message"]>>(type: T, handler: HookHandlers<TPlugin>["after_incoming_message"][T]) => void;
        afterOutgoingMessage: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["after_outgoing_message"]>>(type: T, handler: HookHandlers<TPlugin>["after_outgoing_message"][T]) => void;
        afterOutgoingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["after_outgoing_call_action"]>>(type: T, handler: HookHandlers<TPlugin>["after_outgoing_call_action"][T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        afterIncomingCallAction: <T extends utils.types.StringKeys<HookHandlersMap<TPlugin>["after_incoming_call_action"]>>(type: T, handler: HookHandlers<TPlugin>["after_incoming_call_action"][T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        workflowStart: <T extends utils.types.StringKeys<WorkflowHandlersMap<TPlugin>["started"]>>(type: T, handler: WorkflowHandlers<TPlugin>[T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        workflowContinue: <T extends utils.types.StringKeys<WorkflowHandlersMap<TPlugin>["continued"]>>(type: T, handler: WorkflowHandlers<TPlugin>[T]) => void;
        /**
         * # EXPERIMENTAL
         * This API is experimental and may change in the future.
         */
        workflowTimeout: <T extends utils.types.StringKeys<WorkflowHandlersMap<TPlugin>["timed_out"]>>(type: T, handler: WorkflowHandlers<TPlugin>[T]) => void;
    };
    /**
     * checks if the actual event resolves to the target event
     */
    private _eventResolvesTo;
    private _stripAliasPrefix;
}
