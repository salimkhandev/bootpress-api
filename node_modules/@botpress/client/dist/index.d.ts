import { AxiosRequestConfig, AxiosInstance, AxiosError } from 'axios';
import * as axios from 'axios';
export { axios };
import { IAxiosRetryConfig } from 'axios-retry';
import * as axiosRetry from 'axios-retry';
export { axiosRetry };

type Headers = Record<string, string | string[]>;
type RetryConfig = IAxiosRetryConfig;
type ClientConfig = {
    apiUrl: string;
    headers: Headers;
    withCredentials: boolean;
    timeout: number;
    debug: boolean;
};

type CommonClientProps = {
    apiUrl?: string;
    timeout?: number;
    headers?: Headers;
    retry?: RetryConfig;
    debug?: boolean;
};
type Cast<T, U> = T extends U ? T : U;
type AsyncFunc = (...args: any[]) => Promise<any>;
type SimplifyTuple<T> = T extends [...infer A] ? {
    [K in keyof A]: Simplify<A[K]>;
} : never;
type SimplifyObject<T extends object> = T extends infer O ? {
    [K in keyof O]: Simplify<O[K]>;
} : never;
type Simplify<T> = T extends (...args: infer A) => infer R ? (...args: SimplifyTuple<A>) => Simplify<R> : T extends Array<infer E> ? Array<Simplify<E>> : T extends ReadonlyArray<infer E> ? ReadonlyArray<Simplify<E>> : T extends Promise<infer R> ? Promise<Simplify<R>> : T extends Buffer ? Buffer : T extends object ? SimplifyObject<T> : T;
type Operation$5<C extends Record<string, AsyncFunc>> = Simplify<keyof {
    [K in keyof C as C[K] extends AsyncFunc ? K : never]: C[K];
}>;
type Inputs<C extends Record<string, AsyncFunc>> = Simplify<{
    [T in Operation$5<C>]: Parameters<C[Cast<T, keyof C>]>[0];
}>;
type Outputs<C extends Record<string, AsyncFunc>> = Simplify<{
    [T in Operation$5<C>]: Awaited<ReturnType<C[Cast<T, keyof C>]>>;
}>;

type PageLister<R> = (t: {
    nextToken?: string;
}) => Promise<{
    items: R[];
    meta: {
        nextToken?: string;
    };
}>;
declare class AsyncCollection<T> {
    private _list;
    constructor(_list: PageLister<T>);
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<T>, void, unknown>;
    collect(props?: {
        limit?: number;
    }): Promise<T[]>;
}

type Primitive$4 = string | number | boolean;
type Value$4<P extends Primitive$4> = P | P[] | Record<string, P>;
type QueryValue$4 = Value$4<string> | Value$4<boolean> | Value$4<number> | undefined;
type AnyQueryParams$4 = Record<string, QueryValue$4>;
type HeaderValue$4 = string | undefined;
type AnyHeaderParams$4 = Record<string, HeaderValue$4>;
type AnyBodyParams$4 = Record<string, any>;
type ParsedRequest$4 = {
    method: string;
    path: string;
    query: AnyQueryParams$4;
    headers: AnyHeaderParams$4;
    body: AnyBodyParams$4;
};
declare const toAxiosRequest$4: (req: ParsedRequest$4) => AxiosRequestConfig;

interface CreateConversationRequestHeaders$1 {
}
interface CreateConversationRequestQuery$1 {
}
interface CreateConversationRequestParams$1 {
}
interface CreateConversationRequestBody$1 {
    /**
     * Channel name
     */
    channel: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a conversation from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
}
type CreateConversationInput$1 = CreateConversationRequestBody$1 & CreateConversationRequestHeaders$1 & CreateConversationRequestQuery$1 & CreateConversationRequestParams$1;
interface CreateConversationResponse$1 {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetConversationRequestHeaders$1 {
}
interface GetConversationRequestQuery$1 {
}
interface GetConversationRequestParams$1 {
    id: string;
}
interface GetConversationRequestBody$1 {
}
type GetConversationInput$1 = GetConversationRequestBody$1 & GetConversationRequestHeaders$1 & GetConversationRequestQuery$1 & GetConversationRequestParams$1;
interface GetConversationResponse$1 {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface ListConversationsRequestHeaders$1 {
}
interface ListConversationsRequestQuery$1 {
    nextToken?: string;
    sortField?: "createdAt" | "updatedAt";
    sortDirection?: "asc" | "desc";
    tags?: {
        [k: string]: string;
    };
    participantIds?: string[];
    integrationName?: string;
    channel?: string;
}
interface ListConversationsRequestParams$1 {
}
interface ListConversationsRequestBody$1 {
}
type ListConversationsInput$1 = ListConversationsRequestBody$1 & ListConversationsRequestHeaders$1 & ListConversationsRequestQuery$1 & ListConversationsRequestParams$1;
interface ListConversationsResponse$1 {
    conversations: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateConversationRequestHeaders$1 {
}
interface GetOrCreateConversationRequestQuery$1 {
}
interface GetOrCreateConversationRequestParams$1 {
}
interface GetOrCreateConversationRequestBody$1 {
    /**
     * Channel name
     */
    channel: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a conversation from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Optional list of tag names to use for strict matching when looking up existing conversations. If provided, all specified tags must match exactly for a conversation to be considered a match. For example, with an existing conversation whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateConversationInput$1 = GetOrCreateConversationRequestBody$1 & GetOrCreateConversationRequestHeaders$1 & GetOrCreateConversationRequestQuery$1 & GetOrCreateConversationRequestParams$1;
interface GetOrCreateConversationResponse$1 {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateConversationRequestHeaders$1 {
}
interface UpdateConversationRequestQuery$1 {
}
interface UpdateConversationRequestParams$1 {
    id: string;
}
interface UpdateConversationRequestBody$1 {
    currentTaskId?: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags?: {
        [k: string]: string;
    };
}
type UpdateConversationInput$1 = UpdateConversationRequestBody$1 & UpdateConversationRequestHeaders$1 & UpdateConversationRequestQuery$1 & UpdateConversationRequestParams$1;
interface UpdateConversationResponse$1 {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteConversationRequestHeaders$1 {
}
interface DeleteConversationRequestQuery$1 {
}
interface DeleteConversationRequestParams$1 {
    id: string;
}
interface DeleteConversationRequestBody$1 {
}
type DeleteConversationInput$1 = DeleteConversationRequestBody$1 & DeleteConversationRequestHeaders$1 & DeleteConversationRequestQuery$1 & DeleteConversationRequestParams$1;
interface DeleteConversationResponse$1 {
}

interface ListParticipantsRequestHeaders$1 {
}
interface ListParticipantsRequestQuery$1 {
    nextToken?: string;
}
interface ListParticipantsRequestParams$1 {
    id: string;
}
interface ListParticipantsRequestBody$1 {
}
type ListParticipantsInput$1 = ListParticipantsRequestBody$1 & ListParticipantsRequestHeaders$1 & ListParticipantsRequestQuery$1 & ListParticipantsRequestParams$1;
interface ListParticipantsResponse$1 {
    participants: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface AddParticipantRequestHeaders$1 {
}
interface AddParticipantRequestQuery$1 {
}
interface AddParticipantRequestParams$1 {
    id: string;
}
interface AddParticipantRequestBody$1 {
    /**
     * User id
     */
    userId: string;
}
type AddParticipantInput$1 = AddParticipantRequestBody$1 & AddParticipantRequestHeaders$1 & AddParticipantRequestQuery$1 & AddParticipantRequestParams$1;
interface AddParticipantResponse$1 {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    participant: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface GetParticipantRequestHeaders$1 {
}
interface GetParticipantRequestQuery$1 {
}
interface GetParticipantRequestParams$1 {
    id: string;
    userId: string;
}
interface GetParticipantRequestBody$1 {
}
type GetParticipantInput$1 = GetParticipantRequestBody$1 & GetParticipantRequestHeaders$1 & GetParticipantRequestQuery$1 & GetParticipantRequestParams$1;
interface GetParticipantResponse$1 {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    participant: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface RemoveParticipantRequestHeaders$1 {
}
interface RemoveParticipantRequestQuery$1 {
}
interface RemoveParticipantRequestParams$1 {
    id: string;
    userId: string;
}
interface RemoveParticipantRequestBody$1 {
}
type RemoveParticipantInput$1 = RemoveParticipantRequestBody$1 & RemoveParticipantRequestHeaders$1 & RemoveParticipantRequestQuery$1 & RemoveParticipantRequestParams$1;
interface RemoveParticipantResponse$1 {
}

interface CreateEventRequestHeaders$1 {
}
interface CreateEventRequestQuery$1 {
}
interface CreateEventRequestParams$1 {
}
interface CreateEventRequestBody$1 {
    /**
     * Type of the [Event](#schema_event).
     */
    type: string;
    /**
     * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our API.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Schedule the Event to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Event](#schema_event) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Event](#schema_event)
         */
        delay?: number;
    };
    /**
     * ID of the [Conversation](#schema_conversation) to link the event to.
     */
    conversationId?: string;
    /**
     * ID of the [User](#schema_user) to link the event to.
     */
    userId?: string;
    /**
     * ID of the [Workflow](#schema_workflow) to link the event to.
     */
    workflowId?: string;
    /**
     * ID of the [Message](#schema_message) to link the event to.
     */
    messageId?: string;
}
type CreateEventInput$1 = CreateEventRequestBody$1 & CreateEventRequestHeaders$1 & CreateEventRequestQuery$1 & CreateEventRequestParams$1;
interface CreateEventResponse$1 {
    /**
     * The event object represents an action or an occurrence.
     */
    event: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    };
}

interface GetEventRequestHeaders$1 {
}
interface GetEventRequestQuery$1 {
}
interface GetEventRequestParams$1 {
    id: string;
}
interface GetEventRequestBody$1 {
}
type GetEventInput$1 = GetEventRequestBody$1 & GetEventRequestHeaders$1 & GetEventRequestQuery$1 & GetEventRequestParams$1;
interface GetEventResponse$1 {
    /**
     * The event object represents an action or an occurrence.
     */
    event: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    };
}

interface ListEventsRequestHeaders$1 {
}
interface ListEventsRequestQuery$1 {
    nextToken?: string;
    type?: string;
    conversationId?: string;
    userId?: string;
    messageId?: string;
    workflowId?: string;
    status?: "pending" | "ignored" | "processed" | "failed" | "scheduled";
}
interface ListEventsRequestParams$1 {
}
interface ListEventsRequestBody$1 {
}
type ListEventsInput$1 = ListEventsRequestBody$1 & ListEventsRequestHeaders$1 & ListEventsRequestQuery$1 & ListEventsRequestParams$1;
interface ListEventsResponse$1 {
    events: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateMessageRequestHeaders$1 {
}
interface CreateMessageRequestQuery$1 {
}
interface CreateMessageRequestParams$1 {
}
interface CreateMessageRequestBody$1 {
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Message](#schema_message). The set of [Tags](/docs/developers/concepts/tags) available on a [Message](#schema_message) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Message](#schema_message) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Message](#schema_message)
         */
        delay?: number;
    };
    origin?: "synthetic";
}
type CreateMessageInput$1 = CreateMessageRequestBody$1 & CreateMessageRequestHeaders$1 & CreateMessageRequestQuery$1 & CreateMessageRequestParams$1;
interface CreateMessageResponse$1 {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface GetOrCreateMessageRequestHeaders$1 {
}
interface GetOrCreateMessageRequestQuery$1 {
}
interface GetOrCreateMessageRequestParams$1 {
}
interface GetOrCreateMessageRequestBody$1 {
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Message](#schema_message). The set of [Tags](/docs/developers/concepts/tags) available on a [Message](#schema_message) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Message](#schema_message) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Message](#schema_message)
         */
        delay?: number;
    };
    origin?: "synthetic";
    /**
     * Optional list of tag names to use for strict matching when looking up existing messages. If provided, all specified tags must match exactly for a message to be considered a match. For example, with an existing message whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateMessageInput$1 = GetOrCreateMessageRequestBody$1 & GetOrCreateMessageRequestHeaders$1 & GetOrCreateMessageRequestQuery$1 & GetOrCreateMessageRequestParams$1;
interface GetOrCreateMessageResponse$1 {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface GetMessageRequestHeaders$1 {
}
interface GetMessageRequestQuery$1 {
}
interface GetMessageRequestParams$1 {
    id: string;
}
interface GetMessageRequestBody$1 {
}
type GetMessageInput$1 = GetMessageRequestBody$1 & GetMessageRequestHeaders$1 & GetMessageRequestQuery$1 & GetMessageRequestParams$1;
interface GetMessageResponse$1 {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface UpdateMessageRequestHeaders$1 {
}
interface UpdateMessageRequestQuery$1 {
}
interface UpdateMessageRequestParams$1 {
    id: string;
}
interface UpdateMessageRequestBody$1 {
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload?: {
        [k: string]: any;
    };
}
type UpdateMessageInput$1 = UpdateMessageRequestBody$1 & UpdateMessageRequestHeaders$1 & UpdateMessageRequestQuery$1 & UpdateMessageRequestParams$1;
interface UpdateMessageResponse$1 {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface ListMessagesRequestHeaders$1 {
}
interface ListMessagesRequestQuery$1 {
    nextToken?: string;
    conversationId?: string;
    tags?: {
        [k: string]: string;
    };
}
interface ListMessagesRequestParams$1 {
}
interface ListMessagesRequestBody$1 {
}
type ListMessagesInput$1 = ListMessagesRequestBody$1 & ListMessagesRequestHeaders$1 & ListMessagesRequestQuery$1 & ListMessagesRequestParams$1;
interface ListMessagesResponse$1 {
    messages: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface DeleteMessageRequestHeaders$1 {
}
interface DeleteMessageRequestQuery$1 {
}
interface DeleteMessageRequestParams$1 {
    id: string;
}
interface DeleteMessageRequestBody$1 {
}
type DeleteMessageInput$1 = DeleteMessageRequestBody$1 & DeleteMessageRequestHeaders$1 & DeleteMessageRequestQuery$1 & DeleteMessageRequestParams$1;
interface DeleteMessageResponse$1 {
}

interface CreateUserRequestHeaders$1 {
}
interface CreateUserRequestQuery$1 {
}
interface CreateUserRequestParams$1 {
}
interface CreateUserRequestBody$1 {
    /**
     * Tags for the [User](#schema_user)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a [User](#schema_user) from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Name of the user
     */
    name?: string;
    /**
     * URI of the user picture
     */
    pictureUrl?: string;
}
type CreateUserInput$1 = CreateUserRequestBody$1 & CreateUserRequestHeaders$1 & CreateUserRequestQuery$1 & CreateUserRequestParams$1;
interface CreateUserResponse$1 {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface GetUserRequestHeaders$1 {
}
interface GetUserRequestQuery$1 {
}
interface GetUserRequestParams$1 {
    id: string;
}
interface GetUserRequestBody$1 {
}
type GetUserInput$1 = GetUserRequestBody$1 & GetUserRequestHeaders$1 & GetUserRequestQuery$1 & GetUserRequestParams$1;
interface GetUserResponse$1 {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface ListUsersRequestHeaders$1 {
}
interface ListUsersRequestQuery$1 {
    nextToken?: string;
    conversationId?: string;
    tags?: {
        [k: string]: string;
    };
}
interface ListUsersRequestParams$1 {
}
interface ListUsersRequestBody$1 {
}
type ListUsersInput$1 = ListUsersRequestBody$1 & ListUsersRequestHeaders$1 & ListUsersRequestQuery$1 & ListUsersRequestParams$1;
interface ListUsersResponse$1 {
    users: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateUserRequestHeaders$1 {
}
interface GetOrCreateUserRequestQuery$1 {
}
interface GetOrCreateUserRequestParams$1 {
}
interface GetOrCreateUserRequestBody$1 {
    /**
     * Tags for the [User](#schema_user)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a [User](#schema_user) from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Name of the user
     */
    name?: string;
    /**
     * URI of the user picture
     */
    pictureUrl?: string;
    /**
     * Optional list of tag names to use for strict matching when looking up existing users. If provided, all specified tags must match exactly for a user to be considered a match. For example, with an existing user whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateUserInput$1 = GetOrCreateUserRequestBody$1 & GetOrCreateUserRequestHeaders$1 & GetOrCreateUserRequestQuery$1 & GetOrCreateUserRequestParams$1;
interface GetOrCreateUserResponse$1 {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface UpdateUserRequestHeaders$1 {
}
interface UpdateUserRequestQuery$1 {
}
interface UpdateUserRequestParams$1 {
    id: string;
}
interface UpdateUserRequestBody$1 {
    /**
     * Tags for the [User](#schema_user)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Name of the user
     */
    name?: string | null;
    /**
     * URI of the user picture
     */
    pictureUrl?: string | null;
}
type UpdateUserInput$1 = UpdateUserRequestBody$1 & UpdateUserRequestHeaders$1 & UpdateUserRequestQuery$1 & UpdateUserRequestParams$1;
interface UpdateUserResponse$1 {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface DeleteUserRequestHeaders$1 {
}
interface DeleteUserRequestQuery$1 {
}
interface DeleteUserRequestParams$1 {
    id: string;
}
interface DeleteUserRequestBody$1 {
}
type DeleteUserInput$1 = DeleteUserRequestBody$1 & DeleteUserRequestHeaders$1 & DeleteUserRequestQuery$1 & DeleteUserRequestParams$1;
interface DeleteUserResponse$1 {
}

interface SetStateExpiryRequestHeaders$1 {
}
interface SetStateExpiryRequestQuery$1 {
}
interface SetStateExpiryRequestParams$1 {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface SetStateExpiryRequestBody$1 {
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry: number | null;
}
type SetStateExpiryInput$1 = SetStateExpiryRequestBody$1 & SetStateExpiryRequestHeaders$1 & SetStateExpiryRequestQuery$1 & SetStateExpiryRequestParams$1;
interface SetStateExpiryResponse$1 {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface GetStateRequestHeaders$1 {
}
interface GetStateRequestQuery$1 {
}
interface GetStateRequestParams$1 {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface GetStateRequestBody$1 {
}
type GetStateInput$1 = GetStateRequestBody$1 & GetStateRequestHeaders$1 & GetStateRequestQuery$1 & GetStateRequestParams$1;
interface GetStateResponse$1 {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
    meta: {
        cached: boolean;
    };
}

interface SetStateRequestHeaders$1 {
}
interface SetStateRequestQuery$1 {
}
interface SetStateRequestParams$1 {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface SetStateRequestBody$1 {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    } | null;
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry?: number | null;
}
type SetStateInput$1 = SetStateRequestBody$1 & SetStateRequestHeaders$1 & SetStateRequestQuery$1 & SetStateRequestParams$1;
interface SetStateResponse$1 {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface GetOrSetStateRequestHeaders$1 {
}
interface GetOrSetStateRequestQuery$1 {
}
interface GetOrSetStateRequestParams$1 {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface GetOrSetStateRequestBody$1 {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry?: number | null;
}
type GetOrSetStateInput$1 = GetOrSetStateRequestBody$1 & GetOrSetStateRequestHeaders$1 & GetOrSetStateRequestQuery$1 & GetOrSetStateRequestParams$1;
interface GetOrSetStateResponse$1 {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
    meta: {
        cached: boolean;
    };
}

interface PatchStateRequestHeaders$1 {
}
interface PatchStateRequestQuery$1 {
}
interface PatchStateRequestParams$1 {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface PatchStateRequestBody$1 {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
}
type PatchStateInput$1 = PatchStateRequestBody$1 & PatchStateRequestHeaders$1 & PatchStateRequestQuery$1 & PatchStateRequestParams$1;
interface PatchStateResponse$1 {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface CallActionRequestHeaders$1 {
}
interface CallActionRequestQuery$1 {
}
interface CallActionRequestParams$1 {
}
interface CallActionRequestBody$1 {
    /**
     * Type of the action
     */
    type: string;
    /**
     * Input of the action
     */
    input: {
        [k: string]: any;
    };
}
type CallActionInput$1 = CallActionRequestBody$1 & CallActionRequestHeaders$1 & CallActionRequestQuery$1 & CallActionRequestParams$1;
interface CallActionResponse$1 {
    /**
     * Input of the action
     */
    output: {
        [k: string]: any;
    };
    meta: {
        cached: boolean;
    };
}

interface ConfigureIntegrationRequestHeaders$1 {
}
interface ConfigureIntegrationRequestQuery$1 {
}
interface ConfigureIntegrationRequestParams$1 {
}
interface ConfigureIntegrationRequestBody$1 {
    /**
     * Unique identifier of the integration that was installed on the bot
     */
    identifier?: string | null;
    /**
     * Recurring schedule on which `register()` will be called on the integration
     */
    scheduleRegisterCall?: "hourly" | "daily" | "weekly" | "bi-weekly" | "monthly" | "bi-monthly" | "quarterly" | "yearly";
    /**
     * **EXPERIMENTAL** Sandbox identifiers for the integration. Setting this to null will remove all sandbox identifiers.           This is an experimental feature meant to be used by specific integrations.
     */
    sandboxIdentifiers?: {} | null;
}
type ConfigureIntegrationInput$1 = ConfigureIntegrationRequestBody$1 & ConfigureIntegrationRequestHeaders$1 & ConfigureIntegrationRequestQuery$1 & ConfigureIntegrationRequestParams$1;
interface ConfigureIntegrationResponse$1 {
}

interface GetTaskRequestHeaders$1 {
}
interface GetTaskRequestQuery$1 {
}
interface GetTaskRequestParams$1 {
    id: string;
}
interface GetTaskRequestBody$1 {
}
type GetTaskInput$1 = GetTaskRequestBody$1 & GetTaskRequestHeaders$1 & GetTaskRequestQuery$1 & GetTaskRequestParams$1;
interface GetTaskResponse$1 {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface CreateTaskRequestHeaders$1 {
}
interface CreateTaskRequestQuery$1 {
}
interface CreateTaskRequestParams$1 {
}
interface CreateTaskRequestBody$1 {
    /**
     * Title describing the task
     */
    title?: string;
    /**
     * All the notes related to the execution of the current task
     */
    description?: string;
    /**
     * Type of the task
     */
    type: string;
    /**
     * Content related to the task
     */
    data?: {
        [k: string]: any;
    };
    /**
     * Parent task id is the parent task that created this task
     */
    parentTaskId?: string;
    /**
     * Conversation id related to this task
     */
    conversationId: string;
    /**
     * Specific user related to this task
     */
    userId?: string;
    /**
     * The timeout date where the task should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Task](#schema_task)
     */
    tags?: {
        [k: string]: string;
    };
}
type CreateTaskInput$1 = CreateTaskRequestBody$1 & CreateTaskRequestHeaders$1 & CreateTaskRequestQuery$1 & CreateTaskRequestParams$1;
interface CreateTaskResponse$1 {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateTaskRequestHeaders$1 {
}
interface UpdateTaskRequestQuery$1 {
}
interface UpdateTaskRequestParams$1 {
    id: string;
}
interface UpdateTaskRequestBody$1 {
    /**
     * Title describing the task
     */
    title?: string;
    /**
     * All the notes related to the execution of the current task
     */
    description?: string;
    /**
     * Content related to the task
     */
    data?: {
        [k: string]: any;
    };
    /**
     * The timeout date where the task should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Status of the task
     */
    status?: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
    /**
     * Tags for the [Task](#schema_task)
     */
    tags?: {
        [k: string]: string;
    };
}
type UpdateTaskInput$1 = UpdateTaskRequestBody$1 & UpdateTaskRequestHeaders$1 & UpdateTaskRequestQuery$1 & UpdateTaskRequestParams$1;
interface UpdateTaskResponse$1 {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteTaskRequestHeaders$1 {
}
interface DeleteTaskRequestQuery$1 {
}
interface DeleteTaskRequestParams$1 {
    id: string;
}
interface DeleteTaskRequestBody$1 {
}
type DeleteTaskInput$1 = DeleteTaskRequestBody$1 & DeleteTaskRequestHeaders$1 & DeleteTaskRequestQuery$1 & DeleteTaskRequestParams$1;
interface DeleteTaskResponse$1 {
}

interface ListTasksRequestHeaders$1 {
}
interface ListTasksRequestQuery$1 {
    nextToken?: string;
    tags?: {
        [k: string]: string;
    };
    conversationId?: string;
    userId?: string;
    parentTaskId?: string;
    status?: ("pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled")[];
    type?: string;
}
interface ListTasksRequestParams$1 {
}
interface ListTasksRequestBody$1 {
}
type ListTasksInput$1 = ListTasksRequestBody$1 & ListTasksRequestHeaders$1 & ListTasksRequestQuery$1 & ListTasksRequestParams$1;
interface ListTasksResponse$1 {
    tasks: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateWorkflowRequestHeaders$1 {
}
interface CreateWorkflowRequestQuery$1 {
}
interface CreateWorkflowRequestParams$1 {
}
interface CreateWorkflowRequestBody$1 {
    /**
     * Name of the workflow
     */
    name: string;
    /**
     * Content related to the workflow
     */
    input?: {
        [k: string]: any;
    };
    /**
     * Parent workflow id is the parent workflow that created this workflow
     */
    parentWorkflowId?: string;
    /**
     * Conversation id related to this workflow
     */
    conversationId?: string;
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    status: "pending" | "in_progress" | "listening";
    /**
     * Event id must be specified if the workflow is created with the status in_progress
     */
    eventId?: string;
}
type CreateWorkflowInput$1 = CreateWorkflowRequestBody$1 & CreateWorkflowRequestHeaders$1 & CreateWorkflowRequestQuery$1 & CreateWorkflowRequestParams$1;
interface CreateWorkflowResponse$1 {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetWorkflowRequestHeaders$1 {
}
interface GetWorkflowRequestQuery$1 {
}
interface GetWorkflowRequestParams$1 {
    id: string;
}
interface GetWorkflowRequestBody$1 {
}
type GetWorkflowInput$1 = GetWorkflowRequestBody$1 & GetWorkflowRequestHeaders$1 & GetWorkflowRequestQuery$1 & GetWorkflowRequestParams$1;
interface GetWorkflowResponse$1 {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateWorkflowRequestHeaders$1 {
}
interface UpdateWorkflowRequestQuery$1 {
}
interface UpdateWorkflowRequestParams$1 {
    id: string;
}
interface UpdateWorkflowRequestBody$1 {
    /**
     * Content related to the workflow
     */
    output?: {
        [k: string]: any;
    };
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Status of the workflow
     */
    status?: "completed" | "cancelled" | "listening" | "paused" | "failed" | "in_progress";
    /**
     * Reason why the workflow failed
     */
    failureReason?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * Event id must be specified if the workflow is updated with the status in_progress
     */
    eventId?: string;
}
type UpdateWorkflowInput$1 = UpdateWorkflowRequestBody$1 & UpdateWorkflowRequestHeaders$1 & UpdateWorkflowRequestQuery$1 & UpdateWorkflowRequestParams$1;
interface UpdateWorkflowResponse$1 {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteWorkflowRequestHeaders$1 {
}
interface DeleteWorkflowRequestQuery$1 {
}
interface DeleteWorkflowRequestParams$1 {
    id: string;
}
interface DeleteWorkflowRequestBody$1 {
}
type DeleteWorkflowInput$1 = DeleteWorkflowRequestBody$1 & DeleteWorkflowRequestHeaders$1 & DeleteWorkflowRequestQuery$1 & DeleteWorkflowRequestParams$1;
interface DeleteWorkflowResponse$1 {
}

interface ListWorkflowsRequestHeaders$1 {
}
interface ListWorkflowsRequestQuery$1 {
    nextToken?: string;
    tags?: {
        [k: string]: string;
    };
    conversationId?: string;
    userId?: string;
    parentWorkflowId?: string;
    statuses?: ("pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled")[];
    name?: string;
}
interface ListWorkflowsRequestParams$1 {
}
interface ListWorkflowsRequestBody$1 {
}
type ListWorkflowsInput$1 = ListWorkflowsRequestBody$1 & ListWorkflowsRequestHeaders$1 & ListWorkflowsRequestQuery$1 & ListWorkflowsRequestParams$1;
interface ListWorkflowsResponse$1 {
    workflows: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateWorkflowRequestHeaders$1 {
}
interface GetOrCreateWorkflowRequestQuery$1 {
}
interface GetOrCreateWorkflowRequestParams$1 {
}
interface GetOrCreateWorkflowRequestBody$1 {
    /**
     * Name of the workflow
     */
    name: string;
    /**
     * Content related to the workflow
     */
    input?: {
        [k: string]: any;
    };
    /**
     * Parent workflow id is the parent workflow that created this workflow
     */
    parentWorkflowId?: string;
    /**
     * Conversation id related to this workflow
     */
    conversationId?: string;
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    status: "pending" | "in_progress" | "listening";
    /**
     * Event id must be specified if the workflow is created with the status in_progress
     */
    eventId?: string;
    /**
     * Optional list of tag names to use for strict matching when looking up existing workflows. If provided, all specified tags must match exactly for a workflow to be considered a match. For example, with an existing workflow whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateWorkflowInput$1 = GetOrCreateWorkflowRequestBody$1 & GetOrCreateWorkflowRequestHeaders$1 & GetOrCreateWorkflowRequestQuery$1 & GetOrCreateWorkflowRequestParams$1;
interface GetOrCreateWorkflowResponse$1 {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface ListTagValuesRequestHeaders$1 {
}
interface ListTagValuesRequestQuery$1 {
    nextToken?: string;
    type: "user" | "conversation" | "message";
}
interface ListTagValuesRequestParams$1 {
    key: string;
}
interface ListTagValuesRequestBody$1 {
}
type ListTagValuesInput$1 = ListTagValuesRequestBody$1 & ListTagValuesRequestHeaders$1 & ListTagValuesRequestQuery$1 & ListTagValuesRequestParams$1;
interface ListTagValuesResponse$1 {
    tags: {
        value: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface TrackAnalyticsRequestHeaders$1 {
}
interface TrackAnalyticsRequestQuery$1 {
}
interface TrackAnalyticsRequestParams$1 {
}
interface TrackAnalyticsRequestBody$1 {
    name: string;
    count: number;
}
type TrackAnalyticsInput$1 = TrackAnalyticsRequestBody$1 & TrackAnalyticsRequestHeaders$1 & TrackAnalyticsRequestQuery$1 & TrackAnalyticsRequestParams$1;
interface TrackAnalyticsResponse$1 {
}

type ClientProps$9 = {
    toAxiosRequest: typeof toAxiosRequest$4;
    toApiError: typeof toApiError$4;
};
declare class Client$9 {
    private axiosInstance;
    private props;
    constructor(axiosInstance: AxiosInstance, props?: Partial<ClientProps$9>);
    readonly createConversation: (input: CreateConversationInput$1) => Promise<CreateConversationResponse$1>;
    readonly getConversation: (input: GetConversationInput$1) => Promise<GetConversationResponse$1>;
    readonly listConversations: (input: ListConversationsInput$1) => Promise<ListConversationsResponse$1>;
    readonly getOrCreateConversation: (input: GetOrCreateConversationInput$1) => Promise<GetOrCreateConversationResponse$1>;
    readonly updateConversation: (input: UpdateConversationInput$1) => Promise<UpdateConversationResponse$1>;
    readonly deleteConversation: (input: DeleteConversationInput$1) => Promise<DeleteConversationResponse$1>;
    readonly listParticipants: (input: ListParticipantsInput$1) => Promise<ListParticipantsResponse$1>;
    readonly addParticipant: (input: AddParticipantInput$1) => Promise<AddParticipantResponse$1>;
    readonly getParticipant: (input: GetParticipantInput$1) => Promise<GetParticipantResponse$1>;
    readonly removeParticipant: (input: RemoveParticipantInput$1) => Promise<RemoveParticipantResponse$1>;
    readonly createEvent: (input: CreateEventInput$1) => Promise<CreateEventResponse$1>;
    readonly getEvent: (input: GetEventInput$1) => Promise<GetEventResponse$1>;
    readonly listEvents: (input: ListEventsInput$1) => Promise<ListEventsResponse$1>;
    readonly createMessage: (input: CreateMessageInput$1) => Promise<CreateMessageResponse$1>;
    readonly getOrCreateMessage: (input: GetOrCreateMessageInput$1) => Promise<GetOrCreateMessageResponse$1>;
    readonly getMessage: (input: GetMessageInput$1) => Promise<GetMessageResponse$1>;
    readonly updateMessage: (input: UpdateMessageInput$1) => Promise<UpdateMessageResponse$1>;
    readonly listMessages: (input: ListMessagesInput$1) => Promise<ListMessagesResponse$1>;
    readonly deleteMessage: (input: DeleteMessageInput$1) => Promise<DeleteMessageResponse$1>;
    readonly createUser: (input: CreateUserInput$1) => Promise<CreateUserResponse$1>;
    readonly getUser: (input: GetUserInput$1) => Promise<GetUserResponse$1>;
    readonly listUsers: (input: ListUsersInput$1) => Promise<ListUsersResponse$1>;
    readonly getOrCreateUser: (input: GetOrCreateUserInput$1) => Promise<GetOrCreateUserResponse$1>;
    readonly updateUser: (input: UpdateUserInput$1) => Promise<UpdateUserResponse$1>;
    readonly deleteUser: (input: DeleteUserInput$1) => Promise<DeleteUserResponse$1>;
    readonly setStateExpiry: (input: SetStateExpiryInput$1) => Promise<SetStateExpiryResponse$1>;
    readonly getState: (input: GetStateInput$1) => Promise<GetStateResponse$1>;
    readonly setState: (input: SetStateInput$1) => Promise<SetStateResponse$1>;
    readonly getOrSetState: (input: GetOrSetStateInput$1) => Promise<GetOrSetStateResponse$1>;
    readonly patchState: (input: PatchStateInput$1) => Promise<PatchStateResponse$1>;
    readonly callAction: (input: CallActionInput$1) => Promise<CallActionResponse$1>;
    readonly configureIntegration: (input: ConfigureIntegrationInput$1) => Promise<ConfigureIntegrationResponse$1>;
    readonly getTask: (input: GetTaskInput$1) => Promise<GetTaskResponse$1>;
    readonly createTask: (input: CreateTaskInput$1) => Promise<CreateTaskResponse$1>;
    readonly updateTask: (input: UpdateTaskInput$1) => Promise<UpdateTaskResponse$1>;
    readonly deleteTask: (input: DeleteTaskInput$1) => Promise<DeleteTaskResponse$1>;
    readonly listTasks: (input: ListTasksInput$1) => Promise<ListTasksResponse$1>;
    readonly createWorkflow: (input: CreateWorkflowInput$1) => Promise<CreateWorkflowResponse$1>;
    readonly getWorkflow: (input: GetWorkflowInput$1) => Promise<GetWorkflowResponse$1>;
    readonly updateWorkflow: (input: UpdateWorkflowInput$1) => Promise<UpdateWorkflowResponse$1>;
    readonly deleteWorkflow: (input: DeleteWorkflowInput$1) => Promise<DeleteWorkflowResponse$1>;
    readonly listWorkflows: (input: ListWorkflowsInput$1) => Promise<ListWorkflowsResponse$1>;
    readonly getOrCreateWorkflow: (input: GetOrCreateWorkflowInput$1) => Promise<GetOrCreateWorkflowResponse$1>;
    readonly listTagValues: (input: ListTagValuesInput$1) => Promise<ListTagValuesResponse$1>;
    readonly trackAnalytics: (input: TrackAnalyticsInput$1) => Promise<TrackAnalyticsResponse$1>;
}
declare function toApiError$4(err: unknown): Error;

type IClient$4 = Simplify<Client$9>;
type Operation$4 = Operation$5<IClient$4>;
type ClientInputs$4 = Inputs<IClient$4>;
type ClientOutputs$4 = Outputs<IClient$4>;
type ClientProps$8 = CommonClientProps & {
    token: string;
    botId: string;
    integrationId?: string;
    integrationAlias?: string;
};
declare class Client$8 extends Client$9 {
    readonly config: Readonly<ClientConfig>;
    constructor(clientProps: ClientProps$8);
    get list(): {
        conversations: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            channel?: string | undefined;
            integrationName?: string | undefined;
            sortField?: "createdAt" | "updatedAt" | undefined;
            sortDirection?: "asc" | "desc" | undefined;
            participantIds?: string[] | undefined;
        }) => AsyncCollection<{
            id: string;
            currentTaskId?: string;
            currentWorkflowId?: string;
            createdAt: string;
            updatedAt: string;
            channel: string;
            integration: string;
            tags: {
                [k: string]: string;
            };
        }>;
        participants: (props: {
            id: string;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            tags: {
                [k: string]: string;
            };
            name?: string;
            pictureUrl?: string;
        }>;
        events: (props: {
            status?: "pending" | "ignored" | "processed" | "failed" | "scheduled" | undefined;
            type?: string | undefined;
            userId?: string | undefined;
            conversationId?: string | undefined;
            workflowId?: string | undefined;
            messageId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            type: string;
            payload: {
                [k: string]: any;
            };
            conversationId?: string;
            userId?: string;
            messageId?: string;
            status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
            failureReason: string | null;
        }>;
        messages: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            conversationId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            type: string;
            payload: {
                [k: string]: any;
            };
            direction: "incoming" | "outgoing";
            userId: string;
            conversationId: string;
            tags: {
                [k: string]: string;
            };
            origin?: "synthetic";
        }>;
        users: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            conversationId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            tags: {
                [k: string]: string;
            };
            name?: string;
            pictureUrl?: string;
        }>;
        tasks: (props: {
            status?: ("timeout" | "pending" | "failed" | "in_progress" | "completed" | "blocked" | "paused" | "cancelled")[] | undefined;
            tags?: {
                [x: string]: string;
            } | undefined;
            type?: string | undefined;
            userId?: string | undefined;
            conversationId?: string | undefined;
            parentTaskId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            title: string;
            description: string;
            type: string;
            data: {
                [k: string]: any;
            };
            status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
            parentTaskId?: string;
            conversationId?: string;
            userId?: string;
            timeoutAt: string;
            createdAt: string;
            updatedAt: string;
            failureReason?: string;
            tags: {
                [k: string]: string;
            };
        }>;
    };
}

declare namespace index$3 {
  export { Client$8 as Client, type ClientInputs$4 as ClientInputs, type ClientOutputs$4 as ClientOutputs, type ClientProps$8 as ClientProps, type Operation$4 as Operation };
}

type Primitive$3 = string | number | boolean;
type Value$3<P extends Primitive$3> = P | P[] | Record<string, P>;
type QueryValue$3 = Value$3<string> | Value$3<boolean> | Value$3<number> | undefined;
type AnyQueryParams$3 = Record<string, QueryValue$3>;
type HeaderValue$3 = string | undefined;
type AnyHeaderParams$3 = Record<string, HeaderValue$3>;
type AnyBodyParams$3 = Record<string, any>;
type ParsedRequest$3 = {
    method: string;
    path: string;
    query: AnyQueryParams$3;
    headers: AnyHeaderParams$3;
    body: AnyBodyParams$3;
};
declare const toAxiosRequest$3: (req: ParsedRequest$3) => AxiosRequestConfig;

interface RunVrlRequestHeaders$1 {
}
interface RunVrlRequestQuery$1 {
}
interface RunVrlRequestParams$1 {
}
interface RunVrlRequestBody$1 {
    data: {
        [k: string]: any;
    };
    script: string;
}
type RunVrlInput$1 = RunVrlRequestBody$1 & RunVrlRequestHeaders$1 & RunVrlRequestQuery$1 & RunVrlRequestParams$1;
interface RunVrlResponse$1 {
    data: {
        [k: string]: any;
    };
    result?: any;
}

interface GetAccountRequestHeaders$1 {
}
interface GetAccountRequestQuery$1 {
}
interface GetAccountRequestParams$1 {
}
interface GetAccountRequestBody$1 {
}
type GetAccountInput$1 = GetAccountRequestBody$1 & GetAccountRequestHeaders$1 & GetAccountRequestQuery$1 & GetAccountRequestParams$1;
interface GetAccountResponse$1 {
    account: {
        id: string;
        email: string;
        displayName?: string;
        emailVerified: boolean;
        profilePicture?: string;
        /**
         * Creation date of the [Account](#schema_account) in ISO 8601 format
         */
        createdAt: string;
    };
}

interface UpdateAccountRequestHeaders$1 {
}
interface UpdateAccountRequestQuery$1 {
}
interface UpdateAccountRequestParams$1 {
}
interface UpdateAccountRequestBody$1 {
    displayName?: string;
    profilePicture?: string;
    refresh?: boolean;
}
type UpdateAccountInput$1 = UpdateAccountRequestBody$1 & UpdateAccountRequestHeaders$1 & UpdateAccountRequestQuery$1 & UpdateAccountRequestParams$1;
interface UpdateAccountResponse$1 {
    account: {
        id: string;
        email: string;
        displayName?: string;
        emailVerified: boolean;
        profilePicture?: string;
        /**
         * Creation date of the [Account](#schema_account) in ISO 8601 format
         */
        createdAt: string;
    };
}

interface DeleteAccountRequestHeaders$1 {
}
interface DeleteAccountRequestQuery$1 {
}
interface DeleteAccountRequestParams$1 {
}
interface DeleteAccountRequestBody$1 {
}
type DeleteAccountInput$1 = DeleteAccountRequestBody$1 & DeleteAccountRequestHeaders$1 & DeleteAccountRequestQuery$1 & DeleteAccountRequestParams$1;
interface DeleteAccountResponse$1 {
}

interface ListPersonalAccessTokensRequestHeaders$1 {
}
interface ListPersonalAccessTokensRequestQuery$1 {
}
interface ListPersonalAccessTokensRequestParams$1 {
}
interface ListPersonalAccessTokensRequestBody$1 {
}
type ListPersonalAccessTokensInput$1 = ListPersonalAccessTokensRequestBody$1 & ListPersonalAccessTokensRequestHeaders$1 & ListPersonalAccessTokensRequestQuery$1 & ListPersonalAccessTokensRequestParams$1;
interface ListPersonalAccessTokensResponse$1 {
    pats: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreatePersonalAccessTokenRequestHeaders$1 {
}
interface CreatePersonalAccessTokenRequestQuery$1 {
}
interface CreatePersonalAccessTokenRequestParams$1 {
}
interface CreatePersonalAccessTokenRequestBody$1 {
    /**
     * Note to identify the PAT
     */
    note: string;
}
type CreatePersonalAccessTokenInput$1 = CreatePersonalAccessTokenRequestBody$1 & CreatePersonalAccessTokenRequestHeaders$1 & CreatePersonalAccessTokenRequestQuery$1 & CreatePersonalAccessTokenRequestParams$1;
interface CreatePersonalAccessTokenResponse$1 {
    pat: {
        id: string;
        createdAt: string;
        note: string;
        /**
         * The PAT value. This will only be returned here when created and cannot be retrieved later.
         */
        value: string;
    };
}

interface DeletePersonalAccessTokenRequestHeaders$1 {
}
interface DeletePersonalAccessTokenRequestQuery$1 {
}
interface DeletePersonalAccessTokenRequestParams$1 {
    id: string;
}
interface DeletePersonalAccessTokenRequestBody$1 {
}
type DeletePersonalAccessTokenInput$1 = DeletePersonalAccessTokenRequestBody$1 & DeletePersonalAccessTokenRequestHeaders$1 & DeletePersonalAccessTokenRequestQuery$1 & DeletePersonalAccessTokenRequestParams$1;
interface DeletePersonalAccessTokenResponse$1 {
}

interface SetAccountPreferenceRequestHeaders$1 {
}
interface SetAccountPreferenceRequestQuery$1 {
}
interface SetAccountPreferenceRequestParams$1 {
    key: string;
}
interface SetAccountPreferenceRequestBody$1 {
    value?: any;
}
type SetAccountPreferenceInput$1 = SetAccountPreferenceRequestBody$1 & SetAccountPreferenceRequestHeaders$1 & SetAccountPreferenceRequestQuery$1 & SetAccountPreferenceRequestParams$1;
interface SetAccountPreferenceResponse$1 {
}

interface GetAccountPreferenceRequestHeaders$1 {
}
interface GetAccountPreferenceRequestQuery$1 {
}
interface GetAccountPreferenceRequestParams$1 {
    key: string;
}
interface GetAccountPreferenceRequestBody$1 {
}
type GetAccountPreferenceInput$1 = GetAccountPreferenceRequestBody$1 & GetAccountPreferenceRequestHeaders$1 & GetAccountPreferenceRequestQuery$1 & GetAccountPreferenceRequestParams$1;
interface GetAccountPreferenceResponse$1 {
    value?: any;
}

interface ListPublicIntegrationsRequestHeaders$1 {
}
interface ListPublicIntegrationsRequestQuery$1 {
    nextToken?: string;
    limit?: number;
    name?: string;
    version?: string;
    interfaceId?: string;
    interfaceName?: string;
    installedByBotId?: string;
    verificationStatus?: "unapproved" | "pending" | "approved" | "rejected";
    search?: string;
    sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount";
    direction?: "asc" | "desc";
}
interface ListPublicIntegrationsRequestParams$1 {
}
interface ListPublicIntegrationsRequestBody$1 {
}
type ListPublicIntegrationsInput$1 = ListPublicIntegrationsRequestBody$1 & ListPublicIntegrationsRequestHeaders$1 & ListPublicIntegrationsRequestQuery$1 & ListPublicIntegrationsRequestParams$1;
interface ListPublicIntegrationsResponse$1 {
    integrations: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
        meta: {
            installs: number;
            views: number;
        };
        /**
         * Metadata about which fields matched the search criteria
         */
        matchedOn?: {
            /**
             * Whether the integration name matched the search term
             */
            name?: boolean;
            /**
             * Whether the integration title matched the search term
             */
            title?: boolean;
            /**
             * Whether the integration description matched the search term
             */
            description?: boolean;
            /**
             * Action names that matched the search term
             */
            actions?: string[];
            /**
             * Interface names that matched the search term
             */
            interfaces?: string[];
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPublicIntegrationByIdRequestHeaders$1 {
}
interface GetPublicIntegrationByIdRequestQuery$1 {
}
interface GetPublicIntegrationByIdRequestParams$1 {
    id: string;
}
interface GetPublicIntegrationByIdRequestBody$1 {
}
type GetPublicIntegrationByIdInput$1 = GetPublicIntegrationByIdRequestBody$1 & GetPublicIntegrationByIdRequestHeaders$1 & GetPublicIntegrationByIdRequestQuery$1 & GetPublicIntegrationByIdRequestParams$1;
interface GetPublicIntegrationByIdResponse$1 {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
        meta: {
            installs: number;
            views: number;
        };
    };
}

interface GetPublicIntegrationRequestHeaders$1 {
}
interface GetPublicIntegrationRequestQuery$1 {
}
interface GetPublicIntegrationRequestParams$1 {
    name: string;
    version: string;
}
interface GetPublicIntegrationRequestBody$1 {
}
type GetPublicIntegrationInput$1 = GetPublicIntegrationRequestBody$1 & GetPublicIntegrationRequestHeaders$1 & GetPublicIntegrationRequestQuery$1 & GetPublicIntegrationRequestParams$1;
interface GetPublicIntegrationResponse$1 {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
        meta: {
            installs: number;
            views: number;
        };
    };
}

interface ListPublicPluginsRequestHeaders$1 {
}
interface ListPublicPluginsRequestQuery$1 {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListPublicPluginsRequestParams$1 {
}
interface ListPublicPluginsRequestBody$1 {
}
type ListPublicPluginsInput$1 = ListPublicPluginsRequestBody$1 & ListPublicPluginsRequestHeaders$1 & ListPublicPluginsRequestQuery$1 & ListPublicPluginsRequestParams$1;
interface ListPublicPluginsResponse$1 {
    plugins: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPublicPluginByIdRequestHeaders$1 {
}
interface GetPublicPluginByIdRequestQuery$1 {
}
interface GetPublicPluginByIdRequestParams$1 {
    id: string;
}
interface GetPublicPluginByIdRequestBody$1 {
}
type GetPublicPluginByIdInput$1 = GetPublicPluginByIdRequestBody$1 & GetPublicPluginByIdRequestHeaders$1 & GetPublicPluginByIdRequestQuery$1 & GetPublicPluginByIdRequestParams$1;
interface GetPublicPluginByIdResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetDereferencedPublicPluginByIdRequestHeaders$1 {
}
interface GetDereferencedPublicPluginByIdRequestQuery$1 {
    /**
     * Mapping of interface aliases to integration IDs
     */
    interfaces: {
        /**
         * integration id
         */
        [k: string]: string;
    };
}
interface GetDereferencedPublicPluginByIdRequestParams$1 {
    id: string;
}
interface GetDereferencedPublicPluginByIdRequestBody$1 {
}
type GetDereferencedPublicPluginByIdInput$1 = GetDereferencedPublicPluginByIdRequestBody$1 & GetDereferencedPublicPluginByIdRequestHeaders$1 & GetDereferencedPublicPluginByIdRequestQuery$1 & GetDereferencedPublicPluginByIdRequestParams$1;
interface GetDereferencedPublicPluginByIdResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPublicPluginRequestHeaders$1 {
}
interface GetPublicPluginRequestQuery$1 {
}
interface GetPublicPluginRequestParams$1 {
    name: string;
    version: string;
}
interface GetPublicPluginRequestBody$1 {
}
type GetPublicPluginInput$1 = GetPublicPluginRequestBody$1 & GetPublicPluginRequestHeaders$1 & GetPublicPluginRequestQuery$1 & GetPublicPluginRequestParams$1;
interface GetPublicPluginResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPublicPluginCodeRequestHeaders$1 {
}
interface GetPublicPluginCodeRequestQuery$1 {
}
interface GetPublicPluginCodeRequestParams$1 {
    id: string;
    platform: "node" | "browser";
}
interface GetPublicPluginCodeRequestBody$1 {
}
type GetPublicPluginCodeInput$1 = GetPublicPluginCodeRequestBody$1 & GetPublicPluginCodeRequestHeaders$1 & GetPublicPluginCodeRequestQuery$1 & GetPublicPluginCodeRequestParams$1;
interface GetPublicPluginCodeResponse$1 {
    code: string;
}

interface ListPublicInterfacesRequestHeaders$1 {
}
interface ListPublicInterfacesRequestQuery$1 {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListPublicInterfacesRequestParams$1 {
}
interface ListPublicInterfacesRequestBody$1 {
}
type ListPublicInterfacesInput$1 = ListPublicInterfacesRequestBody$1 & ListPublicInterfacesRequestHeaders$1 & ListPublicInterfacesRequestQuery$1 & ListPublicInterfacesRequestParams$1;
interface ListPublicInterfacesResponse$1 {
    interfaces: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPublicInterfaceByIdRequestHeaders$1 {
}
interface GetPublicInterfaceByIdRequestQuery$1 {
}
interface GetPublicInterfaceByIdRequestParams$1 {
    id: string;
}
interface GetPublicInterfaceByIdRequestBody$1 {
}
type GetPublicInterfaceByIdInput$1 = GetPublicInterfaceByIdRequestBody$1 & GetPublicInterfaceByIdRequestHeaders$1 & GetPublicInterfaceByIdRequestQuery$1 & GetPublicInterfaceByIdRequestParams$1;
interface GetPublicInterfaceByIdResponse$1 {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPublicInterfaceRequestHeaders$1 {
}
interface GetPublicInterfaceRequestQuery$1 {
}
interface GetPublicInterfaceRequestParams$1 {
    name: string;
    version: string;
}
interface GetPublicInterfaceRequestBody$1 {
}
type GetPublicInterfaceInput$1 = GetPublicInterfaceRequestBody$1 & GetPublicInterfaceRequestHeaders$1 & GetPublicInterfaceRequestQuery$1 & GetPublicInterfaceRequestParams$1;
interface GetPublicInterfaceResponse$1 {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface CreateBotRequestHeaders$1 {
}
interface CreateBotRequestQuery$1 {
}
interface CreateBotRequestParams$1 {
}
interface CreateBotRequestBody$1 {
    /**
     * A mapping of states to their definition
     */
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    /**
     * Events definition
     */
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    recurringEvents?: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
        };
    };
    /**
     * Subscriptions of the bot
     */
    subscriptions?: {
        /**
         * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
         */
        events: {
            [k: string]: {};
        } | null;
    };
    /**
     * Actions definition
     */
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    configuration?: {
        /**
         * Configuration data
         */
        data?: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
    };
    user?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    conversation?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    message?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Optional attributes of the [Bot](#schema_bot)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * JavaScript code of the bot
     */
    code?: string;
    /**
     * Optional name for the bot, if not provided will be auto-generated
     */
    name?: string;
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias?: {
        url: string;
        name: string;
    }[];
    /**
     * URL of the [Bot](#schema_bot); Only available for dev bots
     */
    url?: string;
    /**
     * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
     */
    dev?: boolean;
}
type CreateBotInput$1 = CreateBotRequestBody$1 & CreateBotRequestHeaders$1 & CreateBotRequestQuery$1 & CreateBotRequestParams$1;
interface CreateBotResponse$1 {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration. If the `x-multiple-integrations` header is present, this object is keyed by integration aliases. Otherwise, this object is keyed by integration ids.
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * Disabled channels for this integration
                 */
                disabledChannels: string[];
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * @deprecated
                 * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
                 */
                public: boolean;
                /**
                 * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
                 */
                visibility: "public" | "private" | "unlisted";
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * A mapping of plugin aliases to their configuration
         */
        plugins: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Plugin](#schema_plugin)
                 */
                name: string;
                /**
                 * Version of the [Plugin](#schema_plugin)
                 */
                version: string;
                configuration: {
                    [k: string]: any;
                };
                /**
                 * A mapping of plugin interface aliases to their backing integrations
                 */
                interfaces?: {
                    [k: string]: {
                        integrationId: string;
                        interfaceId: string;
                    };
                };
                /**
                 * ID of the [Plugin](#schema_plugin)
                 */
                id: string;
                /**
                 * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the plugin. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the plugin. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the plugin. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * URL of the readme of the plugin. This is the readme that will be displayed in the UI
                 */
                readmeUrl: string;
                /**
                 * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
            };
        };
        /**
         * Maximum execution time of the bot (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface UpdateBotRequestHeaders$1 {
}
interface UpdateBotRequestQuery$1 {
}
interface UpdateBotRequestParams$1 {
    id: string;
}
interface UpdateBotRequestBody$1 {
    /**
     * URL of the [Bot](#schema_bot); Only available for dev bots
     */
    url?: string;
    /**
     * Type of the [Bot](#schema_bot) authentication (`iam`)
     */
    authentication?: "iam";
    configuration?: {
        /**
         * Configuration data
         */
        data?: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
    };
    /**
     * Optional attributes of the [Bot](#schema_bot)
     */
    tags?: {
        [k: string]: string;
    };
    blocked?: boolean;
    /**
     * Maximum execution time (in seconds).
     */
    maxExecutionTime?: number;
    /**
     * Indicates if the [Bot](#schema_bot) should be in always alive mode
     */
    alwaysAlive?: boolean;
    user?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    message?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    conversation?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        } | null;
    };
    recurringEvents?: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
        } | null;
    };
    integrations?: {
        [k: string]: {
            enabled?: boolean;
            /**
             * Integration's definition ID. If defined, the record's key is treated as an alias for the integration instance.
             */
            integrationId?: string;
            /**
             * Integration's configuration type. Set to default if null.
             */
            configurationType?: string | null;
            configuration?: {
                [k: string]: any;
            };
            /**
             * Disabled channels for this integration
             */
            disabledChannels?: string[];
        } | null;
    };
    /**
     * A mapping of plugin aliases to their configuration
     */
    plugins?: {
        [k: string]: {
            id: string;
            enabled?: boolean;
            configuration?: {
                [k: string]: any;
            };
            /**
             * A mapping of plugin interface aliases to their backing integrations
             */
            interfaces?: {
                [k: string]: {
                    integrationId: string;
                };
            };
        } | null;
    };
    subscriptions?: {
        events: {
            [k: string]: {} | null;
        } | null;
    };
    /**
     * JavaScript code of the bot
     */
    code?: string;
    /**
     * Optional name for the bot, if not provided will be auto-generated
     */
    name?: string;
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias?: {
        url: string;
        name: string;
    }[];
    layers?: string[];
    /**
     * UNUSED. Please ignore this field. It will be removed in the near future.
     */
    shouldMergePlugins?: boolean;
}
type UpdateBotInput$1 = UpdateBotRequestBody$1 & UpdateBotRequestHeaders$1 & UpdateBotRequestQuery$1 & UpdateBotRequestParams$1;
interface UpdateBotResponse$1 {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration. If the `x-multiple-integrations` header is present, this object is keyed by integration aliases. Otherwise, this object is keyed by integration ids.
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * Disabled channels for this integration
                 */
                disabledChannels: string[];
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * @deprecated
                 * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
                 */
                public: boolean;
                /**
                 * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
                 */
                visibility: "public" | "private" | "unlisted";
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * A mapping of plugin aliases to their configuration
         */
        plugins: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Plugin](#schema_plugin)
                 */
                name: string;
                /**
                 * Version of the [Plugin](#schema_plugin)
                 */
                version: string;
                configuration: {
                    [k: string]: any;
                };
                /**
                 * A mapping of plugin interface aliases to their backing integrations
                 */
                interfaces?: {
                    [k: string]: {
                        integrationId: string;
                        interfaceId: string;
                    };
                };
                /**
                 * ID of the [Plugin](#schema_plugin)
                 */
                id: string;
                /**
                 * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the plugin. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the plugin. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the plugin. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * URL of the readme of the plugin. This is the readme that will be displayed in the UI
                 */
                readmeUrl: string;
                /**
                 * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
            };
        };
        /**
         * Maximum execution time of the bot (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface TransferBotRequestHeaders$1 {
}
interface TransferBotRequestQuery$1 {
}
interface TransferBotRequestParams$1 {
    id: string;
}
interface TransferBotRequestBody$1 {
    /**
     * The ID of the workspace you want to transfer the bot to.
     */
    targetWorkspaceId: string;
}
type TransferBotInput$1 = TransferBotRequestBody$1 & TransferBotRequestHeaders$1 & TransferBotRequestQuery$1 & TransferBotRequestParams$1;
interface TransferBotResponse$1 {
}

interface ListBotsRequestHeaders$1 {
}
interface ListBotsRequestQuery$1 {
    dev?: boolean;
    tags?: {
        [k: string]: string;
    };
    nextToken?: string;
    sortField?: "createdAt" | "updatedAt";
    sortDirection?: "asc" | "desc";
}
interface ListBotsRequestParams$1 {
}
interface ListBotsRequestBody$1 {
}
type ListBotsInput$1 = ListBotsRequestBody$1 & ListBotsRequestHeaders$1 & ListBotsRequestQuery$1 & ListBotsRequestParams$1;
interface ListBotsResponse$1 {
    bots: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        name: string;
        deployedAt?: string;
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetBotRequestHeaders$1 {
}
interface GetBotRequestQuery$1 {
    shouldMergePlugins?: boolean;
}
interface GetBotRequestParams$1 {
    id: string;
}
interface GetBotRequestBody$1 {
}
type GetBotInput$1 = GetBotRequestBody$1 & GetBotRequestHeaders$1 & GetBotRequestQuery$1 & GetBotRequestParams$1;
interface GetBotResponse$1 {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration. If the `x-multiple-integrations` header is present, this object is keyed by integration aliases. Otherwise, this object is keyed by integration ids.
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * Disabled channels for this integration
                 */
                disabledChannels: string[];
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * @deprecated
                 * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
                 */
                public: boolean;
                /**
                 * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
                 */
                visibility: "public" | "private" | "unlisted";
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * A mapping of plugin aliases to their configuration
         */
        plugins: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Plugin](#schema_plugin)
                 */
                name: string;
                /**
                 * Version of the [Plugin](#schema_plugin)
                 */
                version: string;
                configuration: {
                    [k: string]: any;
                };
                /**
                 * A mapping of plugin interface aliases to their backing integrations
                 */
                interfaces?: {
                    [k: string]: {
                        integrationId: string;
                        interfaceId: string;
                    };
                };
                /**
                 * ID of the [Plugin](#schema_plugin)
                 */
                id: string;
                /**
                 * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the plugin. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the plugin. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the plugin. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * URL of the readme of the plugin. This is the readme that will be displayed in the UI
                 */
                readmeUrl: string;
                /**
                 * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
            };
        };
        /**
         * Maximum execution time of the bot (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface DeleteBotRequestHeaders$1 {
}
interface DeleteBotRequestQuery$1 {
}
interface DeleteBotRequestParams$1 {
    id: string;
}
interface DeleteBotRequestBody$1 {
}
type DeleteBotInput$1 = DeleteBotRequestBody$1 & DeleteBotRequestHeaders$1 & DeleteBotRequestQuery$1 & DeleteBotRequestParams$1;
interface DeleteBotResponse$1 {
}

interface GetBotLogsRequestHeaders$1 {
}
interface GetBotLogsRequestQuery$1 {
    timeStart: string;
    timeEnd?: string;
    level?: string;
    userId?: string;
    workflowId?: string;
    conversationId?: string;
    messageContains?: string;
    nextToken?: string;
}
interface GetBotLogsRequestParams$1 {
    id: string;
}
interface GetBotLogsRequestBody$1 {
}
type GetBotLogsInput$1 = GetBotLogsRequestBody$1 & GetBotLogsRequestHeaders$1 & GetBotLogsRequestQuery$1 & GetBotLogsRequestParams$1;
interface GetBotLogsResponse$1 {
    logs: {
        timestamp: string;
        level: string;
        message: string;
        workflowId?: string;
        userId?: string;
        conversationId?: string;
    }[];
    nextToken?: string;
}

interface GetBotWebchatRequestHeaders$1 {
}
interface GetBotWebchatRequestQuery$1 {
    type: "preconfigured" | "configurable" | "fullscreen" | "sharableUrl";
}
interface GetBotWebchatRequestParams$1 {
    id: string;
}
interface GetBotWebchatRequestBody$1 {
}
type GetBotWebchatInput$1 = GetBotWebchatRequestBody$1 & GetBotWebchatRequestHeaders$1 & GetBotWebchatRequestQuery$1 & GetBotWebchatRequestParams$1;
interface GetBotWebchatResponse$1 {
    code: string;
}

interface GetBotAnalyticsRequestHeaders$1 {
}
interface GetBotAnalyticsRequestQuery$1 {
    startDate: string;
    endDate: string;
}
interface GetBotAnalyticsRequestParams$1 {
    id: string;
}
interface GetBotAnalyticsRequestBody$1 {
}
type GetBotAnalyticsInput$1 = GetBotAnalyticsRequestBody$1 & GetBotAnalyticsRequestHeaders$1 & GetBotAnalyticsRequestQuery$1 & GetBotAnalyticsRequestParams$1;
interface GetBotAnalyticsResponse$1 {
    records: {
        /**
         * ISO 8601 date string of the beginning (inclusive) of the period
         */
        startDateTimeUtc: string;
        /**
         * ISO 8601 date string of the end (inclusive) of the period
         */
        endDateTimeUtc: string;
        returningUsers: number;
        newUsers: number;
        sessions: number;
        /**
         * Deprecated. Use `userMessages` instead.
         */
        messages: number;
        userMessages: number;
        botMessages: number;
        events: number;
        eventTypes: {
            [k: string]: number;
        };
        customEvents: {
            [k: string]: number;
        };
        llm: {
            calls: number;
            errors: number;
            inputTokens: number;
            outputTokens: number;
            /**
             * The time it took for the LLM to complete its response. Values are expressed in milliseconds
             */
            latency: {
                mean: number;
                sd: number;
                min: number;
                max: number;
            };
            /**
             * LLM response generation speed expressed in output tokens per second.
             */
            tokensPerSecond: {
                mean: number;
                sd: number;
                min: number;
                max: number;
            };
            /**
             * Values are expressed in U.S. dollars
             */
            cost: {
                sum: number;
                mean: number;
                sd: number;
                min: number;
                max: number;
            };
        };
    }[];
}

interface ListActionRunsRequestHeaders$1 {
}
interface ListActionRunsRequestQuery$1 {
    integrationName: string;
    timestampFrom?: string;
    timestampUntil?: string;
    nextToken?: string;
}
interface ListActionRunsRequestParams$1 {
    id: string;
}
interface ListActionRunsRequestBody$1 {
}
type ListActionRunsInput$1 = ListActionRunsRequestBody$1 & ListActionRunsRequestHeaders$1 & ListActionRunsRequestQuery$1 & ListActionRunsRequestParams$1;
interface ListActionRunsResponse$1 {
    data: {
        /**
         * ISO 8601 timestamp of the action run
         */
        timestamp: string;
        integrationName?: string;
        actionType: string;
        /**
         * Input of the action
         */
        input: {
            [k: string]: any;
        };
        /**
         * Output of the action
         */
        output: {
            [k: string]: any;
        } | null;
        status: "SUCCESS" | "FAILURE";
        durationMs: number;
        cached: boolean;
        errorMessage?: string | null;
    }[];
    meta: {
        nextToken?: string;
    };
}

interface GetBotIssueRequestHeaders$1 {
}
interface GetBotIssueRequestQuery$1 {
}
interface GetBotIssueRequestParams$1 {
    id: string;
    issueId: string;
}
interface GetBotIssueRequestBody$1 {
}
type GetBotIssueInput$1 = GetBotIssueRequestBody$1 & GetBotIssueRequestHeaders$1 & GetBotIssueRequestQuery$1 & GetBotIssueRequestParams$1;
interface GetBotIssueResponse$1 {
    issue: {
        id: string;
        code: string;
        createdAt: string;
        lastSeenAt: string;
        title: string;
        description: string;
        groupedData: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
        eventsCount: number;
        category: "user_code" | "limits" | "configuration" | "other";
        resolutionLink: string | null;
    };
}

interface ListBotIssuesRequestHeaders$1 {
}
interface ListBotIssuesRequestQuery$1 {
    nextToken?: string;
}
interface ListBotIssuesRequestParams$1 {
    id: string;
}
interface ListBotIssuesRequestBody$1 {
}
type ListBotIssuesInput$1 = ListBotIssuesRequestBody$1 & ListBotIssuesRequestHeaders$1 & ListBotIssuesRequestQuery$1 & ListBotIssuesRequestParams$1;
interface ListBotIssuesResponse$1 {
    issues: {
        id: string;
        code: string;
        createdAt: string;
        lastSeenAt: string;
        title: string;
        description: string;
        groupedData: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
        eventsCount: number;
        category: "user_code" | "limits" | "configuration" | "other";
        resolutionLink: string | null;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface DeleteBotIssueRequestHeaders$1 {
}
interface DeleteBotIssueRequestQuery$1 {
}
interface DeleteBotIssueRequestParams$1 {
    id: string;
    issueId: string;
}
interface DeleteBotIssueRequestBody$1 {
}
type DeleteBotIssueInput$1 = DeleteBotIssueRequestBody$1 & DeleteBotIssueRequestHeaders$1 & DeleteBotIssueRequestQuery$1 & DeleteBotIssueRequestParams$1;
interface DeleteBotIssueResponse$1 {
}

interface ListBotIssueEventsRequestHeaders$1 {
}
interface ListBotIssueEventsRequestQuery$1 {
}
interface ListBotIssueEventsRequestParams$1 {
    id: string;
    issueId: string;
}
interface ListBotIssueEventsRequestBody$1 {
}
type ListBotIssueEventsInput$1 = ListBotIssueEventsRequestBody$1 & ListBotIssueEventsRequestHeaders$1 & ListBotIssueEventsRequestQuery$1 & ListBotIssueEventsRequestParams$1;
interface ListBotIssueEventsResponse$1 {
    issueEvents: {
        id: string;
        createdAt: string;
        data: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
    }[];
}

interface ListBotVersionsRequestHeaders$1 {
}
interface ListBotVersionsRequestQuery$1 {
}
interface ListBotVersionsRequestParams$1 {
    id: string;
}
interface ListBotVersionsRequestBody$1 {
}
type ListBotVersionsInput$1 = ListBotVersionsRequestBody$1 & ListBotVersionsRequestHeaders$1 & ListBotVersionsRequestQuery$1 & ListBotVersionsRequestParams$1;
interface ListBotVersionsResponse$1 {
    versions: {
        id: string;
        name: string;
        description?: string;
    }[];
}

interface GetBotVersionRequestHeaders$1 {
}
interface GetBotVersionRequestQuery$1 {
}
interface GetBotVersionRequestParams$1 {
    id: string;
    versionId: string;
}
interface GetBotVersionRequestBody$1 {
}
type GetBotVersionInput$1 = GetBotVersionRequestBody$1 & GetBotVersionRequestHeaders$1 & GetBotVersionRequestQuery$1 & GetBotVersionRequestParams$1;
interface GetBotVersionResponse$1 {
    url: string;
}

interface GetBotJsonRequestHeaders$1 {
}
interface GetBotJsonRequestQuery$1 {
}
interface GetBotJsonRequestParams$1 {
    id: string;
}
interface GetBotJsonRequestBody$1 {
}
type GetBotJsonInput$1 = GetBotJsonRequestBody$1 & GetBotJsonRequestHeaders$1 & GetBotJsonRequestQuery$1 & GetBotJsonRequestParams$1;
interface GetBotJsonResponse$1 {
    [k: string]: any;
}

interface PublishFromBotJsonRequestHeaders$1 {
}
interface PublishFromBotJsonRequestQuery$1 {
}
interface PublishFromBotJsonRequestParams$1 {
    id: string;
}
interface PublishFromBotJsonRequestBody$1 {
    botJson: {
        [k: string]: any;
    };
}
type PublishFromBotJsonInput$1 = PublishFromBotJsonRequestBody$1 & PublishFromBotJsonRequestHeaders$1 & PublishFromBotJsonRequestQuery$1 & PublishFromBotJsonRequestParams$1;
interface PublishFromBotJsonResponse$1 {
    [k: string]: any;
}

interface CreateBotVersionRequestHeaders$1 {
}
interface CreateBotVersionRequestQuery$1 {
}
interface CreateBotVersionRequestParams$1 {
    id: string;
}
interface CreateBotVersionRequestBody$1 {
    name: string;
    description?: string;
}
type CreateBotVersionInput$1 = CreateBotVersionRequestBody$1 & CreateBotVersionRequestHeaders$1 & CreateBotVersionRequestQuery$1 & CreateBotVersionRequestParams$1;
interface CreateBotVersionResponse$1 {
    version: {
        id: string;
        name: string;
        description?: string;
    };
}

interface DeployBotVersionRequestHeaders$1 {
}
interface DeployBotVersionRequestQuery$1 {
}
interface DeployBotVersionRequestParams$1 {
    id: string;
}
interface DeployBotVersionRequestBody$1 {
    versionId: string;
}
type DeployBotVersionInput$1 = DeployBotVersionRequestBody$1 & DeployBotVersionRequestHeaders$1 & DeployBotVersionRequestQuery$1 & DeployBotVersionRequestParams$1;
interface DeployBotVersionResponse$1 {
}

interface CreateIntegrationShareableIdRequestHeaders$1 {
}
interface CreateIntegrationShareableIdRequestQuery$1 {
}
interface CreateIntegrationShareableIdRequestParams$1 {
    botId: string;
    integrationId: string;
}
interface CreateIntegrationShareableIdRequestBody$1 {
}
type CreateIntegrationShareableIdInput$1 = CreateIntegrationShareableIdRequestBody$1 & CreateIntegrationShareableIdRequestHeaders$1 & CreateIntegrationShareableIdRequestQuery$1 & CreateIntegrationShareableIdRequestParams$1;
interface CreateIntegrationShareableIdResponse$1 {
    shareableId: string;
}

interface DeleteIntegrationShareableIdRequestHeaders$1 {
}
interface DeleteIntegrationShareableIdRequestQuery$1 {
}
interface DeleteIntegrationShareableIdRequestParams$1 {
    botId: string;
    integrationId: string;
}
interface DeleteIntegrationShareableIdRequestBody$1 {
}
type DeleteIntegrationShareableIdInput$1 = DeleteIntegrationShareableIdRequestBody$1 & DeleteIntegrationShareableIdRequestHeaders$1 & DeleteIntegrationShareableIdRequestQuery$1 & DeleteIntegrationShareableIdRequestParams$1;
interface DeleteIntegrationShareableIdResponse$1 {
}

interface GetIntegrationShareableIdRequestHeaders$1 {
}
interface GetIntegrationShareableIdRequestQuery$1 {
}
interface GetIntegrationShareableIdRequestParams$1 {
    botId: string;
    integrationId: string;
}
interface GetIntegrationShareableIdRequestBody$1 {
}
type GetIntegrationShareableIdInput$1 = GetIntegrationShareableIdRequestBody$1 & GetIntegrationShareableIdRequestHeaders$1 & GetIntegrationShareableIdRequestQuery$1 & GetIntegrationShareableIdRequestParams$1;
interface GetIntegrationShareableIdResponse$1 {
    shareableId: string;
    isExpired: boolean;
}

interface UnlinkSandboxedConversationsRequestHeaders$1 {
}
interface UnlinkSandboxedConversationsRequestQuery$1 {
}
interface UnlinkSandboxedConversationsRequestParams$1 {
    botId: string;
    integrationId: string;
}
interface UnlinkSandboxedConversationsRequestBody$1 {
}
type UnlinkSandboxedConversationsInput$1 = UnlinkSandboxedConversationsRequestBody$1 & UnlinkSandboxedConversationsRequestHeaders$1 & UnlinkSandboxedConversationsRequestQuery$1 & UnlinkSandboxedConversationsRequestParams$1;
interface UnlinkSandboxedConversationsResponse$1 {
}

interface ListBotApiKeysRequestHeaders$1 {
}
interface ListBotApiKeysRequestQuery$1 {
    botId: string;
}
interface ListBotApiKeysRequestParams$1 {
}
interface ListBotApiKeysRequestBody$1 {
}
type ListBotApiKeysInput$1 = ListBotApiKeysRequestBody$1 & ListBotApiKeysRequestHeaders$1 & ListBotApiKeysRequestQuery$1 & ListBotApiKeysRequestParams$1;
interface ListBotApiKeysResponse$1 {
    baks: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreateBotApiKeyRequestHeaders$1 {
}
interface CreateBotApiKeyRequestQuery$1 {
}
interface CreateBotApiKeyRequestParams$1 {
}
interface CreateBotApiKeyRequestBody$1 {
    botId: string;
    note?: string;
}
type CreateBotApiKeyInput$1 = CreateBotApiKeyRequestBody$1 & CreateBotApiKeyRequestHeaders$1 & CreateBotApiKeyRequestQuery$1 & CreateBotApiKeyRequestParams$1;
interface CreateBotApiKeyResponse$1 {
    id: string;
    createdAt: string;
    note: string;
    /**
     * The BAK value. This will only be returned here when created and cannot be retrieved later.
     */
    value: string;
}

interface DeleteBotApiKeyRequestHeaders$1 {
}
interface DeleteBotApiKeyRequestQuery$1 {
}
interface DeleteBotApiKeyRequestParams$1 {
    id: string;
}
interface DeleteBotApiKeyRequestBody$1 {
}
type DeleteBotApiKeyInput$1 = DeleteBotApiKeyRequestBody$1 & DeleteBotApiKeyRequestHeaders$1 & DeleteBotApiKeyRequestQuery$1 & DeleteBotApiKeyRequestParams$1;
interface DeleteBotApiKeyResponse$1 {
}

interface GetBotAllowlistRequestHeaders$1 {
}
interface GetBotAllowlistRequestQuery$1 {
}
interface GetBotAllowlistRequestParams$1 {
    botId: string;
}
interface GetBotAllowlistRequestBody$1 {
}
type GetBotAllowlistInput$1 = GetBotAllowlistRequestBody$1 & GetBotAllowlistRequestHeaders$1 & GetBotAllowlistRequestQuery$1 & GetBotAllowlistRequestParams$1;
interface GetBotAllowlistResponse$1 {
    /**
     * Allowlist setting of the bot
     */
    setting: "ALL_WORKSPACE_USERS" | "SELECTED_USERS";
    users: {
        id: string;
    }[];
}

interface UpdateBotAllowlistRequestHeaders$1 {
}
interface UpdateBotAllowlistRequestQuery$1 {
}
interface UpdateBotAllowlistRequestParams$1 {
    botId: string;
}
interface UpdateBotAllowlistRequestBody$1 {
    /**
     * Allowlist setting of the bot
     */
    setting?: "ALL_WORKSPACE_USERS" | "SELECTED_USERS";
    users?: {
        /**
         * If `true`, the user should be added to the allowlist. If `false`, the user should be removed from the allowlist. This performs a partial update, so any existing users not included here will be kept in the allowlist
         */
        [k: string]: boolean;
    };
}
type UpdateBotAllowlistInput$1 = UpdateBotAllowlistRequestBody$1 & UpdateBotAllowlistRequestHeaders$1 & UpdateBotAllowlistRequestQuery$1 & UpdateBotAllowlistRequestParams$1;
interface UpdateBotAllowlistResponse$1 {
}

interface ListWorkspaceInvoicesRequestHeaders$1 {
}
interface ListWorkspaceInvoicesRequestQuery$1 {
}
interface ListWorkspaceInvoicesRequestParams$1 {
    id: string;
}
interface ListWorkspaceInvoicesRequestBody$1 {
}
type ListWorkspaceInvoicesInput$1 = ListWorkspaceInvoicesRequestBody$1 & ListWorkspaceInvoicesRequestHeaders$1 & ListWorkspaceInvoicesRequestQuery$1 & ListWorkspaceInvoicesRequestParams$1;
interface ListWorkspaceInvoicesResponse$1 {
    invoices: {
        id: string;
        period: {
            month: number;
            year: number;
        };
        /**
         * Date on which the invoice was generated.
         */
        date: string;
        /**
         * Total amount to pay of the invoice.
         */
        amount: number;
        /**
         * Currency of the invoice amount.
         */
        currency: string;
        paymentStatus: ("deleted" | "draft" | "open" | "paid" | "uncollectible" | "void") | null;
        /**
         * Date on which the invoice is due.
         */
        dueDate?: string;
        /**
         * Number of times payment has been unsuccessfully attempted on the invoice.
         */
        paymentAttemptCount: number | null;
        /**
         * Date on which the next payment attempt will be made.
         */
        nextPaymentAttemptDate: string | null;
        /**
         * URL to download the PDF file of the invoice.
         */
        pdfUrl: string;
    }[];
}

interface GetUpcomingInvoiceRequestHeaders$1 {
}
interface GetUpcomingInvoiceRequestQuery$1 {
}
interface GetUpcomingInvoiceRequestParams$1 {
    id: string;
}
interface GetUpcomingInvoiceRequestBody$1 {
}
type GetUpcomingInvoiceInput$1 = GetUpcomingInvoiceRequestBody$1 & GetUpcomingInvoiceRequestHeaders$1 & GetUpcomingInvoiceRequestQuery$1 & GetUpcomingInvoiceRequestParams$1;
interface GetUpcomingInvoiceResponse$1 {
    /**
     * Total amount to pay of the invoice.
     */
    total: number;
    /**
     * List of items included in the invoice.
     */
    lineItems: {
        id: string;
        /**
         * Description of the line item.
         */
        description: string;
        /**
         * Total amount to pay (in cents) of the line item.
         */
        totalInCents: number;
        /**
         * Three-letter ISO currency code, in lowercase.
         */
        currency: string;
        /**
         * Price per unit (in cents) of the line item.
         */
        pricePerUnitInCents: number | null;
        /**
         * The quantity of the subscription, if the line item is a subscription or a proration.
         */
        quantity: number | null;
        /**
         * Type of the line item.
         */
        type: "invoiceitem" | "subscription";
        /**
         * Start date of the line item period.
         */
        periodStart: string | null;
        /**
         * End date of the line item period.
         */
        periodEnd: string | null;
    }[];
}

interface ChargeWorkspaceUnpaidInvoicesRequestHeaders$1 {
}
interface ChargeWorkspaceUnpaidInvoicesRequestQuery$1 {
}
interface ChargeWorkspaceUnpaidInvoicesRequestParams$1 {
    id: string;
}
interface ChargeWorkspaceUnpaidInvoicesRequestBody$1 {
    /**
     * @minItems 1
     */
    invoiceIds?: string[];
}
type ChargeWorkspaceUnpaidInvoicesInput$1 = ChargeWorkspaceUnpaidInvoicesRequestBody$1 & ChargeWorkspaceUnpaidInvoicesRequestHeaders$1 & ChargeWorkspaceUnpaidInvoicesRequestQuery$1 & ChargeWorkspaceUnpaidInvoicesRequestParams$1;
interface ChargeWorkspaceUnpaidInvoicesResponse$1 {
    /**
     * Invoices that were successfully charged by this request.
     */
    chargedInvoices: {
        id: string;
        amount: number;
    }[];
    /**
     * Invoices that failed to be charged by this request.
     */
    failedInvoices: {
        id: string;
        amount: number;
        failedReason: string;
    }[];
}

interface CreateWorkspaceRequestHeaders$1 {
}
interface CreateWorkspaceRequestQuery$1 {
}
interface CreateWorkspaceRequestParams$1 {
}
interface CreateWorkspaceRequestBody$1 {
    name: string;
}
type CreateWorkspaceInput$1 = CreateWorkspaceRequestBody$1 & CreateWorkspaceRequestHeaders$1 & CreateWorkspaceRequestQuery$1 & CreateWorkspaceRequestParams$1;
interface CreateWorkspaceResponse$1 {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface GetPublicWorkspaceRequestHeaders$1 {
}
interface GetPublicWorkspaceRequestQuery$1 {
}
interface GetPublicWorkspaceRequestParams$1 {
    id: string;
}
interface GetPublicWorkspaceRequestBody$1 {
}
type GetPublicWorkspaceInput$1 = GetPublicWorkspaceRequestBody$1 & GetPublicWorkspaceRequestHeaders$1 & GetPublicWorkspaceRequestQuery$1 & GetPublicWorkspaceRequestParams$1;
interface GetPublicWorkspaceResponse$3 {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    handle?: string;
}

interface GetWorkspaceRequestHeaders$1 {
}
interface GetWorkspaceRequestQuery$1 {
}
interface GetWorkspaceRequestParams$1 {
    id: string;
}
interface GetWorkspaceRequestBody$1 {
}
type GetWorkspaceInput$1 = GetWorkspaceRequestBody$1 & GetWorkspaceRequestHeaders$1 & GetWorkspaceRequestQuery$1 & GetWorkspaceRequestParams$1;
interface GetWorkspaceResponse$1 {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface ListWorkspaceUsagesRequestHeaders$1 {
}
interface ListWorkspaceUsagesRequestQuery$1 {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface ListWorkspaceUsagesRequestParams$1 {
    id: string;
}
interface ListWorkspaceUsagesRequestBody$1 {
}
type ListWorkspaceUsagesInput$1 = ListWorkspaceUsagesRequestBody$1 & ListWorkspaceUsagesRequestHeaders$1 & ListWorkspaceUsagesRequestQuery$1 & ListWorkspaceUsagesRequestParams$1;
interface ListWorkspaceUsagesResponse$1 {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface BreakDownWorkspaceUsageByBotRequestHeaders$1 {
}
interface BreakDownWorkspaceUsageByBotRequestQuery$1 {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface BreakDownWorkspaceUsageByBotRequestParams$1 {
    id: string;
}
interface BreakDownWorkspaceUsageByBotRequestBody$1 {
}
type BreakDownWorkspaceUsageByBotInput$1 = BreakDownWorkspaceUsageByBotRequestBody$1 & BreakDownWorkspaceUsageByBotRequestHeaders$1 & BreakDownWorkspaceUsageByBotRequestQuery$1 & BreakDownWorkspaceUsageByBotRequestParams$1;
interface BreakDownWorkspaceUsageByBotResponse$1 {
    data: {
        botId: string;
        value: number;
    }[];
}

interface GetAllWorkspaceQuotaCompletionRequestHeaders$1 {
}
interface GetAllWorkspaceQuotaCompletionRequestQuery$1 {
}
interface GetAllWorkspaceQuotaCompletionRequestParams$1 {
}
interface GetAllWorkspaceQuotaCompletionRequestBody$1 {
}
type GetAllWorkspaceQuotaCompletionInput$1 = GetAllWorkspaceQuotaCompletionRequestBody$1 & GetAllWorkspaceQuotaCompletionRequestHeaders$1 & GetAllWorkspaceQuotaCompletionRequestQuery$1 & GetAllWorkspaceQuotaCompletionRequestParams$1;
interface GetAllWorkspaceQuotaCompletionResponse$1 {
    [k: string]: {
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
        completion: number;
    };
}

interface GetWorkspaceQuotaRequestHeaders$1 {
}
interface GetWorkspaceQuotaRequestQuery$1 {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface GetWorkspaceQuotaRequestParams$1 {
    id: string;
}
interface GetWorkspaceQuotaRequestBody$1 {
}
type GetWorkspaceQuotaInput$1 = GetWorkspaceQuotaRequestBody$1 & GetWorkspaceQuotaRequestHeaders$1 & GetWorkspaceQuotaRequestQuery$1 & GetWorkspaceQuotaRequestParams$1;
interface GetWorkspaceQuotaResponse$1 {
    quota: {
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the quota that is used
         */
        value: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    };
}

interface ListWorkspaceQuotasRequestHeaders$1 {
}
interface ListWorkspaceQuotasRequestQuery$1 {
    period?: string;
}
interface ListWorkspaceQuotasRequestParams$1 {
    id: string;
}
interface ListWorkspaceQuotasRequestBody$1 {
}
type ListWorkspaceQuotasInput$1 = ListWorkspaceQuotasRequestBody$1 & ListWorkspaceQuotasRequestHeaders$1 & ListWorkspaceQuotasRequestQuery$1 & ListWorkspaceQuotasRequestParams$1;
interface ListWorkspaceQuotasResponse$1 {
    quotas: {
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the quota that is used
         */
        value: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface UpdateWorkspaceRequestHeaders$1 {
}
interface UpdateWorkspaceRequestQuery$1 {
}
interface UpdateWorkspaceRequestParams$1 {
    id: string;
}
interface UpdateWorkspaceRequestBody$1 {
    name?: string;
    spendingLimit?: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    /**
     * @maxItems 5
     */
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}
type UpdateWorkspaceInput$1 = UpdateWorkspaceRequestBody$1 & UpdateWorkspaceRequestHeaders$1 & UpdateWorkspaceRequestQuery$1 & UpdateWorkspaceRequestParams$1;
interface UpdateWorkspaceResponse$3 {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface CheckHandleAvailabilityRequestHeaders$1 {
}
interface CheckHandleAvailabilityRequestQuery$1 {
}
interface CheckHandleAvailabilityRequestParams$1 {
}
interface CheckHandleAvailabilityRequestBody$1 {
    handle: string;
}
type CheckHandleAvailabilityInput$1 = CheckHandleAvailabilityRequestBody$1 & CheckHandleAvailabilityRequestHeaders$1 & CheckHandleAvailabilityRequestQuery$1 & CheckHandleAvailabilityRequestParams$1;
interface CheckHandleAvailabilityResponse$1 {
    available: boolean;
    suggestions: string[];
    usedBy?: string;
}

interface ListWorkspacesRequestHeaders$1 {
}
interface ListWorkspacesRequestQuery$1 {
    nextToken?: string;
    handle?: string;
}
interface ListWorkspacesRequestParams$1 {
}
interface ListWorkspacesRequestBody$1 {
}
type ListWorkspacesInput$1 = ListWorkspacesRequestBody$1 & ListWorkspacesRequestHeaders$1 & ListWorkspacesRequestQuery$1 & ListWorkspacesRequestParams$1;
interface ListWorkspacesResponse$1 {
    workspaces: UpdateWorkspaceResponse$2[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}
interface UpdateWorkspaceResponse$2 {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface ListPublicWorkspacesRequestHeaders$1 {
}
interface ListPublicWorkspacesRequestQuery$1 {
    nextToken?: string;
    workspaceIds?: string[];
    search?: string;
}
interface ListPublicWorkspacesRequestParams$1 {
}
interface ListPublicWorkspacesRequestBody$1 {
}
type ListPublicWorkspacesInput$1 = ListPublicWorkspacesRequestBody$1 & ListPublicWorkspacesRequestHeaders$1 & ListPublicWorkspacesRequestQuery$1 & ListPublicWorkspacesRequestParams$1;
interface ListPublicWorkspacesResponse$1 {
    workspaces: GetPublicWorkspaceResponse$2[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}
interface GetPublicWorkspaceResponse$2 {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    handle?: string;
}

interface DeleteWorkspaceRequestHeaders$1 {
}
interface DeleteWorkspaceRequestQuery$1 {
}
interface DeleteWorkspaceRequestParams$1 {
    id: string;
}
interface DeleteWorkspaceRequestBody$1 {
}
type DeleteWorkspaceInput$1 = DeleteWorkspaceRequestBody$1 & DeleteWorkspaceRequestHeaders$1 & DeleteWorkspaceRequestQuery$1 & DeleteWorkspaceRequestParams$1;
interface DeleteWorkspaceResponse$1 {
}

interface GetAuditRecordsRequestHeaders$1 {
}
interface GetAuditRecordsRequestQuery$1 {
    nextToken?: string;
}
interface GetAuditRecordsRequestParams$1 {
    id: string;
}
interface GetAuditRecordsRequestBody$1 {
}
type GetAuditRecordsInput$1 = GetAuditRecordsRequestBody$1 & GetAuditRecordsRequestHeaders$1 & GetAuditRecordsRequestQuery$1 & GetAuditRecordsRequestParams$1;
interface GetAuditRecordsResponse$1 {
    records: {
        id: string;
        recordedAt: string;
        userId: string | null;
        userEmail?: string | null;
        resourceId: string | null;
        resourceName?: string | null;
        value?: string | null;
        action: "UNKNOWN" | "ADD_WORKSPACE_MEMBER" | "REMOVE_WORKSPACE_MEMBER" | "UPDATE_WORKSPACE_MEMBER" | "CLOSE_WORKSPACE" | "CREATE_BOT" | "CREATE_WORKSPACE" | "DELETE_BOT" | "DEPLOY_BOT" | "TRANSFER_BOT" | "DOWNLOAD_BOT_ARCHIVE" | "UPDATE_BOT" | "UPDATE_BOT_CHANNEL" | "UPDATE_BOT_CONFIG" | "UPDATE_PAYMENT_METHOD" | "UPDATE_WORKSPACE" | "SET_SPENDING_LIMIT" | "SET_AI_SPENDING_LIMIT" | "UPDATE_WORKSPACE_BILLING_READONLY";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface SetWorkspacePreferenceRequestHeaders$1 {
}
interface SetWorkspacePreferenceRequestQuery$1 {
}
interface SetWorkspacePreferenceRequestParams$1 {
    key: string;
}
interface SetWorkspacePreferenceRequestBody$1 {
    value?: any;
}
type SetWorkspacePreferenceInput$1 = SetWorkspacePreferenceRequestBody$1 & SetWorkspacePreferenceRequestHeaders$1 & SetWorkspacePreferenceRequestQuery$1 & SetWorkspacePreferenceRequestParams$1;
interface SetWorkspacePreferenceResponse$1 {
}

interface GetWorkspacePreferenceRequestHeaders$1 {
}
interface GetWorkspacePreferenceRequestQuery$1 {
}
interface GetWorkspacePreferenceRequestParams$1 {
    key: string;
}
interface GetWorkspacePreferenceRequestBody$1 {
}
type GetWorkspacePreferenceInput$1 = GetWorkspacePreferenceRequestBody$1 & GetWorkspacePreferenceRequestHeaders$1 & GetWorkspacePreferenceRequestQuery$1 & GetWorkspacePreferenceRequestParams$1;
interface GetWorkspacePreferenceResponse$1 {
    value?: any;
}

interface ListWorkspaceMembersRequestHeaders$1 {
}
interface ListWorkspaceMembersRequestQuery$1 {
    nextToken?: string;
}
interface ListWorkspaceMembersRequestParams$1 {
}
interface ListWorkspaceMembersRequestBody$1 {
}
type ListWorkspaceMembersInput$1 = ListWorkspaceMembersRequestBody$1 & ListWorkspaceMembersRequestHeaders$1 & ListWorkspaceMembersRequestQuery$1 & ListWorkspaceMembersRequestParams$1;
interface ListWorkspaceMembersResponse$1 {
    members: {
        id: string;
        userId?: string;
        email: string;
        createdAt: string;
        role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
        profilePicture?: string;
        displayName?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetWorkspaceMemberRequestHeaders$1 {
}
interface GetWorkspaceMemberRequestQuery$1 {
}
interface GetWorkspaceMemberRequestParams$1 {
}
interface GetWorkspaceMemberRequestBody$1 {
}
type GetWorkspaceMemberInput$1 = GetWorkspaceMemberRequestBody$1 & GetWorkspaceMemberRequestHeaders$1 & GetWorkspaceMemberRequestQuery$1 & GetWorkspaceMemberRequestParams$1;
interface GetWorkspaceMemberResponse$1 {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface DeleteWorkspaceMemberRequestHeaders$1 {
}
interface DeleteWorkspaceMemberRequestQuery$1 {
}
interface DeleteWorkspaceMemberRequestParams$1 {
    id: string;
}
interface DeleteWorkspaceMemberRequestBody$1 {
}
type DeleteWorkspaceMemberInput$1 = DeleteWorkspaceMemberRequestBody$1 & DeleteWorkspaceMemberRequestHeaders$1 & DeleteWorkspaceMemberRequestQuery$1 & DeleteWorkspaceMemberRequestParams$1;
interface DeleteWorkspaceMemberResponse$1 {
}

interface CreateWorkspaceMemberRequestHeaders$1 {
}
interface CreateWorkspaceMemberRequestQuery$1 {
}
interface CreateWorkspaceMemberRequestParams$1 {
}
interface CreateWorkspaceMemberRequestBody$1 {
    email: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
}
type CreateWorkspaceMemberInput$1 = CreateWorkspaceMemberRequestBody$1 & CreateWorkspaceMemberRequestHeaders$1 & CreateWorkspaceMemberRequestQuery$1 & CreateWorkspaceMemberRequestParams$1;
interface CreateWorkspaceMemberResponse$1 {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface UpdateWorkspaceMemberRequestHeaders$1 {
}
interface UpdateWorkspaceMemberRequestQuery$1 {
}
interface UpdateWorkspaceMemberRequestParams$1 {
    id: string;
}
interface UpdateWorkspaceMemberRequestBody$1 {
    role?: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
}
type UpdateWorkspaceMemberInput$1 = UpdateWorkspaceMemberRequestBody$1 & UpdateWorkspaceMemberRequestHeaders$1 & UpdateWorkspaceMemberRequestQuery$1 & UpdateWorkspaceMemberRequestParams$1;
interface UpdateWorkspaceMemberResponse$2 {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface ListIntegrationApiKeysRequestHeaders$1 {
}
interface ListIntegrationApiKeysRequestQuery$1 {
    integrationId: string;
}
interface ListIntegrationApiKeysRequestParams$1 {
}
interface ListIntegrationApiKeysRequestBody$1 {
}
type ListIntegrationApiKeysInput$1 = ListIntegrationApiKeysRequestBody$1 & ListIntegrationApiKeysRequestHeaders$1 & ListIntegrationApiKeysRequestQuery$1 & ListIntegrationApiKeysRequestParams$1;
interface ListIntegrationApiKeysResponse$1 {
    iaks: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreateIntegrationApiKeyRequestHeaders$1 {
}
interface CreateIntegrationApiKeyRequestQuery$1 {
}
interface CreateIntegrationApiKeyRequestParams$1 {
}
interface CreateIntegrationApiKeyRequestBody$1 {
    integrationId: string;
    note?: string;
}
type CreateIntegrationApiKeyInput$1 = CreateIntegrationApiKeyRequestBody$1 & CreateIntegrationApiKeyRequestHeaders$1 & CreateIntegrationApiKeyRequestQuery$1 & CreateIntegrationApiKeyRequestParams$1;
interface CreateIntegrationApiKeyResponse$1 {
    id: string;
    createdAt: string;
    note: string;
    /**
     * The IAK value. This will only be returned here when created and cannot be retrieved later.
     */
    value: string;
}

interface DeleteIntegrationApiKeyRequestHeaders$1 {
}
interface DeleteIntegrationApiKeyRequestQuery$1 {
}
interface DeleteIntegrationApiKeyRequestParams$1 {
    id: string;
}
interface DeleteIntegrationApiKeyRequestBody$1 {
}
type DeleteIntegrationApiKeyInput$1 = DeleteIntegrationApiKeyRequestBody$1 & DeleteIntegrationApiKeyRequestHeaders$1 & DeleteIntegrationApiKeyRequestQuery$1 & DeleteIntegrationApiKeyRequestParams$1;
interface DeleteIntegrationApiKeyResponse$1 {
}

interface CreateIntegrationRequestHeaders$1 {
}
interface CreateIntegrationRequestQuery$1 {
}
interface CreateIntegrationRequestParams$1 {
}
interface CreateIntegrationRequestBody$1 {
    /**
     * Name of the [Integration](#schema_integration)
     */
    name: string;
    /**
     * Version of the [Integration](#schema_integration)
     */
    version: string;
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            required?: boolean;
            linkTemplateScript?: string;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                required?: boolean;
                linkTemplateScript?: string;
            };
        };
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    identifier?: {
        fallbackHandlerScript?: string;
        extractScript?: string;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
        };
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        };
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * URL of the integration
     */
    url?: string;
    /**
     * Indicates if the integration is a development integration; Dev integrations run locally
     */
    dev?: boolean;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type CreateIntegrationInput$1 = CreateIntegrationRequestBody$1 & CreateIntegrationRequestHeaders$1 & CreateIntegrationRequestQuery$1 & CreateIntegrationRequestParams$1;
interface CreateIntegrationResponse$1 {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface ValidateIntegrationCreationRequestHeaders$1 {
}
interface ValidateIntegrationCreationRequestQuery$1 {
}
interface ValidateIntegrationCreationRequestParams$1 {
}
interface ValidateIntegrationCreationRequestBody$1 {
    /**
     * Name of the [Integration](#schema_integration)
     */
    name: string;
    /**
     * Version of the [Integration](#schema_integration)
     */
    version: string;
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            required?: boolean;
            linkTemplateScript?: string;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                required?: boolean;
                linkTemplateScript?: string;
            };
        };
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    identifier?: {
        fallbackHandlerScript?: string;
        extractScript?: string;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
        };
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        };
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * URL of the integration
     */
    url?: string;
    /**
     * Indicates if the integration is a development integration; Dev integrations run locally
     */
    dev?: boolean;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type ValidateIntegrationCreationInput$1 = ValidateIntegrationCreationRequestBody$1 & ValidateIntegrationCreationRequestHeaders$1 & ValidateIntegrationCreationRequestQuery$1 & ValidateIntegrationCreationRequestParams$1;
interface ValidateIntegrationCreationResponse$1 {
}

interface UpdateIntegrationRequestHeaders$1 {
}
interface UpdateIntegrationRequestQuery$1 {
}
interface UpdateIntegrationRequestParams$1 {
    id: string;
}
interface UpdateIntegrationRequestBody$1 {
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            linkTemplateScript?: string | null;
            required?: boolean;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                linkTemplateScript?: string | null;
                required?: boolean;
            };
        } | null;
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages?: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                } | null;
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
        } | null;
    };
    /**
     * Maximum execution time of the integration (in seconds).
     */
    maxExecutionTime?: number;
    identifier?: {
        extractScript?: string | null;
        fallbackHandlerScript?: string | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        } | null;
    };
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * URL of the integration
     */
    url?: string | null;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type UpdateIntegrationInput$1 = UpdateIntegrationRequestBody$1 & UpdateIntegrationRequestHeaders$1 & UpdateIntegrationRequestQuery$1 & UpdateIntegrationRequestParams$1;
interface UpdateIntegrationResponse$1 {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface ValidateIntegrationUpdateRequestHeaders$1 {
}
interface ValidateIntegrationUpdateRequestQuery$1 {
}
interface ValidateIntegrationUpdateRequestParams$1 {
    id: string;
}
interface ValidateIntegrationUpdateRequestBody$1 {
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            linkTemplateScript?: string | null;
            required?: boolean;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                linkTemplateScript?: string | null;
                required?: boolean;
            };
        } | null;
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages?: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                } | null;
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
        } | null;
    };
    /**
     * Maximum execution time of the integration (in seconds).
     */
    maxExecutionTime?: number;
    identifier?: {
        extractScript?: string | null;
        fallbackHandlerScript?: string | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        } | null;
    };
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * URL of the integration
     */
    url?: string | null;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type ValidateIntegrationUpdateInput$1 = ValidateIntegrationUpdateRequestBody$1 & ValidateIntegrationUpdateRequestHeaders$1 & ValidateIntegrationUpdateRequestQuery$1 & ValidateIntegrationUpdateRequestParams$1;
interface ValidateIntegrationUpdateResponse$1 {
}

interface ListIntegrationsRequestHeaders$1 {
}
interface ListIntegrationsRequestQuery$1 {
    nextToken?: string;
    limit?: number;
    name?: string;
    version?: string;
    interfaceId?: string;
    interfaceName?: string;
    installedByBotId?: string;
    verificationStatus?: "unapproved" | "pending" | "approved" | "rejected";
    search?: string;
    sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount";
    direction?: "asc" | "desc";
    visibility?: "public" | "private";
    dev?: boolean;
}
interface ListIntegrationsRequestParams$1 {
}
interface ListIntegrationsRequestBody$1 {
}
type ListIntegrationsInput$1 = ListIntegrationsRequestBody$1 & ListIntegrationsRequestHeaders$1 & ListIntegrationsRequestQuery$1 & ListIntegrationsRequestParams$1;
interface ListIntegrationsResponse$1 {
    integrations: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Metadata about which fields matched the search criteria
         */
        matchedOn?: {
            /**
             * Whether the integration name matched the search term
             */
            name?: boolean;
            /**
             * Whether the integration title matched the search term
             */
            title?: boolean;
            /**
             * Whether the integration description matched the search term
             */
            description?: boolean;
            /**
             * Action names that matched the search term
             */
            actions?: string[];
            /**
             * Interface names that matched the search term
             */
            interfaces?: string[];
        };
        ownerWorkspace?: {
            id: string;
            handle: string | null;
            name: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetIntegrationRequestHeaders$1 {
}
interface GetIntegrationRequestQuery$1 {
}
interface GetIntegrationRequestParams$1 {
    id: string;
}
interface GetIntegrationRequestBody$1 {
}
type GetIntegrationInput$1 = GetIntegrationRequestBody$1 & GetIntegrationRequestHeaders$1 & GetIntegrationRequestQuery$1 & GetIntegrationRequestParams$1;
interface GetIntegrationResponse$1 {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface GetIntegrationLogsRequestHeaders$1 {
}
interface GetIntegrationLogsRequestQuery$1 {
    timeStart: string;
    timeEnd?: string;
    level?: string;
    userId?: string;
    conversationId?: string;
    messageContains?: string;
    nextToken?: string;
}
interface GetIntegrationLogsRequestParams$1 {
    id: string;
}
interface GetIntegrationLogsRequestBody$1 {
}
type GetIntegrationLogsInput$1 = GetIntegrationLogsRequestBody$1 & GetIntegrationLogsRequestHeaders$1 & GetIntegrationLogsRequestQuery$1 & GetIntegrationLogsRequestParams$1;
interface GetIntegrationLogsResponse$1 {
    logs: {
        timestamp: string;
        level: string;
        message: string;
        workflowId?: string;
        userId?: string;
        conversationId?: string;
    }[];
    nextToken?: string;
}

interface GetIntegrationByNameRequestHeaders$1 {
}
interface GetIntegrationByNameRequestQuery$1 {
}
interface GetIntegrationByNameRequestParams$1 {
    name: string;
    version: string;
}
interface GetIntegrationByNameRequestBody$1 {
}
type GetIntegrationByNameInput$1 = GetIntegrationByNameRequestBody$1 & GetIntegrationByNameRequestHeaders$1 & GetIntegrationByNameRequestQuery$1 & GetIntegrationByNameRequestParams$1;
interface GetIntegrationByNameResponse$1 {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface DeleteIntegrationRequestHeaders$1 {
}
interface DeleteIntegrationRequestQuery$1 {
}
interface DeleteIntegrationRequestParams$1 {
    id: string;
}
interface DeleteIntegrationRequestBody$1 {
}
type DeleteIntegrationInput$1 = DeleteIntegrationRequestBody$1 & DeleteIntegrationRequestHeaders$1 & DeleteIntegrationRequestQuery$1 & DeleteIntegrationRequestParams$1;
interface DeleteIntegrationResponse$1 {
}

interface RequestIntegrationVerificationRequestHeaders$1 {
}
interface RequestIntegrationVerificationRequestQuery$1 {
}
interface RequestIntegrationVerificationRequestParams$1 {
}
interface RequestIntegrationVerificationRequestBody$1 {
    integrationId: string;
}
type RequestIntegrationVerificationInput$1 = RequestIntegrationVerificationRequestBody$1 & RequestIntegrationVerificationRequestHeaders$1 & RequestIntegrationVerificationRequestQuery$1 & RequestIntegrationVerificationRequestParams$1;
interface RequestIntegrationVerificationResponse$1 {
}

interface CreateInterfaceRequestHeaders$1 {
}
interface CreateInterfaceRequestQuery$1 {
}
interface CreateInterfaceRequestParams$1 {
}
interface CreateInterfaceRequestBody$1 {
    /**
     * Name of the [Interface](#schema_interface)
     */
    name: string;
    /**
     * Version of the [Interface](#schema_interface)
     */
    version: string;
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    /**
     * Base64 encoded svg of the interface icon. This icon is global to the interface each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the interface readme. The readme is specific to each interface versions.
     */
    readme?: string;
    /**
     * Title of the interface. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the interface. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
}
type CreateInterfaceInput$1 = CreateInterfaceRequestBody$1 & CreateInterfaceRequestHeaders$1 & CreateInterfaceRequestQuery$1 & CreateInterfaceRequestParams$1;
interface CreateInterfaceResponse$1 {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetInterfaceRequestHeaders$1 {
}
interface GetInterfaceRequestQuery$1 {
}
interface GetInterfaceRequestParams$1 {
    id: string;
}
interface GetInterfaceRequestBody$1 {
}
type GetInterfaceInput$1 = GetInterfaceRequestBody$1 & GetInterfaceRequestHeaders$1 & GetInterfaceRequestQuery$1 & GetInterfaceRequestParams$1;
interface GetInterfaceResponse$1 {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetInterfaceByNameRequestHeaders$1 {
}
interface GetInterfaceByNameRequestQuery$1 {
}
interface GetInterfaceByNameRequestParams$1 {
    name: string;
    version: string;
}
interface GetInterfaceByNameRequestBody$1 {
}
type GetInterfaceByNameInput$1 = GetInterfaceByNameRequestBody$1 & GetInterfaceByNameRequestHeaders$1 & GetInterfaceByNameRequestQuery$1 & GetInterfaceByNameRequestParams$1;
interface GetInterfaceByNameResponse$1 {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface UpdateInterfaceRequestHeaders$1 {
}
interface UpdateInterfaceRequestQuery$1 {
}
interface UpdateInterfaceRequestParams$1 {
    id: string;
}
interface UpdateInterfaceRequestBody$1 {
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages?: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                } | null;
            };
        } | null;
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    } | null;
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    /**
     * Base64 encoded svg of the interface icon. This icon is global to the interface each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the interface readme. The readme is specific to each interface versions.
     */
    readme?: string;
    /**
     * Title of the interface. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the interface. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
}
type UpdateInterfaceInput$1 = UpdateInterfaceRequestBody$1 & UpdateInterfaceRequestHeaders$1 & UpdateInterfaceRequestQuery$1 & UpdateInterfaceRequestParams$1;
interface UpdateInterfaceResponse$1 {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface DeleteInterfaceRequestHeaders$1 {
}
interface DeleteInterfaceRequestQuery$1 {
}
interface DeleteInterfaceRequestParams$1 {
    id: string;
}
interface DeleteInterfaceRequestBody$1 {
}
type DeleteInterfaceInput$1 = DeleteInterfaceRequestBody$1 & DeleteInterfaceRequestHeaders$1 & DeleteInterfaceRequestQuery$1 & DeleteInterfaceRequestParams$1;
interface DeleteInterfaceResponse$1 {
}

interface ListInterfacesRequestHeaders$1 {
}
interface ListInterfacesRequestQuery$1 {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListInterfacesRequestParams$1 {
}
interface ListInterfacesRequestBody$1 {
}
type ListInterfacesInput$1 = ListInterfacesRequestBody$1 & ListInterfacesRequestHeaders$1 & ListInterfacesRequestQuery$1 & ListInterfacesRequestParams$1;
interface ListInterfacesResponse$1 {
    interfaces: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreatePluginRequestHeaders$1 {
}
interface CreatePluginRequestQuery$1 {
}
interface CreatePluginRequestParams$1 {
}
interface CreatePluginRequestBody$1 {
    /**
     * Name of the [Plugin](#schema_plugin)
     */
    name: string;
    /**
     * Version of the [Plugin](#schema_plugin)
     */
    version: string;
    /**
     * Configuration definition
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    };
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    /**
     * User object configuration
     */
    user?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Conversation object configuration
     */
    conversation?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    code: {
        /**
         * Code of plugin bundled for Node.JS
         */
        node: string;
        /**
         * Code of plugin bundled for the browser
         */
        browser: string;
    };
    /**
     * Base64 encoded svg of the plugin icon. This icon is global to the plugin each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the plugin readme. The readme is specific to each plugin versions.
     */
    readme?: string;
    /**
     * Title of the plugin. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the plugin. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
    dependencies?: {
        /**
         * Mapping of interface aliases to interface references
         */
        interfaces?: {
            [k: string]: {
                /**
                 * Id of the interface. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the interface
                 */
                name?: string;
                /**
                 * Version of the interface. Accepts semver versions and version ranges
                 */
                version?: string;
            };
        };
        /**
         * Mapping of integration aliases to integration references
         */
        integrations?: {
            [k: string]: {
                /**
                 * Id of the integration. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the integration
                 */
                name?: string;
                /**
                 * Version of the integration. Accepts semver versions and version ranges
                 */
                version?: string;
            };
        };
    };
}
type CreatePluginInput$1 = CreatePluginRequestBody$1 & CreatePluginRequestHeaders$1 & CreatePluginRequestQuery$1 & CreatePluginRequestParams$1;
interface CreatePluginResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPluginRequestHeaders$1 {
}
interface GetPluginRequestQuery$1 {
}
interface GetPluginRequestParams$1 {
    id: string;
}
interface GetPluginRequestBody$1 {
}
type GetPluginInput$1 = GetPluginRequestBody$1 & GetPluginRequestHeaders$1 & GetPluginRequestQuery$1 & GetPluginRequestParams$1;
interface GetPluginResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetDereferencedPluginRequestHeaders$1 {
}
interface GetDereferencedPluginRequestQuery$1 {
    /**
     * Mapping of interface aliases to integration IDs
     */
    interfaces: {
        /**
         * integration id
         */
        [k: string]: string;
    };
}
interface GetDereferencedPluginRequestParams$1 {
    id: string;
}
interface GetDereferencedPluginRequestBody$1 {
}
type GetDereferencedPluginInput$1 = GetDereferencedPluginRequestBody$1 & GetDereferencedPluginRequestHeaders$1 & GetDereferencedPluginRequestQuery$1 & GetDereferencedPluginRequestParams$1;
interface GetDereferencedPluginResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPluginByNameRequestHeaders$1 {
}
interface GetPluginByNameRequestQuery$1 {
}
interface GetPluginByNameRequestParams$1 {
    name: string;
    version: string;
}
interface GetPluginByNameRequestBody$1 {
}
type GetPluginByNameInput$1 = GetPluginByNameRequestBody$1 & GetPluginByNameRequestHeaders$1 & GetPluginByNameRequestQuery$1 & GetPluginByNameRequestParams$1;
interface GetPluginByNameResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface UpdatePluginRequestHeaders$1 {
}
interface UpdatePluginRequestQuery$1 {
}
interface UpdatePluginRequestParams$1 {
    id: string;
}
interface UpdatePluginRequestBody$1 {
    /**
     * Configuration definition
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    } | null;
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    user?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    conversation?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    code?: {
        /**
         * Code of plugin bundled for Node.JS
         */
        node?: string;
        /**
         * Code of plugin bundled for the browser
         */
        browser?: string;
    };
    /**
     * Base64 encoded svg of the plugin icon. This icon is global to the plugin each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the plugin readme. The readme is specific to each plugin versions.
     */
    readme?: string;
    /**
     * Title of the plugin. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the plugin. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
    dependencies?: {
        /**
         * Mapping of interface aliases to interface references
         */
        interfaces?: {
            [k: string]: {
                /**
                 * Id of the interface. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the interface
                 */
                name?: string;
                /**
                 * Version of the interface. Accepts semver versions and version ranges
                 */
                version?: string;
            } | null;
        };
        /**
         * Mapping of integration aliases to integration references
         */
        integrations?: {
            [k: string]: {
                /**
                 * Id of the integration. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the integration
                 */
                name?: string;
                /**
                 * Version of the integration. Accepts semver versions and version ranges
                 */
                version?: string;
            } | null;
        };
    };
}
type UpdatePluginInput$1 = UpdatePluginRequestBody$1 & UpdatePluginRequestHeaders$1 & UpdatePluginRequestQuery$1 & UpdatePluginRequestParams$1;
interface UpdatePluginResponse$1 {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface DeletePluginRequestHeaders$1 {
}
interface DeletePluginRequestQuery$1 {
}
interface DeletePluginRequestParams$1 {
    id: string;
}
interface DeletePluginRequestBody$1 {
}
type DeletePluginInput$1 = DeletePluginRequestBody$1 & DeletePluginRequestHeaders$1 & DeletePluginRequestQuery$1 & DeletePluginRequestParams$1;
interface DeletePluginResponse$1 {
}

interface ListPluginsRequestHeaders$1 {
}
interface ListPluginsRequestQuery$1 {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListPluginsRequestParams$1 {
}
interface ListPluginsRequestBody$1 {
}
type ListPluginsInput$1 = ListPluginsRequestBody$1 & ListPluginsRequestHeaders$1 & ListPluginsRequestQuery$1 & ListPluginsRequestParams$1;
interface ListPluginsResponse$1 {
    plugins: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPluginCodeRequestHeaders$1 {
}
interface GetPluginCodeRequestQuery$1 {
}
interface GetPluginCodeRequestParams$1 {
    id: string;
    platform: "node" | "browser";
}
interface GetPluginCodeRequestBody$1 {
}
type GetPluginCodeInput$1 = GetPluginCodeRequestBody$1 & GetPluginCodeRequestHeaders$1 & GetPluginCodeRequestQuery$1 & GetPluginCodeRequestParams$1;
interface GetPluginCodeResponse$1 {
    code: string;
}

interface GetUsageRequestHeaders$1 {
}
interface GetUsageRequestQuery$1 {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface GetUsageRequestParams$1 {
    id: string;
}
interface GetUsageRequestBody$1 {
}
type GetUsageInput$1 = GetUsageRequestBody$1 & GetUsageRequestHeaders$1 & GetUsageRequestQuery$1 & GetUsageRequestParams$1;
interface GetUsageResponse$1 {
    usage: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    };
}

interface GetMultipleUsagesRequestHeaders$1 {
}
interface GetMultipleUsagesRequestQuery$1 {
    types: string[];
    ids: string[];
    period?: string;
}
interface GetMultipleUsagesRequestParams$1 {
}
interface GetMultipleUsagesRequestBody$1 {
}
type GetMultipleUsagesInput$1 = GetMultipleUsagesRequestBody$1 & GetMultipleUsagesRequestHeaders$1 & GetMultipleUsagesRequestQuery$1 & GetMultipleUsagesRequestParams$1;
interface GetMultipleUsagesResponse$1 {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface ListUsageHistoryRequestHeaders$1 {
}
interface ListUsageHistoryRequestQuery$1 {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
}
interface ListUsageHistoryRequestParams$1 {
    id: string;
}
interface ListUsageHistoryRequestBody$1 {
}
type ListUsageHistoryInput$1 = ListUsageHistoryRequestBody$1 & ListUsageHistoryRequestHeaders$1 & ListUsageHistoryRequestQuery$1 & ListUsageHistoryRequestParams$1;
interface ListUsageHistoryResponse$1 {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface ListUsageActivityRequestHeaders$1 {
}
interface ListUsageActivityRequestQuery$1 {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    timestampFrom?: string;
    timestampUntil?: string;
    nextToken?: string;
}
interface ListUsageActivityRequestParams$1 {
    id: string;
}
interface ListUsageActivityRequestBody$1 {
}
type ListUsageActivityInput$1 = ListUsageActivityRequestBody$1 & ListUsageActivityRequestHeaders$1 & ListUsageActivityRequestQuery$1 & ListUsageActivityRequestParams$1;
interface ListUsageActivityResponse$1 {
    data: {
        timestamp: string;
        value: number;
        period: string;
        metadata: {
            [k: string]: any | null;
        };
    }[];
    meta: {
        nextToken?: string;
    };
}

interface ListUsageActivityDailyRequestHeaders$1 {
}
interface ListUsageActivityDailyRequestQuery$1 {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    dateFrom?: string;
    dateUntil?: string;
    nextToken?: string;
}
interface ListUsageActivityDailyRequestParams$1 {
    id: string;
}
interface ListUsageActivityDailyRequestBody$1 {
}
type ListUsageActivityDailyInput$1 = ListUsageActivityDailyRequestBody$1 & ListUsageActivityDailyRequestHeaders$1 & ListUsageActivityDailyRequestQuery$1 & ListUsageActivityDailyRequestParams$1;
interface ListUsageActivityDailyResponse$1 {
    data: {
        key: string;
        date: string;
        value: number;
        metadata?: {
            botId: string;
            type: "IntegrationAction" | "FileIndexing" | "BingSearch" | "WebSearch";
            subtype?: string;
            source?: string;
        };
    }[];
    meta: {
        nextToken?: string;
    };
}

interface ChangeAispendQuotaRequestHeaders$1 {
}
interface ChangeAispendQuotaRequestQuery$1 {
}
interface ChangeAispendQuotaRequestParams$1 {
}
interface ChangeAispendQuotaRequestBody$1 {
    monthlySpendingLimit: number;
}
type ChangeAispendQuotaInput$1 = ChangeAispendQuotaRequestBody$1 & ChangeAispendQuotaRequestHeaders$1 & ChangeAispendQuotaRequestQuery$1 & ChangeAispendQuotaRequestParams$1;
interface ChangeAispendQuotaResponse$1 {
}

interface ListActivitiesRequestHeaders$1 {
}
interface ListActivitiesRequestQuery$1 {
    nextToken?: string;
    taskId: string;
    botId: string;
}
interface ListActivitiesRequestParams$1 {
}
interface ListActivitiesRequestBody$1 {
}
type ListActivitiesInput$1 = ListActivitiesRequestBody$1 & ListActivitiesRequestHeaders$1 & ListActivitiesRequestQuery$1 & ListActivitiesRequestParams$1;
interface ListActivitiesResponse$1 {
    activities: {
        id: string;
        description: string;
        taskId: string;
        category: "unknown" | "capture" | "bot_message" | "user_message" | "agent_message" | "event" | "action" | "task_status" | "subtask_status" | "exception";
        data: {
            [k: string]: any;
        };
        /**
         * Creation date of the activity in ISO 8601 format
         */
        createdAt: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface IntrospectRequestHeaders$1 {
}
interface IntrospectRequestQuery$1 {
}
interface IntrospectRequestParams$1 {
}
interface IntrospectRequestBody$1 {
    botId: string;
}
type IntrospectInput$1 = IntrospectRequestBody$1 & IntrospectRequestHeaders$1 & IntrospectRequestQuery$1 & IntrospectRequestParams$1;
interface IntrospectResponse$1 {
    workspaceId: string;
    botId: string;
    userId: string;
}

type ClientProps$7 = {
    toAxiosRequest: typeof toAxiosRequest$3;
    toApiError: typeof toApiError$3;
};
declare class Client$7 {
    private axiosInstance;
    private props;
    constructor(axiosInstance: AxiosInstance, props?: Partial<ClientProps$7>);
    readonly runVrl: (input: RunVrlInput$1) => Promise<RunVrlResponse$1>;
    readonly getAccount: (input: GetAccountInput$1) => Promise<GetAccountResponse$1>;
    readonly updateAccount: (input: UpdateAccountInput$1) => Promise<UpdateAccountResponse$1>;
    readonly deleteAccount: (input: DeleteAccountInput$1) => Promise<DeleteAccountResponse$1>;
    readonly listPersonalAccessTokens: (input: ListPersonalAccessTokensInput$1) => Promise<ListPersonalAccessTokensResponse$1>;
    readonly createPersonalAccessToken: (input: CreatePersonalAccessTokenInput$1) => Promise<CreatePersonalAccessTokenResponse$1>;
    readonly deletePersonalAccessToken: (input: DeletePersonalAccessTokenInput$1) => Promise<DeletePersonalAccessTokenResponse$1>;
    readonly setAccountPreference: (input: SetAccountPreferenceInput$1) => Promise<SetAccountPreferenceResponse$1>;
    readonly getAccountPreference: (input: GetAccountPreferenceInput$1) => Promise<GetAccountPreferenceResponse$1>;
    readonly listPublicIntegrations: (input: ListPublicIntegrationsInput$1) => Promise<ListPublicIntegrationsResponse$1>;
    readonly getPublicIntegrationById: (input: GetPublicIntegrationByIdInput$1) => Promise<GetPublicIntegrationByIdResponse$1>;
    readonly getPublicIntegration: (input: GetPublicIntegrationInput$1) => Promise<GetPublicIntegrationResponse$1>;
    readonly listPublicPlugins: (input: ListPublicPluginsInput$1) => Promise<ListPublicPluginsResponse$1>;
    readonly getPublicPluginById: (input: GetPublicPluginByIdInput$1) => Promise<GetPublicPluginByIdResponse$1>;
    readonly getDereferencedPublicPluginById: (input: GetDereferencedPublicPluginByIdInput$1) => Promise<GetDereferencedPublicPluginByIdResponse$1>;
    readonly getPublicPlugin: (input: GetPublicPluginInput$1) => Promise<GetPublicPluginResponse$1>;
    readonly getPublicPluginCode: (input: GetPublicPluginCodeInput$1) => Promise<GetPublicPluginCodeResponse$1>;
    readonly listPublicInterfaces: (input: ListPublicInterfacesInput$1) => Promise<ListPublicInterfacesResponse$1>;
    readonly getPublicInterfaceById: (input: GetPublicInterfaceByIdInput$1) => Promise<GetPublicInterfaceByIdResponse$1>;
    readonly getPublicInterface: (input: GetPublicInterfaceInput$1) => Promise<GetPublicInterfaceResponse$1>;
    readonly createBot: (input: CreateBotInput$1) => Promise<CreateBotResponse$1>;
    readonly updateBot: (input: UpdateBotInput$1) => Promise<UpdateBotResponse$1>;
    readonly transferBot: (input: TransferBotInput$1) => Promise<TransferBotResponse$1>;
    readonly listBots: (input: ListBotsInput$1) => Promise<ListBotsResponse$1>;
    readonly getBot: (input: GetBotInput$1) => Promise<GetBotResponse$1>;
    readonly deleteBot: (input: DeleteBotInput$1) => Promise<DeleteBotResponse$1>;
    readonly getBotLogs: (input: GetBotLogsInput$1) => Promise<GetBotLogsResponse$1>;
    readonly getBotWebchat: (input: GetBotWebchatInput$1) => Promise<GetBotWebchatResponse$1>;
    readonly getBotAnalytics: (input: GetBotAnalyticsInput$1) => Promise<GetBotAnalyticsResponse$1>;
    readonly listActionRuns: (input: ListActionRunsInput$1) => Promise<ListActionRunsResponse$1>;
    readonly getBotIssue: (input: GetBotIssueInput$1) => Promise<GetBotIssueResponse$1>;
    readonly listBotIssues: (input: ListBotIssuesInput$1) => Promise<ListBotIssuesResponse$1>;
    readonly deleteBotIssue: (input: DeleteBotIssueInput$1) => Promise<DeleteBotIssueResponse$1>;
    readonly listBotIssueEvents: (input: ListBotIssueEventsInput$1) => Promise<ListBotIssueEventsResponse$1>;
    readonly listBotVersions: (input: ListBotVersionsInput$1) => Promise<ListBotVersionsResponse$1>;
    readonly getBotVersion: (input: GetBotVersionInput$1) => Promise<GetBotVersionResponse$1>;
    readonly getBotJson: (input: GetBotJsonInput$1) => Promise<GetBotJsonResponse$1>;
    readonly publishFromBotJson: (input: PublishFromBotJsonInput$1) => Promise<PublishFromBotJsonResponse$1>;
    readonly createBotVersion: (input: CreateBotVersionInput$1) => Promise<CreateBotVersionResponse$1>;
    readonly deployBotVersion: (input: DeployBotVersionInput$1) => Promise<DeployBotVersionResponse$1>;
    readonly createIntegrationShareableId: (input: CreateIntegrationShareableIdInput$1) => Promise<CreateIntegrationShareableIdResponse$1>;
    readonly deleteIntegrationShareableId: (input: DeleteIntegrationShareableIdInput$1) => Promise<DeleteIntegrationShareableIdResponse$1>;
    readonly getIntegrationShareableId: (input: GetIntegrationShareableIdInput$1) => Promise<GetIntegrationShareableIdResponse$1>;
    readonly unlinkSandboxedConversations: (input: UnlinkSandboxedConversationsInput$1) => Promise<UnlinkSandboxedConversationsResponse$1>;
    readonly listBotApiKeys: (input: ListBotApiKeysInput$1) => Promise<ListBotApiKeysResponse$1>;
    readonly createBotApiKey: (input: CreateBotApiKeyInput$1) => Promise<CreateBotApiKeyResponse$1>;
    readonly deleteBotApiKey: (input: DeleteBotApiKeyInput$1) => Promise<DeleteBotApiKeyResponse$1>;
    readonly getBotAllowlist: (input: GetBotAllowlistInput$1) => Promise<GetBotAllowlistResponse$1>;
    readonly updateBotAllowlist: (input: UpdateBotAllowlistInput$1) => Promise<UpdateBotAllowlistResponse$1>;
    readonly listWorkspaceInvoices: (input: ListWorkspaceInvoicesInput$1) => Promise<ListWorkspaceInvoicesResponse$1>;
    readonly getUpcomingInvoice: (input: GetUpcomingInvoiceInput$1) => Promise<GetUpcomingInvoiceResponse$1>;
    readonly chargeWorkspaceUnpaidInvoices: (input: ChargeWorkspaceUnpaidInvoicesInput$1) => Promise<ChargeWorkspaceUnpaidInvoicesResponse$1>;
    readonly createWorkspace: (input: CreateWorkspaceInput$1) => Promise<CreateWorkspaceResponse$1>;
    readonly getPublicWorkspace: (input: GetPublicWorkspaceInput$1) => Promise<GetPublicWorkspaceResponse$3>;
    readonly getWorkspace: (input: GetWorkspaceInput$1) => Promise<GetWorkspaceResponse$1>;
    readonly listWorkspaceUsages: (input: ListWorkspaceUsagesInput$1) => Promise<ListWorkspaceUsagesResponse$1>;
    readonly breakDownWorkspaceUsageByBot: (input: BreakDownWorkspaceUsageByBotInput$1) => Promise<BreakDownWorkspaceUsageByBotResponse$1>;
    readonly getAllWorkspaceQuotaCompletion: (input: GetAllWorkspaceQuotaCompletionInput$1) => Promise<GetAllWorkspaceQuotaCompletionResponse$1>;
    readonly getWorkspaceQuota: (input: GetWorkspaceQuotaInput$1) => Promise<GetWorkspaceQuotaResponse$1>;
    readonly listWorkspaceQuotas: (input: ListWorkspaceQuotasInput$1) => Promise<ListWorkspaceQuotasResponse$1>;
    readonly updateWorkspace: (input: UpdateWorkspaceInput$1) => Promise<UpdateWorkspaceResponse$3>;
    readonly checkHandleAvailability: (input: CheckHandleAvailabilityInput$1) => Promise<CheckHandleAvailabilityResponse$1>;
    readonly listWorkspaces: (input: ListWorkspacesInput$1) => Promise<ListWorkspacesResponse$1>;
    readonly listPublicWorkspaces: (input: ListPublicWorkspacesInput$1) => Promise<ListPublicWorkspacesResponse$1>;
    readonly deleteWorkspace: (input: DeleteWorkspaceInput$1) => Promise<DeleteWorkspaceResponse$1>;
    readonly getAuditRecords: (input: GetAuditRecordsInput$1) => Promise<GetAuditRecordsResponse$1>;
    readonly setWorkspacePreference: (input: SetWorkspacePreferenceInput$1) => Promise<SetWorkspacePreferenceResponse$1>;
    readonly getWorkspacePreference: (input: GetWorkspacePreferenceInput$1) => Promise<GetWorkspacePreferenceResponse$1>;
    readonly listWorkspaceMembers: (input: ListWorkspaceMembersInput$1) => Promise<ListWorkspaceMembersResponse$1>;
    readonly getWorkspaceMember: (input: GetWorkspaceMemberInput$1) => Promise<GetWorkspaceMemberResponse$1>;
    readonly deleteWorkspaceMember: (input: DeleteWorkspaceMemberInput$1) => Promise<DeleteWorkspaceMemberResponse$1>;
    readonly createWorkspaceMember: (input: CreateWorkspaceMemberInput$1) => Promise<CreateWorkspaceMemberResponse$1>;
    readonly updateWorkspaceMember: (input: UpdateWorkspaceMemberInput$1) => Promise<UpdateWorkspaceMemberResponse$2>;
    readonly listIntegrationApiKeys: (input: ListIntegrationApiKeysInput$1) => Promise<ListIntegrationApiKeysResponse$1>;
    readonly createIntegrationApiKey: (input: CreateIntegrationApiKeyInput$1) => Promise<CreateIntegrationApiKeyResponse$1>;
    readonly deleteIntegrationApiKey: (input: DeleteIntegrationApiKeyInput$1) => Promise<DeleteIntegrationApiKeyResponse$1>;
    readonly createIntegration: (input: CreateIntegrationInput$1) => Promise<CreateIntegrationResponse$1>;
    readonly validateIntegrationCreation: (input: ValidateIntegrationCreationInput$1) => Promise<ValidateIntegrationCreationResponse$1>;
    readonly updateIntegration: (input: UpdateIntegrationInput$1) => Promise<UpdateIntegrationResponse$1>;
    readonly validateIntegrationUpdate: (input: ValidateIntegrationUpdateInput$1) => Promise<ValidateIntegrationUpdateResponse$1>;
    readonly listIntegrations: (input: ListIntegrationsInput$1) => Promise<ListIntegrationsResponse$1>;
    readonly getIntegration: (input: GetIntegrationInput$1) => Promise<GetIntegrationResponse$1>;
    readonly getIntegrationLogs: (input: GetIntegrationLogsInput$1) => Promise<GetIntegrationLogsResponse$1>;
    readonly getIntegrationByName: (input: GetIntegrationByNameInput$1) => Promise<GetIntegrationByNameResponse$1>;
    readonly deleteIntegration: (input: DeleteIntegrationInput$1) => Promise<DeleteIntegrationResponse$1>;
    readonly requestIntegrationVerification: (input: RequestIntegrationVerificationInput$1) => Promise<RequestIntegrationVerificationResponse$1>;
    readonly createInterface: (input: CreateInterfaceInput$1) => Promise<CreateInterfaceResponse$1>;
    readonly getInterface: (input: GetInterfaceInput$1) => Promise<GetInterfaceResponse$1>;
    readonly getInterfaceByName: (input: GetInterfaceByNameInput$1) => Promise<GetInterfaceByNameResponse$1>;
    readonly updateInterface: (input: UpdateInterfaceInput$1) => Promise<UpdateInterfaceResponse$1>;
    readonly deleteInterface: (input: DeleteInterfaceInput$1) => Promise<DeleteInterfaceResponse$1>;
    readonly listInterfaces: (input: ListInterfacesInput$1) => Promise<ListInterfacesResponse$1>;
    readonly createPlugin: (input: CreatePluginInput$1) => Promise<CreatePluginResponse$1>;
    readonly getPlugin: (input: GetPluginInput$1) => Promise<GetPluginResponse$1>;
    readonly getDereferencedPlugin: (input: GetDereferencedPluginInput$1) => Promise<GetDereferencedPluginResponse$1>;
    readonly getPluginByName: (input: GetPluginByNameInput$1) => Promise<GetPluginByNameResponse$1>;
    readonly updatePlugin: (input: UpdatePluginInput$1) => Promise<UpdatePluginResponse$1>;
    readonly deletePlugin: (input: DeletePluginInput$1) => Promise<DeletePluginResponse$1>;
    readonly listPlugins: (input: ListPluginsInput$1) => Promise<ListPluginsResponse$1>;
    readonly getPluginCode: (input: GetPluginCodeInput$1) => Promise<GetPluginCodeResponse$1>;
    readonly getUsage: (input: GetUsageInput$1) => Promise<GetUsageResponse$1>;
    readonly getMultipleUsages: (input: GetMultipleUsagesInput$1) => Promise<GetMultipleUsagesResponse$1>;
    readonly listUsageHistory: (input: ListUsageHistoryInput$1) => Promise<ListUsageHistoryResponse$1>;
    readonly listUsageActivity: (input: ListUsageActivityInput$1) => Promise<ListUsageActivityResponse$1>;
    readonly listUsageActivityDaily: (input: ListUsageActivityDailyInput$1) => Promise<ListUsageActivityDailyResponse$1>;
    readonly changeAISpendQuota: (input: ChangeAispendQuotaInput$1) => Promise<ChangeAispendQuotaResponse$1>;
    readonly listActivities: (input: ListActivitiesInput$1) => Promise<ListActivitiesResponse$1>;
    readonly introspect: (input: IntrospectInput$1) => Promise<IntrospectResponse$1>;
}
declare function toApiError$3(err: unknown): Error;

type IClient$3 = Simplify<Client$7>;
type Operation$3 = Operation$5<IClient$3>;
type ClientInputs$3 = Inputs<IClient$3>;
type ClientOutputs$3 = Outputs<IClient$3>;
type ClientProps$6 = CommonClientProps & {
    workspaceId?: string;
    token: string;
};
declare class Client$6 extends Client$7 {
    readonly config: Readonly<ClientConfig>;
    constructor(clientProps: ClientProps$6);
    get list(): {
        publicIntegrations: (props: {
            search?: string | undefined;
            name?: string | undefined;
            limit?: number | undefined;
            version?: string | undefined;
            interfaceId?: string | undefined;
            interfaceName?: string | undefined;
            installedByBotId?: string | undefined;
            verificationStatus?: "unapproved" | "pending" | "approved" | "rejected" | undefined;
            sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount" | undefined;
            direction?: "asc" | "desc" | undefined;
        }) => AsyncCollection<{
            id: string;
            name: string;
            version: string;
            createdAt: string;
            updatedAt: string;
            title: string;
            description: string;
            iconUrl: string;
            public: boolean;
            visibility: "public" | "private" | "unlisted";
            verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            ownerWorkspace: {
                id: string;
                handle: string | null;
                name: string;
            };
            meta: {
                installs: number;
                views: number;
            };
            matchedOn?: {
                name?: boolean;
                title?: boolean;
                description?: boolean;
                actions?: string[];
                interfaces?: string[];
            };
        }>;
        bots: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            sortField?: "createdAt" | "updatedAt" | undefined;
            sortDirection?: "asc" | "desc" | undefined;
            dev?: boolean | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            name: string;
            deployedAt?: string;
            tags: {
                [k: string]: string;
            };
        }>;
        botIssues: (props: {
            id: string;
        }) => AsyncCollection<{
            id: string;
            code: string;
            createdAt: string;
            lastSeenAt: string;
            title: string;
            description: string;
            groupedData: {
                [k: string]: {
                    raw: string;
                    pretty?: string;
                };
            };
            eventsCount: number;
            category: "user_code" | "limits" | "configuration" | "other";
            resolutionLink: string | null;
        }>;
        workspaces: (props: {
            handle?: string | undefined;
        }) => AsyncCollection<UpdateWorkspaceResponse$2>;
        publicWorkspaces: (props: {
            search?: string | undefined;
            workspaceIds?: string[] | undefined;
        }) => AsyncCollection<GetPublicWorkspaceResponse$2>;
        workspaceMembers: (props: {}) => AsyncCollection<{
            id: string;
            userId?: string;
            email: string;
            createdAt: string;
            role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
            profilePicture?: string;
            displayName?: string;
        }>;
        integrations: (props: {
            search?: string | undefined;
            name?: string | undefined;
            limit?: number | undefined;
            version?: string | undefined;
            interfaceId?: string | undefined;
            interfaceName?: string | undefined;
            installedByBotId?: string | undefined;
            verificationStatus?: "unapproved" | "pending" | "approved" | "rejected" | undefined;
            sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount" | undefined;
            direction?: "asc" | "desc" | undefined;
            dev?: boolean | undefined;
            visibility?: "public" | "private" | undefined;
        }) => AsyncCollection<{
            id: string;
            name: string;
            version: string;
            createdAt: string;
            updatedAt: string;
            title: string;
            description: string;
            iconUrl: string;
            public: boolean;
            visibility: "public" | "private" | "unlisted";
            verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            matchedOn?: {
                name?: boolean;
                title?: boolean;
                description?: boolean;
                actions?: string[];
                interfaces?: string[];
            };
            ownerWorkspace?: {
                id: string;
                handle: string | null;
                name: string;
            };
        }>;
        interfaces: (props: {
            name?: string | undefined;
            version?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            name: string;
            version: string;
            title: string;
            description: string;
            iconUrl: string;
            readmeUrl: string;
            public: boolean;
        }>;
        activities: (props: {
            botId: string;
            taskId: string;
        }) => AsyncCollection<{
            id: string;
            description: string;
            taskId: string;
            category: "unknown" | "capture" | "bot_message" | "user_message" | "agent_message" | "event" | "action" | "task_status" | "subtask_status" | "exception";
            data: {
                [k: string]: any;
            };
            createdAt: string;
        }>;
        usageActivity: (props: {
            type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
            id: string;
            timestampFrom?: string | undefined;
            timestampUntil?: string | undefined;
        }) => AsyncCollection<{
            timestamp: string;
            value: number;
            period: string;
            metadata: {
                [k: string]: any | null;
            };
        }>;
        usageActivityDaily: (props: {
            type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
            id: string;
            dateFrom?: string | undefined;
            dateUntil?: string | undefined;
        }) => AsyncCollection<{
            key: string;
            date: string;
            value: number;
            metadata?: {
                botId: string;
                type: "IntegrationAction" | "FileIndexing" | "BingSearch" | "WebSearch";
                subtype?: string;
                source?: string;
            };
        }>;
    };
}

declare namespace index$2 {
  export { Client$6 as Client, type ClientInputs$3 as ClientInputs, type ClientOutputs$3 as ClientOutputs, type ClientProps$6 as ClientProps, type Operation$3 as Operation };
}

type Primitive$2 = string | number | boolean;
type Value$2<P extends Primitive$2> = P | P[] | Record<string, P>;
type QueryValue$2 = Value$2<string> | Value$2<boolean> | Value$2<number> | undefined;
type AnyQueryParams$2 = Record<string, QueryValue$2>;
type HeaderValue$2 = string | undefined;
type AnyHeaderParams$2 = Record<string, HeaderValue$2>;
type AnyBodyParams$2 = Record<string, any>;
type ParsedRequest$2 = {
    method: string;
    path: string;
    query: AnyQueryParams$2;
    headers: AnyHeaderParams$2;
    body: AnyBodyParams$2;
};
declare const toAxiosRequest$2: (req: ParsedRequest$2) => AxiosRequestConfig;

interface UpsertFileRequestHeaders$1 {
}
interface UpsertFileRequestQuery$1 {
}
interface UpsertFileRequestParams$1 {
}
interface UpsertFileRequestBody$1 {
    /**
     * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
     */
    key: string;
    /**
     * File tags as an object of key-value pairs. Tag values should be of `string` (text) type.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * File size in bytes. This will count against your File Storage quota. If the `index` parameter is set to `true`, this will also count against your Vector DB Storage quota.
     */
    size: number;
    /**
     * Set to a value of 'true' to index the file in vector storage. Only certain file formats are currently supported for indexing. Files larger than 95 MB cannot be indexed. Note that if a file is indexed, it will count towards both the Vector DB Storage quota and the File Storage quota of the workspace.
     */
    index?: boolean;
    indexing?: {
        /**
         * Configuration to use for indexing the file, will be stored in the file's metadata for reference.
         */
        configuration: {
            parsing?: {
                /**
                 * The minimum length a standalone paragraph should have. If a paragraph is shorter than this, it will be merged with the next immediate paragraph.
                 */
                minimumParagraphLength?: number;
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) Enabling this will use a lightweight/inexpensive LLM to clean up the extracted content of PDF files before indexing them to increase the quality of the stored vectors, as PDFs often store raw text in unusual ways which when extracted may result in formatting issues (e.g. broken sentences/paragraphs, unexpected headings, garbled characters, etc.) that can affect retrieval performance for certain user queries if left untouched.
                 *
                 * Notes:
                 * - This feature is only available in Team and Enterprise plans.
                 * - This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred.
                 * - We recommend using this feature for PDFs that have custom layouts or design. For simple text-based PDFs like documents and books, this feature is usually not necessary.
                 * - The smart cleanup takes some time to perform due to the LLM calls involved, so enabling it will increase the total time it takes to index the file.
                 * - We take steps to prevent the original text from being fundamentally changed but due to the nature of LLMs this could theoretically still happen so it's recommended to review the passages generated for the file after indexing to ensure the content is still accurate.
                 * - This feature is limited to the first 30 pages or 20 KB of text in the PDF file (whichever comes first). If the file has more content than these limits then the rest of the file will be indexed as-is without any cleanup. If you need to clean up the content of the entire file, consider splitting it into smaller files.
                 */
                smartCleanup?: boolean;
            };
            chunking?: {
                /**
                 * The maximum length of a chunk in characters.
                 */
                maximumChunkLength?: number;
                /**
                 * The number of surrounding context levels to include in the vector embedding of the chunk.
                 */
                embeddedContextLevels?: number;
                /**
                 * Include the breadcrumb of the chunk in the vector embedding.
                 */
                embedBreadcrumb?: boolean;
            };
            summarization?: {
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) Create summaries for this file and index them as standalone vectors. Enabling this option will incur in AI Spend cost (charged to the workspace of the bot) to generate the summaries based on the amount of content in the file and the summarization model used.
                 *
                 * Please note that this feature is only available in Team and Enterprise plans.
                 */
                enable?: boolean;
                /**
                 * The model type to use for summarization.
                 */
                modelType?: "inexpensive" | "balanced" | "accurate";
                /**
                 * The minimum length a section of the file should have to create a summary of it.
                 */
                minimumInputLength?: number;
                /**
                 * The maximum length of a summary (in tokens).
                 */
                outputTokenLimit?: number;
                /**
                 * Generate a summary of the entire file and index it as a standalone vector.
                 */
                generateMasterSummary?: boolean;
            };
            /**
             * If not set, the default indexing stack will be used.
             */
            stack?: "legacy" | "realtime-v1";
            vision?: {
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) For PDF files, set this option to `true` or pass an array with specific page numbers to use a vision-enabled LLM to transcribe each page of the PDF as standalone vectors and index them.
                 *
                 * This feature is useful when a PDF file contains custom designs or layouts, or when your document has many infographics, which require visual processing in order to index the file effectively, as the default text-based indexing may not be enough to allow your bot to correctly understand the content in your PDFs.
                 *
                 * Notes:
                 * - This feature is only available in Team and Enterprise plans.
                 * - Enabling this feature will incur in AI Spend cost to use a vision-enabled LLM to index the PDF pages.
                 * - This is limited to a maximum of 100 pages of the PDF. If the file has more pages then the rest of the pages will NOT be transcribed using this vision feature, and will be processed using the default text-based indexing instead. If you need to transcribe the entire file using vision, please split it into smaller files.
                 * - Pages that are vision-transcribed will not be processed by the default text-based indexing to avoid duplicate content in the index.
                 * - This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred.
                 */
                transcribePages?: {
                    [k: string]: any;
                };
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) For PDF files, set this option to `true` or pass an array with specific page numbers to use a vision-enabled LLM to index each page of the PDF as a standalone image.
                 *
                 * Enabling this feature will allow Autonomous Nodes in your bot to answer visual or higher-level questions about the content in these pages that can usually not be answered correctly by the default text-based indexing or visual transcription.
                 *
                 * This feature is useful when a PDF has:
                 * - Tables with complex layouts
                 * - Charts, diagrams or infographics
                 * - Photos or images that can be used to answer user queries
                 *
                 * Notes:
                 * - This feature is only available in Team and Enterprise plans.
                 * - Enabling this will incur in extra AI Spend cost and additional File Storage usage, in order to use a vision-enabled LLM to visually index the PDF pages and store them as standalone page images in the bot's file storage.
                 * - Enabling this may increase the overall AI Spend cost of your bot as your bot may pass one or more indexed page images to a vision-enabled LLM for answering user queries.
                 * - This is limited to the first 100 pages of the PDF. If the file has more pages then the rest of the pages will NOT be vision-indexed. If you need to visually index the entire file, please split it into smaller files.
                 * - This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred.
                 */
                indexPages?: {
                    [k: string]: any;
                };
            };
        };
    };
    /**
     * File access policies. Add "public_content" to allow public access to the file content. Add "integrations" to allow read, search and list operations for any integration installed in the bot.
     */
    accessPolicies?: ("public_content" | "integrations")[];
    /**
     * File content type. If omitted, the content type will be inferred from the file extension (if any) specified in `key`. If a content type cannot be inferred, the default is "application/octet-stream".
     */
    contentType?: string;
    /**
     * Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored.
     */
    expiresAt?: string;
    /**
     * Use when your file has "public_content" in its access policy and you need the file\'s content to be immediately accessible through its URL after the file has been uploaded without having to wait for the upload to be processed by our system.
     *
     * If set to `true`, the `x-amz-tagging` HTTP header with a value of `public=true` will need to be sent in the HTTP PUT request to the `uploadUrl` in order for the upload request to work.
     */
    publicContentImmediatelyAccessible?: boolean;
    /**
     * Custom metadata for the file expressed as an object of key-value pairs. The values can be of any type.
     */
    metadata?: {
        [k: string]: any;
    };
}
type UpsertFileInput$1 = UpsertFileRequestBody$1 & UpsertFileRequestHeaders$1 & UpsertFileRequestQuery$1 & UpsertFileRequestParams$1;
interface UpsertFileResponse$1 {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
        /**
         * URL to upload the file content. File content needs to be sent to this URL via a PUT request.
         */
        uploadUrl: string;
    };
}

interface DeleteFileRequestHeaders$1 {
}
interface DeleteFileRequestQuery$1 {
}
interface DeleteFileRequestParams$1 {
    id: string;
}
interface DeleteFileRequestBody$1 {
}
type DeleteFileInput$1 = DeleteFileRequestBody$1 & DeleteFileRequestHeaders$1 & DeleteFileRequestQuery$1 & DeleteFileRequestParams$1;
interface DeleteFileResponse$1 {
}

interface ListFilesRequestHeaders$1 {
}
interface ListFilesRequestQuery$1 {
    nextToken?: string;
    sortField?: "key" | "size" | "createdAt" | "updatedAt" | "status";
    sortDirection?: "asc" | "desc";
    tags?: any;
    /**
     * @maxItems 50
     */
    ids?: string[];
}
interface ListFilesRequestParams$1 {
}
interface ListFilesRequestBody$1 {
}
type ListFilesInput$1 = ListFilesRequestBody$1 & ListFilesRequestHeaders$1 & ListFilesRequestQuery$1 & ListFilesRequestParams$1;
interface ListFilesResponse$1 {
    files: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any | null;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetFileRequestHeaders$1 {
}
interface GetFileRequestQuery$1 {
}
interface GetFileRequestParams$1 {
    id: string;
}
interface GetFileRequestBody$1 {
}
type GetFileInput$1 = GetFileRequestBody$1 & GetFileRequestHeaders$1 & GetFileRequestQuery$1 & GetFileRequestParams$1;
interface GetFileResponse$1 {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    };
}

interface UpdateFileMetadataRequestHeaders$1 {
}
interface UpdateFileMetadataRequestQuery$1 {
}
interface UpdateFileMetadataRequestParams$1 {
    id: string;
}
interface UpdateFileMetadataRequestBody$1 {
    /**
     * Custom metadata for the file expressed as an object of key-value pairs. Omit to keep existing metadata intact. Any existing metadata keys not included will be preserved. New keys will be added. To delete a metadata key, set its value to `null`.
     */
    metadata?: {
        [k: string]: any;
    };
    /**
     * The file tags to update as an object of key-value pairs with `string` (text) values. Omit to keep existing tags intact. Any existing tags not included will be preserved. New tags will be added. To delete a tag, set its value to `null`.
     */
    tags?: {
        [k: string]: string | null;
    };
    /**
     * New access policies to set for the file. Omit to keep existing policies intact.
     */
    accessPolicies?: ("integrations" | "public_content")[];
    /**
     * Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored. Omit to keep the existing expiry intact. Set to `null` to remove the expiry.
     */
    expiresAt?: string | null;
}
type UpdateFileMetadataInput$1 = UpdateFileMetadataRequestBody$1 & UpdateFileMetadataRequestHeaders$1 & UpdateFileMetadataRequestQuery$1 & UpdateFileMetadataRequestParams$1;
interface UpdateFileMetadataResponse$1 {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    };
}

interface CopyFileRequestHeaders$1 {
    "x-destination-bot-id"?: string;
}
interface CopyFileRequestQuery$1 {
}
interface CopyFileRequestParams$1 {
    idOrKey: string;
    destinationKey: string;
}
interface CopyFileRequestBody$1 {
    /**
     * Set to `true` to overwrite the file if it already exists, otherwise an error will be returned.
     *
     * When this endpoint is called using bot authentication, the existing file must have been originally created by the same bot making the file copy request in order to overwrite it.
     */
    overwrite?: boolean;
}
type CopyFileInput$1 = CopyFileRequestBody$1 & CopyFileRequestHeaders$1 & CopyFileRequestQuery$1 & CopyFileRequestParams$1;
interface CopyFileResponse$1 {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    };
}

interface SearchFilesRequestHeaders$1 {
}
interface SearchFilesRequestQuery$1 {
    tags?: any;
    query: string;
    contextDepth?: number;
    limit?: number;
    consolidate?: boolean;
    includeBreadcrumb?: boolean;
    withContext?: boolean;
}
interface SearchFilesRequestParams$1 {
}
interface SearchFilesRequestBody$1 {
}
type SearchFilesInput$1 = SearchFilesRequestBody$1 & SearchFilesRequestHeaders$1 & SearchFilesRequestQuery$1 & SearchFilesRequestParams$1;
interface SearchFilesResponse$1 {
    passages: {
        /**
         * The content of the matching passage in the file including surrounding context, if any.
         */
        content: string;
        /**
         * The score indicating the similarity of the passage to the query. A higher score indicates higher similarity.
         */
        score: number;
        /**
         * The passage metadata.
         */
        meta: {
            /**
             * The type of passage
             */
            type?: "chunk" | "summary" | "consolidated" | "image";
            /**
             * The subtype of passage, if available.
             */
            subtype?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image" | "page";
            /**
             * Page number the passage is located on. Only applicable if the passage was extracted from a PDF file.
             */
            pageNumber?: number;
            /**
             * Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file.
             */
            position?: number;
            /**
             * The URL of the source file for the vector, if applicable (e.g. for image vectors).
             */
            sourceUrl?: string;
        };
        file: {
            /**
             * File ID
             */
            id: string;
            /**
             * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
             */
            key: string;
            /**
             * MIME type of the file's content
             */
            contentType: string;
            /**
             * The tags of the file as an object of key-value pairs.
             */
            tags: {
                [k: string]: string;
            };
            /**
             * File creation timestamp in ISO 8601 format
             */
            createdAt: string;
            /**
             * File last update timestamp in ISO 8601 format
             */
            updatedAt: string;
        };
        /**
         * Surrounding passages including the current passage, based on the requested `contextDepth`. Only returned if the `withContext` parameter is set to `true`. Not supported when using the `consolidate` option.
         */
        context?: {
            /**
             * The ID of the vector that the context passage belongs to. Omitted for breadcrumbs.
             */
            id?: string;
            text: string;
            /**
             * Position of the context passage relative to the current passage. Negative for preceding passages, positive for subsequent, ommited for breadcrumbs.
             */
            offset?: number;
            /**
             * The type of context passage
             */
            type: "preceding" | "subsequent" | "current" | "breadcrumb";
        }[];
    }[];
}

interface ListFilePassagesRequestHeaders$1 {
}
interface ListFilePassagesRequestQuery$1 {
    nextToken?: string;
    limit?: number;
}
interface ListFilePassagesRequestParams$1 {
    id: string;
}
interface ListFilePassagesRequestBody$1 {
}
type ListFilePassagesInput$1 = ListFilePassagesRequestBody$1 & ListFilePassagesRequestHeaders$1 & ListFilePassagesRequestQuery$1 & ListFilePassagesRequestParams$1;
interface ListFilePassagesResponse$1 {
    passages: {
        /**
         * Passage ID
         */
        id: string;
        /**
         * The content of the passage.
         */
        content: string;
        /**
         * The passage metadata.
         */
        meta: {
            /**
             * The type of passage
             */
            type?: "chunk" | "summary" | "consolidated" | "image";
            /**
             * The subtype of passage, if available.
             */
            subtype?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image" | "page";
            /**
             * Page number the passage is located on. Only applicable if the passage was extracted from a PDF file.
             */
            pageNumber?: number;
            /**
             * Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file.
             */
            position?: number;
            /**
             * The URL of the source file for the vector, if applicable (e.g. for image vectors).
             */
            sourceUrl?: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface SetFilePassagesRequestHeaders$1 {
}
interface SetFilePassagesRequestQuery$1 {
}
interface SetFilePassagesRequestParams$1 {
    id: string;
}
interface SetFilePassagesRequestBody$1 {
    /**
     * Note: The passages should appear in the array in the same order as they appear in the original document.
     */
    passages: {
        /**
         * The content of the passage, supports Markdown formatting.
         */
        content: string;
        /**
         * The type should match the Markdown format used for the passage content.
         */
        type?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image";
        pageNumber?: number;
    }[];
}
type SetFilePassagesInput$1 = SetFilePassagesRequestBody$1 & SetFilePassagesRequestHeaders$1 & SetFilePassagesRequestQuery$1 & SetFilePassagesRequestParams$1;
interface SetFilePassagesResponse$1 {
}

interface ListFileTagsRequestHeaders$1 {
}
interface ListFileTagsRequestQuery$1 {
    nextToken?: string;
}
interface ListFileTagsRequestParams$1 {
}
interface ListFileTagsRequestBody$1 {
}
type ListFileTagsInput$1 = ListFileTagsRequestBody$1 & ListFileTagsRequestHeaders$1 & ListFileTagsRequestQuery$1 & ListFileTagsRequestParams$1;
interface ListFileTagsResponse$1 {
    tags: string[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface ListFileTagValuesRequestHeaders$1 {
}
interface ListFileTagValuesRequestQuery$1 {
    nextToken?: string;
}
interface ListFileTagValuesRequestParams$1 {
    tag: string;
}
interface ListFileTagValuesRequestBody$1 {
}
type ListFileTagValuesInput$1 = ListFileTagValuesRequestBody$1 & ListFileTagValuesRequestHeaders$1 & ListFileTagValuesRequestQuery$1 & ListFileTagValuesRequestParams$1;
interface ListFileTagValuesResponse$1 {
    values: string[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateKnowledgeBaseRequestHeaders$1 {
}
interface CreateKnowledgeBaseRequestQuery$1 {
}
interface CreateKnowledgeBaseRequestParams$1 {
}
interface CreateKnowledgeBaseRequestBody$1 {
    /**
     * Name of the knowledge base.
     */
    name: string;
    tags?: {
        [k: string]: string;
    };
}
type CreateKnowledgeBaseInput$1 = CreateKnowledgeBaseRequestBody$1 & CreateKnowledgeBaseRequestHeaders$1 & CreateKnowledgeBaseRequestQuery$1 & CreateKnowledgeBaseRequestParams$1;
interface CreateKnowledgeBaseResponse$1 {
    knowledgeBase: {
        /**
         * Knowledge base ID
         */
        id: string;
        /**
         * Name of the knowledge base.
         */
        name: string;
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteKnowledgeBaseRequestHeaders$1 {
}
interface DeleteKnowledgeBaseRequestQuery$1 {
}
interface DeleteKnowledgeBaseRequestParams$1 {
    id: string;
}
interface DeleteKnowledgeBaseRequestBody$1 {
}
type DeleteKnowledgeBaseInput$1 = DeleteKnowledgeBaseRequestBody$1 & DeleteKnowledgeBaseRequestHeaders$1 & DeleteKnowledgeBaseRequestQuery$1 & DeleteKnowledgeBaseRequestParams$1;
interface DeleteKnowledgeBaseResponse$1 {
}

interface UpdateKnowledgeBaseRequestHeaders$1 {
}
interface UpdateKnowledgeBaseRequestQuery$1 {
}
interface UpdateKnowledgeBaseRequestParams$1 {
    id: string;
}
interface UpdateKnowledgeBaseRequestBody$1 {
    /**
     * New name of the knowledge base.
     */
    name: string;
    /**
     * The knowledge base tags to update as an object of key-value pairs with `string` (text) values. Omit to keep existing tags intact. Any existing tags not included will be preserved. New tags will be added. To delete a tag, set its value to `null`.
     */
    tags?: {
        [k: string]: string | null;
    };
}
type UpdateKnowledgeBaseInput$1 = UpdateKnowledgeBaseRequestBody$1 & UpdateKnowledgeBaseRequestHeaders$1 & UpdateKnowledgeBaseRequestQuery$1 & UpdateKnowledgeBaseRequestParams$1;
interface UpdateKnowledgeBaseResponse$1 {
    knowledgeBase: {
        /**
         * Knowledge base ID
         */
        id: string;
        /**
         * Name of the knowledge base.
         */
        name: string;
        tags: {
            [k: string]: string;
        };
    };
}

interface ListKnowledgeBasesRequestHeaders$1 {
}
interface ListKnowledgeBasesRequestQuery$1 {
    nextToken?: string;
    tags?: any;
}
interface ListKnowledgeBasesRequestParams$1 {
}
interface ListKnowledgeBasesRequestBody$1 {
}
type ListKnowledgeBasesInput$1 = ListKnowledgeBasesRequestBody$1 & ListKnowledgeBasesRequestHeaders$1 & ListKnowledgeBasesRequestQuery$1 & ListKnowledgeBasesRequestParams$1;
interface ListKnowledgeBasesResponse$1 {
    knowledgeBases: {
        /**
         * Knowledge base ID
         */
        id: string;
        /**
         * Name of the knowledge base.
         */
        name: string;
        /**
         * Knowledge base creation timestamp in ISO 8601 format
         */
        createdAt: string;
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

type ClientProps$5 = {
    toAxiosRequest: typeof toAxiosRequest$2;
    toApiError: typeof toApiError$2;
};
declare class Client$5 {
    private axiosInstance;
    private props;
    constructor(axiosInstance: AxiosInstance, props?: Partial<ClientProps$5>);
    readonly upsertFile: (input: UpsertFileInput$1) => Promise<UpsertFileResponse$1>;
    readonly deleteFile: (input: DeleteFileInput$1) => Promise<DeleteFileResponse$1>;
    readonly listFiles: (input: ListFilesInput$1) => Promise<ListFilesResponse$1>;
    readonly getFile: (input: GetFileInput$1) => Promise<GetFileResponse$1>;
    readonly updateFileMetadata: (input: UpdateFileMetadataInput$1) => Promise<UpdateFileMetadataResponse$1>;
    readonly copyFile: (input: CopyFileInput$1) => Promise<CopyFileResponse$1>;
    readonly searchFiles: (input: SearchFilesInput$1) => Promise<SearchFilesResponse$1>;
    readonly listFilePassages: (input: ListFilePassagesInput$1) => Promise<ListFilePassagesResponse$1>;
    readonly setFilePassages: (input: SetFilePassagesInput$1) => Promise<SetFilePassagesResponse$1>;
    readonly listFileTags: (input: ListFileTagsInput$1) => Promise<ListFileTagsResponse$1>;
    readonly listFileTagValues: (input: ListFileTagValuesInput$1) => Promise<ListFileTagValuesResponse$1>;
    readonly createKnowledgeBase: (input: CreateKnowledgeBaseInput$1) => Promise<CreateKnowledgeBaseResponse$1>;
    readonly deleteKnowledgeBase: (input: DeleteKnowledgeBaseInput$1) => Promise<DeleteKnowledgeBaseResponse$1>;
    readonly updateKnowledgeBase: (input: UpdateKnowledgeBaseInput$1) => Promise<UpdateKnowledgeBaseResponse$1>;
    readonly listKnowledgeBases: (input: ListKnowledgeBasesInput$1) => Promise<ListKnowledgeBasesResponse$1>;
}
declare function toApiError$2(err: unknown): Error;

type UploadFileInput = Simplify<Omit<UpsertFileInput$1, 'size'> & {
    content?: ArrayBuffer | Buffer | Blob | Uint8Array | string;
    url?: string;
}>;
type UploadFileOutput = UpsertFileResponse$1;

type IClient$2 = Simplify<Client$5 & {
    uploadFile: (input: UploadFileInput) => Promise<UploadFileOutput>;
}>;
type Operation$2 = Operation$5<IClient$2>;
type ClientInputs$2 = Inputs<IClient$2>;
type ClientOutputs$2 = Outputs<IClient$2>;
type ClientProps$4 = CommonClientProps & {
    token: string;
    botId: string;
    integrationId?: string;
    integrationAlias?: string;
};
declare class Client$4 extends Client$5 implements IClient$2 {
    readonly config: Readonly<ClientConfig>;
    constructor(clientProps: ClientProps$4);
    get list(): {
        files: (props: {
            tags?: any;
            sortField?: "key" | "size" | "createdAt" | "updatedAt" | "status" | undefined;
            sortDirection?: "asc" | "desc" | undefined;
            ids?: string[] | undefined;
        }) => AsyncCollection<{
            id: string;
            botId: string;
            key: string;
            url: string;
            size: number | null;
            contentType: string;
            tags: {
                [k: string]: string;
            };
            metadata: {
                [k: string]: any | null;
            };
            createdAt: string;
            updatedAt: string;
            accessPolicies: ("integrations" | "public_content")[];
            index: boolean;
            status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
            failedStatusReason?: string;
            expiresAt?: string;
            owner: {
                type: "bot" | "integration" | "user";
                id?: string;
                name?: string;
            };
            indexingStack?: "v1" | "v2";
        }>;
        filePassages: (props: {
            id: string;
            limit?: number | undefined;
        }) => AsyncCollection<{
            id: string;
            content: string;
            meta: {
                type?: "chunk" | "summary" | "consolidated" | "image";
                subtype?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image" | "page";
                pageNumber?: number;
                position?: number;
                sourceUrl?: string;
            };
        }>;
        fileTags: (props: {}) => AsyncCollection<string>;
        fileTagValues: (props: {
            tag: string;
        }) => AsyncCollection<string>;
        knowledgeBases: (props: {
            tags?: any;
        }) => AsyncCollection<{
            id: string;
            name: string;
            createdAt: string;
            tags: {
                [k: string]: string;
            };
        }>;
    };
    /**
     * Create/update and upload a file in a single step. Returns an object containing the file metadata and the URL to retrieve the file.
     */
    uploadFile(input: UploadFileInput): Promise<UploadFileOutput>;
}

declare namespace index$1 {
  export { Client$4 as Client, type ClientInputs$2 as ClientInputs, type ClientOutputs$2 as ClientOutputs, type ClientProps$4 as ClientProps, type Operation$2 as Operation };
}

type Primitive$1 = string | number | boolean;
type Value$1<P extends Primitive$1> = P | P[] | Record<string, P>;
type QueryValue$1 = Value$1<string> | Value$1<boolean> | Value$1<number> | undefined;
type AnyQueryParams$1 = Record<string, QueryValue$1>;
type HeaderValue$1 = string | undefined;
type AnyHeaderParams$1 = Record<string, HeaderValue$1>;
type AnyBodyParams$1 = Record<string, any>;
type ParsedRequest$1 = {
    method: string;
    path: string;
    query: AnyQueryParams$1;
    headers: AnyHeaderParams$1;
    body: AnyBodyParams$1;
};
declare const toAxiosRequest$1: (req: ParsedRequest$1) => AxiosRequestConfig;

interface ListTablesRequestHeaders$1 {
}
interface ListTablesRequestQuery$1 {
    tags?: {
        [k: string]: string;
    };
}
interface ListTablesRequestParams$1 {
}
interface ListTablesRequestBody$1 {
}
type ListTablesInput$1 = ListTablesRequestBody$1 & ListTablesRequestHeaders$1 & ListTablesRequestQuery$1 & ListTablesRequestParams$1;
interface ListTablesResponse$1 {
    tables: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    }[];
}

interface GetTableRequestHeaders$1 {
}
interface GetTableRequestQuery$1 {
}
interface GetTableRequestParams$1 {
    table: string;
}
interface GetTableRequestBody$1 {
}
type GetTableInput$1 = GetTableRequestBody$1 & GetTableRequestHeaders$1 & GetTableRequestQuery$1 & GetTableRequestParams$1;
interface GetTableResponse$1 {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * The total number of rows present in the table.
     */
    rows: number;
    /**
     * The number of stale rows that are waiting to be processed
     */
    stale: number;
    /**
     * The number of rows that are waiting to be indexed (for search)
     */
    indexing: number;
}

interface GetOrCreateTableRequestHeaders$1 {
}
interface GetOrCreateTableRequestQuery$1 {
}
interface GetOrCreateTableRequestParams$1 {
    table: string;
}
interface GetOrCreateTableRequestBody$1 {
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type GetOrCreateTableInput$1 = GetOrCreateTableRequestBody$1 & GetOrCreateTableRequestHeaders$1 & GetOrCreateTableRequestQuery$1 & GetOrCreateTableRequestParams$1;
interface GetOrCreateTableResponse$1 {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * Flag indicating if the table was newly created.
     */
    created: boolean;
    /**
     * The total number of rows present in the table.
     */
    rows: number;
    /**
     * The number of stale rows that are waiting to be processed
     */
    stale: number;
    /**
     * The number of rows that are waiting to be indexed (for search)
     */
    indexing: number;
}

interface CreateTableRequestHeaders$1 {
}
interface CreateTableRequestQuery$1 {
}
interface CreateTableRequestParams$1 {
}
interface CreateTableRequestBody$1 {
    /**
     * Required. This name is used to identify your table.
     */
    name: string;
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type CreateTableInput$1 = CreateTableRequestBody$1 & CreateTableRequestHeaders$1 & CreateTableRequestQuery$1 & CreateTableRequestParams$1;
interface CreateTableResponse$1 {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
}

interface DuplicateTableRequestHeaders$1 {
}
interface DuplicateTableRequestQuery$1 {
}
interface DuplicateTableRequestParams$1 {
    sourceTableId: string;
}
interface DuplicateTableRequestBody$1 {
    tableName?: string;
    /**
     * Only duplicate the schema, not the content
     */
    schemaOnly?: boolean;
    /**
     * Use a different factor for the table. Leave empty to use the same as the duplicated table.
     */
    factor?: number;
}
type DuplicateTableInput$1 = DuplicateTableRequestBody$1 & DuplicateTableRequestHeaders$1 & DuplicateTableRequestQuery$1 & DuplicateTableRequestParams$1;
interface DuplicateTableResponse$1 {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * The total number of rows present in the table.
     */
    rows: number;
}

interface ExportTableRequestHeaders$1 {
}
interface ExportTableRequestQuery$1 {
    format?: "csv" | "json";
    compress?: boolean;
}
interface ExportTableRequestParams$1 {
    table: string;
}
interface ExportTableRequestBody$1 {
}
type ExportTableInput$1 = ExportTableRequestBody$1 & ExportTableRequestHeaders$1 & ExportTableRequestQuery$1 & ExportTableRequestParams$1;
interface ExportTableResponse$1 {
    job: {
        id: string;
        botId: string;
        tableId: string;
        type: "export" | "import";
        status: "pending" | "in_progress" | "finalizing" | "completed" | "failed";
        progress?: number;
        inputFileId: string | null;
        outputFileId: string | null;
        createdAt: string;
        updatedAt: string;
    };
}

interface GetTableJobsRequestHeaders$1 {
}
interface GetTableJobsRequestQuery$1 {
}
interface GetTableJobsRequestParams$1 {
    table: string;
}
interface GetTableJobsRequestBody$1 {
}
type GetTableJobsInput$1 = GetTableJobsRequestBody$1 & GetTableJobsRequestHeaders$1 & GetTableJobsRequestQuery$1 & GetTableJobsRequestParams$1;
interface GetTableJobsResponse$1 {
    jobs: {
        id: string;
        botId: string;
        tableId: string;
        type: "export" | "import";
        status: "pending" | "in_progress" | "finalizing" | "completed" | "failed";
        progress?: number;
        inputFileId: string | null;
        outputFileId: string | null;
        createdAt: string;
        updatedAt: string;
    }[];
}

interface ImportTableRequestHeaders$1 {
}
interface ImportTableRequestQuery$1 {
}
interface ImportTableRequestParams$1 {
    table: string;
}
interface ImportTableRequestBody$1 {
    /**
     * The file ID to import. It must have been uploaded to the Files API before. Supported formats: CSV, JSON (gzipped or not)
     */
    fileId: string;
}
type ImportTableInput$1 = ImportTableRequestBody$1 & ImportTableRequestHeaders$1 & ImportTableRequestQuery$1 & ImportTableRequestParams$1;
interface ImportTableResponse$1 {
    job: {
        id: string;
        botId: string;
        tableId: string;
        type: "export" | "import";
        status: "pending" | "in_progress" | "finalizing" | "completed" | "failed";
        progress?: number;
        inputFileId: string | null;
        outputFileId: string | null;
        createdAt: string;
        updatedAt: string;
    };
}

interface UpdateTableRequestHeaders$1 {
}
interface UpdateTableRequestQuery$1 {
}
interface UpdateTableRequestParams$1 {
    table: string;
}
interface UpdateTableRequestBody$1 {
    /**
     * Required. This name is used to identify your table.
     */
    name?: string;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema?: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type UpdateTableInput$1 = UpdateTableRequestBody$1 & UpdateTableRequestHeaders$1 & UpdateTableRequestQuery$1 & UpdateTableRequestParams$1;
interface UpdateTableResponse$1 {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * List of columns that have become stale following the modification.
     */
    staleColumns?: string[];
}

interface RenameTableColumnRequestHeaders$1 {
}
interface RenameTableColumnRequestQuery$1 {
}
interface RenameTableColumnRequestParams$1 {
    table: string;
}
interface RenameTableColumnRequestBody$1 {
    /**
     * The existing name of the column.
     */
    name: string;
    /**
     * The new name to assign to the column.
     */
    newName: string;
}
type RenameTableColumnInput$1 = RenameTableColumnRequestBody$1 & RenameTableColumnRequestHeaders$1 & RenameTableColumnRequestQuery$1 & RenameTableColumnRequestParams$1;
interface RenameTableColumnResponse$1 {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
}

interface DeleteTableRequestHeaders$1 {
}
interface DeleteTableRequestQuery$1 {
}
interface DeleteTableRequestParams$1 {
    table: string;
}
interface DeleteTableRequestBody$1 {
}
type DeleteTableInput$1 = DeleteTableRequestBody$1 & DeleteTableRequestHeaders$1 & DeleteTableRequestQuery$1 & DeleteTableRequestParams$1;
interface DeleteTableResponse$1 {
}

interface GetTableRowRequestHeaders$1 {
}
interface GetTableRowRequestQuery$1 {
    id: number;
}
interface GetTableRowRequestParams$1 {
    table: string;
}
interface GetTableRowRequestBody$1 {
}
type GetTableRowInput$1 = GetTableRowRequestBody$1 & GetTableRowRequestHeaders$1 & GetTableRowRequestQuery$1 & GetTableRowRequestParams$1;
interface GetTableRowResponse$1 {
    row: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    };
}

interface FindTableRowsRequestHeaders$1 {
}
interface FindTableRowsRequestQuery$1 {
}
interface FindTableRowsRequestParams$1 {
    table: string;
}
interface FindTableRowsRequestBody$1 {
    /**
     * Limit for pagination, specifying the maximum number of rows to return.
     */
    limit?: number;
    /**
     * Offset for pagination, specifying where to start returning rows from.
     */
    offset?: number;
    /**
     * Provide a mongodb-like filter to apply to the query. Example: \{ "name": \{ "$eq": "John" \} \}
     */
    filter?: {
        [k: string]: any;
    };
    /**
     * Group the rows by a specific column and apply aggregations to them. Allowed values: key, avg, max, min, sum, count. Example: \{ "someId": "key", "orders": ["sum", "avg"] \}
     */
    group?: {
        [k: string]: any;
    };
    /**
     * Search term to apply to the row search. When using this parameter, some rows which doesn't match the search term will be returned, use the similarity field to know how much the row matches the search term.
     */
    search?: string;
    /**
     * Specifies the column by which to order the results. By default it is ordered by id. Build-in columns: id, createdAt, updatedAt
     */
    orderBy?: string;
    /**
     * Specifies the direction of sorting, either ascending or descending.
     */
    orderDirection?: "asc" | "desc";
}
type FindTableRowsInput$1 = FindTableRowsRequestBody$1 & FindTableRowsRequestHeaders$1 & FindTableRowsRequestQuery$1 & FindTableRowsRequestParams$1;
interface FindTableRowsResponse$1 {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Flag indicating if there are more rows to fetch.
     */
    hasMore: boolean;
    offset: number;
    limit: number;
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
}

interface CreateTableRowsRequestHeaders$1 {
}
interface CreateTableRowsRequestQuery$1 {
}
interface CreateTableRowsRequestParams$1 {
    table: string;
}
interface CreateTableRowsRequestBody$1 {
    /**
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        [k: string]: any;
    }[];
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type CreateTableRowsInput$1 = CreateTableRowsRequestBody$1 & CreateTableRowsRequestHeaders$1 & CreateTableRowsRequestQuery$1 & CreateTableRowsRequestParams$1;
interface CreateTableRowsResponse$1 {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface DeleteTableRowsRequestHeaders$1 {
}
interface DeleteTableRowsRequestQuery$1 {
}
interface DeleteTableRowsRequestParams$1 {
    table: string;
}
interface DeleteTableRowsRequestBody$1 {
    /**
     * @maxItems 1000
     */
    ids?: number[];
    /**
     * Filter to apply when deleting rows. Example: \{ "name": \{ "$eq": "John" \} \}
     */
    filter?: {
        [k: string]: any;
    };
    /**
     * Flag to delete all rows. Use with caution as this action is irreversible.
     */
    deleteAllRows?: boolean;
}
type DeleteTableRowsInput$1 = DeleteTableRowsRequestBody$1 & DeleteTableRowsRequestHeaders$1 & DeleteTableRowsRequestQuery$1 & DeleteTableRowsRequestParams$1;
interface DeleteTableRowsResponse$1 {
    deletedRows: number;
}

interface UpdateTableRowsRequestHeaders$1 {
}
interface UpdateTableRowsRequestQuery$1 {
}
interface UpdateTableRowsRequestParams$1 {
    table: string;
}
interface UpdateTableRowsRequestBody$1 {
    /**
     * Rows with updated data, identified by ID.
     *
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        id: number;
        [k: string]: any;
    }[];
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type UpdateTableRowsInput$1 = UpdateTableRowsRequestBody$1 & UpdateTableRowsRequestHeaders$1 & UpdateTableRowsRequestQuery$1 & UpdateTableRowsRequestParams$1;
interface UpdateTableRowsResponse$1 {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface UpsertTableRowsRequestHeaders$1 {
}
interface UpsertTableRowsRequestQuery$1 {
}
interface UpsertTableRowsRequestParams$1 {
    table: string;
}
interface UpsertTableRowsRequestBody$1 {
    /**
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        id?: number;
        [k: string]: any;
    }[];
    /**
     * Determines if a row is inserted or updated. Defaults to "id".
     */
    keyColumn?: string;
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type UpsertTableRowsInput$1 = UpsertTableRowsRequestBody$1 & UpsertTableRowsRequestHeaders$1 & UpsertTableRowsRequestQuery$1 & UpsertTableRowsRequestParams$1;
interface UpsertTableRowsResponse$1 {
    inserted: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    updated: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

type ClientProps$3 = {
    toAxiosRequest: typeof toAxiosRequest$1;
    toApiError: typeof toApiError$1;
};
declare class Client$3 {
    private axiosInstance;
    private props;
    constructor(axiosInstance: AxiosInstance, props?: Partial<ClientProps$3>);
    readonly listTables: (input: ListTablesInput$1) => Promise<ListTablesResponse$1>;
    readonly getTable: (input: GetTableInput$1) => Promise<GetTableResponse$1>;
    readonly getOrCreateTable: (input: GetOrCreateTableInput$1) => Promise<GetOrCreateTableResponse$1>;
    readonly createTable: (input: CreateTableInput$1) => Promise<CreateTableResponse$1>;
    readonly duplicateTable: (input: DuplicateTableInput$1) => Promise<DuplicateTableResponse$1>;
    readonly exportTable: (input: ExportTableInput$1) => Promise<ExportTableResponse$1>;
    readonly getTableJobs: (input: GetTableJobsInput$1) => Promise<GetTableJobsResponse$1>;
    readonly importTable: (input: ImportTableInput$1) => Promise<ImportTableResponse$1>;
    readonly updateTable: (input: UpdateTableInput$1) => Promise<UpdateTableResponse$1>;
    readonly renameTableColumn: (input: RenameTableColumnInput$1) => Promise<RenameTableColumnResponse$1>;
    readonly deleteTable: (input: DeleteTableInput$1) => Promise<DeleteTableResponse$1>;
    readonly getTableRow: (input: GetTableRowInput$1) => Promise<GetTableRowResponse$1>;
    readonly findTableRows: (input: FindTableRowsInput$1) => Promise<FindTableRowsResponse$1>;
    readonly createTableRows: (input: CreateTableRowsInput$1) => Promise<CreateTableRowsResponse$1>;
    readonly deleteTableRows: (input: DeleteTableRowsInput$1) => Promise<DeleteTableRowsResponse$1>;
    readonly updateTableRows: (input: UpdateTableRowsInput$1) => Promise<UpdateTableRowsResponse$1>;
    readonly upsertTableRows: (input: UpsertTableRowsInput$1) => Promise<UpsertTableRowsResponse$1>;
}
declare function toApiError$1(err: unknown): Error;

type IClient$1 = Simplify<Client$3>;
type Operation$1 = Operation$5<IClient$1>;
type ClientInputs$1 = Inputs<IClient$1>;
type ClientOutputs$1 = Outputs<IClient$1>;
type ClientProps$2 = CommonClientProps & {
    token: string;
    botId: string;
    integrationId?: string;
    integrationAlias?: string;
};
declare class Client$2 extends Client$3 {
    readonly config: Readonly<ClientConfig>;
    constructor(clientProps: ClientProps$2);
}

declare namespace index {
  export { Client$2 as Client, type ClientInputs$1 as ClientInputs, type ClientOutputs$1 as ClientOutputs, type ClientProps$2 as ClientProps, type Operation$1 as Operation };
}

type Primitive = string | number | boolean;
type Value<P extends Primitive> = P | P[] | Record<string, P>;
type QueryValue = Value<string> | Value<boolean> | Value<number> | undefined;
type AnyQueryParams = Record<string, QueryValue>;
type HeaderValue = string | undefined;
type AnyHeaderParams = Record<string, HeaderValue>;
type AnyBodyParams = Record<string, any>;
type ParsedRequest = {
    method: string;
    path: string;
    query: AnyQueryParams;
    headers: AnyHeaderParams;
    body: AnyBodyParams;
};
declare const toAxiosRequest: (req: ParsedRequest) => AxiosRequestConfig;

interface CreateConversationRequestHeaders {
}
interface CreateConversationRequestQuery {
}
interface CreateConversationRequestParams {
}
interface CreateConversationRequestBody {
    /**
     * Channel name
     */
    channel: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a conversation from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
}
type CreateConversationInput = CreateConversationRequestBody & CreateConversationRequestHeaders & CreateConversationRequestQuery & CreateConversationRequestParams;
interface CreateConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetConversationRequestHeaders {
}
interface GetConversationRequestQuery {
}
interface GetConversationRequestParams {
    id: string;
}
interface GetConversationRequestBody {
}
type GetConversationInput = GetConversationRequestBody & GetConversationRequestHeaders & GetConversationRequestQuery & GetConversationRequestParams;
interface GetConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface ListConversationsRequestHeaders {
}
interface ListConversationsRequestQuery {
    nextToken?: string;
    sortField?: "createdAt" | "updatedAt";
    sortDirection?: "asc" | "desc";
    tags?: {
        [k: string]: string;
    };
    participantIds?: string[];
    integrationName?: string;
    channel?: string;
}
interface ListConversationsRequestParams {
}
interface ListConversationsRequestBody {
}
type ListConversationsInput = ListConversationsRequestBody & ListConversationsRequestHeaders & ListConversationsRequestQuery & ListConversationsRequestParams;
interface ListConversationsResponse {
    conversations: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateConversationRequestHeaders {
}
interface GetOrCreateConversationRequestQuery {
}
interface GetOrCreateConversationRequestParams {
}
interface GetOrCreateConversationRequestBody {
    /**
     * Channel name
     */
    channel: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a conversation from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Optional list of tag names to use for strict matching when looking up existing conversations. If provided, all specified tags must match exactly for a conversation to be considered a match. For example, with an existing conversation whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateConversationInput = GetOrCreateConversationRequestBody & GetOrCreateConversationRequestHeaders & GetOrCreateConversationRequestQuery & GetOrCreateConversationRequestParams;
interface GetOrCreateConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateConversationRequestHeaders {
}
interface UpdateConversationRequestQuery {
}
interface UpdateConversationRequestParams {
    id: string;
}
interface UpdateConversationRequestBody {
    currentTaskId?: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags?: {
        [k: string]: string;
    };
}
type UpdateConversationInput = UpdateConversationRequestBody & UpdateConversationRequestHeaders & UpdateConversationRequestQuery & UpdateConversationRequestParams;
interface UpdateConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteConversationRequestHeaders {
}
interface DeleteConversationRequestQuery {
}
interface DeleteConversationRequestParams {
    id: string;
}
interface DeleteConversationRequestBody {
}
type DeleteConversationInput = DeleteConversationRequestBody & DeleteConversationRequestHeaders & DeleteConversationRequestQuery & DeleteConversationRequestParams;
interface DeleteConversationResponse {
}

interface ListParticipantsRequestHeaders {
}
interface ListParticipantsRequestQuery {
    nextToken?: string;
}
interface ListParticipantsRequestParams {
    id: string;
}
interface ListParticipantsRequestBody {
}
type ListParticipantsInput = ListParticipantsRequestBody & ListParticipantsRequestHeaders & ListParticipantsRequestQuery & ListParticipantsRequestParams;
interface ListParticipantsResponse {
    participants: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface AddParticipantRequestHeaders {
}
interface AddParticipantRequestQuery {
}
interface AddParticipantRequestParams {
    id: string;
}
interface AddParticipantRequestBody {
    /**
     * User id
     */
    userId: string;
}
type AddParticipantInput = AddParticipantRequestBody & AddParticipantRequestHeaders & AddParticipantRequestQuery & AddParticipantRequestParams;
interface AddParticipantResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    participant: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface GetParticipantRequestHeaders {
}
interface GetParticipantRequestQuery {
}
interface GetParticipantRequestParams {
    id: string;
    userId: string;
}
interface GetParticipantRequestBody {
}
type GetParticipantInput = GetParticipantRequestBody & GetParticipantRequestHeaders & GetParticipantRequestQuery & GetParticipantRequestParams;
interface GetParticipantResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    participant: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface RemoveParticipantRequestHeaders {
}
interface RemoveParticipantRequestQuery {
}
interface RemoveParticipantRequestParams {
    id: string;
    userId: string;
}
interface RemoveParticipantRequestBody {
}
type RemoveParticipantInput = RemoveParticipantRequestBody & RemoveParticipantRequestHeaders & RemoveParticipantRequestQuery & RemoveParticipantRequestParams;
interface RemoveParticipantResponse {
}

interface CreateEventRequestHeaders {
}
interface CreateEventRequestQuery {
}
interface CreateEventRequestParams {
}
interface CreateEventRequestBody {
    /**
     * Type of the [Event](#schema_event).
     */
    type: string;
    /**
     * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our API.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Schedule the Event to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Event](#schema_event) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Event](#schema_event)
         */
        delay?: number;
    };
    /**
     * ID of the [Conversation](#schema_conversation) to link the event to.
     */
    conversationId?: string;
    /**
     * ID of the [User](#schema_user) to link the event to.
     */
    userId?: string;
    /**
     * ID of the [Workflow](#schema_workflow) to link the event to.
     */
    workflowId?: string;
    /**
     * ID of the [Message](#schema_message) to link the event to.
     */
    messageId?: string;
}
type CreateEventInput = CreateEventRequestBody & CreateEventRequestHeaders & CreateEventRequestQuery & CreateEventRequestParams;
interface CreateEventResponse {
    /**
     * The event object represents an action or an occurrence.
     */
    event: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    };
}

interface GetEventRequestHeaders {
}
interface GetEventRequestQuery {
}
interface GetEventRequestParams {
    id: string;
}
interface GetEventRequestBody {
}
type GetEventInput = GetEventRequestBody & GetEventRequestHeaders & GetEventRequestQuery & GetEventRequestParams;
interface GetEventResponse {
    /**
     * The event object represents an action or an occurrence.
     */
    event: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    };
}

interface ListEventsRequestHeaders {
}
interface ListEventsRequestQuery {
    nextToken?: string;
    type?: string;
    conversationId?: string;
    userId?: string;
    messageId?: string;
    workflowId?: string;
    status?: "pending" | "ignored" | "processed" | "failed" | "scheduled";
}
interface ListEventsRequestParams {
}
interface ListEventsRequestBody {
}
type ListEventsInput = ListEventsRequestBody & ListEventsRequestHeaders & ListEventsRequestQuery & ListEventsRequestParams;
interface ListEventsResponse {
    events: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateMessageRequestHeaders {
}
interface CreateMessageRequestQuery {
}
interface CreateMessageRequestParams {
}
interface CreateMessageRequestBody {
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Message](#schema_message). The set of [Tags](/docs/developers/concepts/tags) available on a [Message](#schema_message) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Message](#schema_message) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Message](#schema_message)
         */
        delay?: number;
    };
    origin?: "synthetic";
}
type CreateMessageInput = CreateMessageRequestBody & CreateMessageRequestHeaders & CreateMessageRequestQuery & CreateMessageRequestParams;
interface CreateMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface GetOrCreateMessageRequestHeaders {
}
interface GetOrCreateMessageRequestQuery {
}
interface GetOrCreateMessageRequestParams {
}
interface GetOrCreateMessageRequestBody {
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Message](#schema_message). The set of [Tags](/docs/developers/concepts/tags) available on a [Message](#schema_message) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Message](#schema_message) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Message](#schema_message)
         */
        delay?: number;
    };
    origin?: "synthetic";
    /**
     * Optional list of tag names to use for strict matching when looking up existing messages. If provided, all specified tags must match exactly for a message to be considered a match. For example, with an existing message whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateMessageInput = GetOrCreateMessageRequestBody & GetOrCreateMessageRequestHeaders & GetOrCreateMessageRequestQuery & GetOrCreateMessageRequestParams;
interface GetOrCreateMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface GetMessageRequestHeaders {
}
interface GetMessageRequestQuery {
}
interface GetMessageRequestParams {
    id: string;
}
interface GetMessageRequestBody {
}
type GetMessageInput = GetMessageRequestBody & GetMessageRequestHeaders & GetMessageRequestQuery & GetMessageRequestParams;
interface GetMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface UpdateMessageRequestHeaders {
}
interface UpdateMessageRequestQuery {
}
interface UpdateMessageRequestParams {
    id: string;
}
interface UpdateMessageRequestBody {
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload?: {
        [k: string]: any;
    };
}
type UpdateMessageInput = UpdateMessageRequestBody & UpdateMessageRequestHeaders & UpdateMessageRequestQuery & UpdateMessageRequestParams;
interface UpdateMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    };
}

interface ListMessagesRequestHeaders {
}
interface ListMessagesRequestQuery {
    nextToken?: string;
    conversationId?: string;
    tags?: {
        [k: string]: string;
    };
}
interface ListMessagesRequestParams {
}
interface ListMessagesRequestBody {
}
type ListMessagesInput = ListMessagesRequestBody & ListMessagesRequestHeaders & ListMessagesRequestQuery & ListMessagesRequestParams;
interface ListMessagesResponse {
    messages: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Update date of the [Message](#schema_message) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Origin of the message (`synthetic`).
         */
        origin?: "synthetic";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface DeleteMessageRequestHeaders {
}
interface DeleteMessageRequestQuery {
}
interface DeleteMessageRequestParams {
    id: string;
}
interface DeleteMessageRequestBody {
}
type DeleteMessageInput = DeleteMessageRequestBody & DeleteMessageRequestHeaders & DeleteMessageRequestQuery & DeleteMessageRequestParams;
interface DeleteMessageResponse {
}

interface CreateUserRequestHeaders {
}
interface CreateUserRequestQuery {
}
interface CreateUserRequestParams {
}
interface CreateUserRequestBody {
    /**
     * Tags for the [User](#schema_user)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a [User](#schema_user) from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Name of the user
     */
    name?: string;
    /**
     * URI of the user picture
     */
    pictureUrl?: string;
}
type CreateUserInput = CreateUserRequestBody & CreateUserRequestHeaders & CreateUserRequestQuery & CreateUserRequestParams;
interface CreateUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface GetUserRequestHeaders {
}
interface GetUserRequestQuery {
}
interface GetUserRequestParams {
    id: string;
}
interface GetUserRequestBody {
}
type GetUserInput = GetUserRequestBody & GetUserRequestHeaders & GetUserRequestQuery & GetUserRequestParams;
interface GetUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface ListUsersRequestHeaders {
}
interface ListUsersRequestQuery {
    nextToken?: string;
    conversationId?: string;
    tags?: {
        [k: string]: string;
    };
}
interface ListUsersRequestParams {
}
interface ListUsersRequestBody {
}
type ListUsersInput = ListUsersRequestBody & ListUsersRequestHeaders & ListUsersRequestQuery & ListUsersRequestParams;
interface ListUsersResponse {
    users: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateUserRequestHeaders {
}
interface GetOrCreateUserRequestQuery {
}
interface GetOrCreateUserRequestParams {
}
interface GetOrCreateUserRequestBody {
    /**
     * Tags for the [User](#schema_user)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a [User](#schema_user) from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Name of the user
     */
    name?: string;
    /**
     * URI of the user picture
     */
    pictureUrl?: string;
    /**
     * Optional list of tag names to use for strict matching when looking up existing users. If provided, all specified tags must match exactly for a user to be considered a match. For example, with an existing user whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateUserInput = GetOrCreateUserRequestBody & GetOrCreateUserRequestHeaders & GetOrCreateUserRequestQuery & GetOrCreateUserRequestParams;
interface GetOrCreateUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface UpdateUserRequestHeaders {
}
interface UpdateUserRequestQuery {
}
interface UpdateUserRequestParams {
    id: string;
}
interface UpdateUserRequestBody {
    /**
     * Tags for the [User](#schema_user)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Name of the user
     */
    name?: string | null;
    /**
     * URI of the user picture
     */
    pictureUrl?: string | null;
}
type UpdateUserInput = UpdateUserRequestBody & UpdateUserRequestHeaders & UpdateUserRequestQuery & UpdateUserRequestParams;
interface UpdateUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface DeleteUserRequestHeaders {
}
interface DeleteUserRequestQuery {
}
interface DeleteUserRequestParams {
    id: string;
}
interface DeleteUserRequestBody {
}
type DeleteUserInput = DeleteUserRequestBody & DeleteUserRequestHeaders & DeleteUserRequestQuery & DeleteUserRequestParams;
interface DeleteUserResponse {
}

interface SetStateExpiryRequestHeaders {
}
interface SetStateExpiryRequestQuery {
}
interface SetStateExpiryRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface SetStateExpiryRequestBody {
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry: number | null;
}
type SetStateExpiryInput = SetStateExpiryRequestBody & SetStateExpiryRequestHeaders & SetStateExpiryRequestQuery & SetStateExpiryRequestParams;
interface SetStateExpiryResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface GetStateRequestHeaders {
}
interface GetStateRequestQuery {
}
interface GetStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface GetStateRequestBody {
}
type GetStateInput = GetStateRequestBody & GetStateRequestHeaders & GetStateRequestQuery & GetStateRequestParams;
interface GetStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
    meta: {
        cached: boolean;
    };
}

interface SetStateRequestHeaders {
}
interface SetStateRequestQuery {
}
interface SetStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface SetStateRequestBody {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    } | null;
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry?: number | null;
}
type SetStateInput = SetStateRequestBody & SetStateRequestHeaders & SetStateRequestQuery & SetStateRequestParams;
interface SetStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface GetOrSetStateRequestHeaders {
}
interface GetOrSetStateRequestQuery {
}
interface GetOrSetStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface GetOrSetStateRequestBody {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry?: number | null;
}
type GetOrSetStateInput = GetOrSetStateRequestBody & GetOrSetStateRequestHeaders & GetOrSetStateRequestQuery & GetOrSetStateRequestParams;
interface GetOrSetStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
    meta: {
        cached: boolean;
    };
}

interface PatchStateRequestHeaders {
}
interface PatchStateRequestQuery {
}
interface PatchStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface PatchStateRequestBody {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
}
type PatchStateInput = PatchStateRequestBody & PatchStateRequestHeaders & PatchStateRequestQuery & PatchStateRequestParams;
interface PatchStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface CallActionRequestHeaders {
}
interface CallActionRequestQuery {
}
interface CallActionRequestParams {
}
interface CallActionRequestBody {
    /**
     * Type of the action
     */
    type: string;
    /**
     * Input of the action
     */
    input: {
        [k: string]: any;
    };
}
type CallActionInput = CallActionRequestBody & CallActionRequestHeaders & CallActionRequestQuery & CallActionRequestParams;
interface CallActionResponse {
    /**
     * Input of the action
     */
    output: {
        [k: string]: any;
    };
    meta: {
        cached: boolean;
    };
}

interface ConfigureIntegrationRequestHeaders {
}
interface ConfigureIntegrationRequestQuery {
}
interface ConfigureIntegrationRequestParams {
}
interface ConfigureIntegrationRequestBody {
    /**
     * Unique identifier of the integration that was installed on the bot
     */
    identifier?: string | null;
    /**
     * Recurring schedule on which `register()` will be called on the integration
     */
    scheduleRegisterCall?: "hourly" | "daily" | "weekly" | "bi-weekly" | "monthly" | "bi-monthly" | "quarterly" | "yearly";
    /**
     * **EXPERIMENTAL** Sandbox identifiers for the integration. Setting this to null will remove all sandbox identifiers.           This is an experimental feature meant to be used by specific integrations.
     */
    sandboxIdentifiers?: {} | null;
}
type ConfigureIntegrationInput = ConfigureIntegrationRequestBody & ConfigureIntegrationRequestHeaders & ConfigureIntegrationRequestQuery & ConfigureIntegrationRequestParams;
interface ConfigureIntegrationResponse {
}

interface GetTaskRequestHeaders {
}
interface GetTaskRequestQuery {
}
interface GetTaskRequestParams {
    id: string;
}
interface GetTaskRequestBody {
}
type GetTaskInput = GetTaskRequestBody & GetTaskRequestHeaders & GetTaskRequestQuery & GetTaskRequestParams;
interface GetTaskResponse {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface CreateTaskRequestHeaders {
}
interface CreateTaskRequestQuery {
}
interface CreateTaskRequestParams {
}
interface CreateTaskRequestBody {
    /**
     * Title describing the task
     */
    title?: string;
    /**
     * All the notes related to the execution of the current task
     */
    description?: string;
    /**
     * Type of the task
     */
    type: string;
    /**
     * Content related to the task
     */
    data?: {
        [k: string]: any;
    };
    /**
     * Parent task id is the parent task that created this task
     */
    parentTaskId?: string;
    /**
     * Conversation id related to this task
     */
    conversationId: string;
    /**
     * Specific user related to this task
     */
    userId?: string;
    /**
     * The timeout date where the task should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Task](#schema_task)
     */
    tags?: {
        [k: string]: string;
    };
}
type CreateTaskInput = CreateTaskRequestBody & CreateTaskRequestHeaders & CreateTaskRequestQuery & CreateTaskRequestParams;
interface CreateTaskResponse {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateTaskRequestHeaders {
}
interface UpdateTaskRequestQuery {
}
interface UpdateTaskRequestParams {
    id: string;
}
interface UpdateTaskRequestBody {
    /**
     * Title describing the task
     */
    title?: string;
    /**
     * All the notes related to the execution of the current task
     */
    description?: string;
    /**
     * Content related to the task
     */
    data?: {
        [k: string]: any;
    };
    /**
     * The timeout date where the task should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Status of the task
     */
    status?: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
    /**
     * Tags for the [Task](#schema_task)
     */
    tags?: {
        [k: string]: string;
    };
}
type UpdateTaskInput = UpdateTaskRequestBody & UpdateTaskRequestHeaders & UpdateTaskRequestQuery & UpdateTaskRequestParams;
interface UpdateTaskResponse {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteTaskRequestHeaders {
}
interface DeleteTaskRequestQuery {
}
interface DeleteTaskRequestParams {
    id: string;
}
interface DeleteTaskRequestBody {
}
type DeleteTaskInput = DeleteTaskRequestBody & DeleteTaskRequestHeaders & DeleteTaskRequestQuery & DeleteTaskRequestParams;
interface DeleteTaskResponse {
}

interface ListTasksRequestHeaders {
}
interface ListTasksRequestQuery {
    nextToken?: string;
    tags?: {
        [k: string]: string;
    };
    conversationId?: string;
    userId?: string;
    parentTaskId?: string;
    status?: ("pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled")[];
    type?: string;
}
interface ListTasksRequestParams {
}
interface ListTasksRequestBody {
}
type ListTasksInput = ListTasksRequestBody & ListTasksRequestHeaders & ListTasksRequestQuery & ListTasksRequestParams;
interface ListTasksResponse {
    tasks: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateWorkflowRequestHeaders {
}
interface CreateWorkflowRequestQuery {
}
interface CreateWorkflowRequestParams {
}
interface CreateWorkflowRequestBody {
    /**
     * Name of the workflow
     */
    name: string;
    /**
     * Content related to the workflow
     */
    input?: {
        [k: string]: any;
    };
    /**
     * Parent workflow id is the parent workflow that created this workflow
     */
    parentWorkflowId?: string;
    /**
     * Conversation id related to this workflow
     */
    conversationId?: string;
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    status: "pending" | "in_progress" | "listening";
    /**
     * Event id must be specified if the workflow is created with the status in_progress
     */
    eventId?: string;
}
type CreateWorkflowInput = CreateWorkflowRequestBody & CreateWorkflowRequestHeaders & CreateWorkflowRequestQuery & CreateWorkflowRequestParams;
interface CreateWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetWorkflowRequestHeaders {
}
interface GetWorkflowRequestQuery {
}
interface GetWorkflowRequestParams {
    id: string;
}
interface GetWorkflowRequestBody {
}
type GetWorkflowInput = GetWorkflowRequestBody & GetWorkflowRequestHeaders & GetWorkflowRequestQuery & GetWorkflowRequestParams;
interface GetWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateWorkflowRequestHeaders {
}
interface UpdateWorkflowRequestQuery {
}
interface UpdateWorkflowRequestParams {
    id: string;
}
interface UpdateWorkflowRequestBody {
    /**
     * Content related to the workflow
     */
    output?: {
        [k: string]: any;
    };
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Status of the workflow
     */
    status?: "completed" | "cancelled" | "listening" | "paused" | "failed" | "in_progress";
    /**
     * Reason why the workflow failed
     */
    failureReason?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * Event id must be specified if the workflow is updated with the status in_progress
     */
    eventId?: string;
}
type UpdateWorkflowInput = UpdateWorkflowRequestBody & UpdateWorkflowRequestHeaders & UpdateWorkflowRequestQuery & UpdateWorkflowRequestParams;
interface UpdateWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteWorkflowRequestHeaders {
}
interface DeleteWorkflowRequestQuery {
}
interface DeleteWorkflowRequestParams {
    id: string;
}
interface DeleteWorkflowRequestBody {
}
type DeleteWorkflowInput = DeleteWorkflowRequestBody & DeleteWorkflowRequestHeaders & DeleteWorkflowRequestQuery & DeleteWorkflowRequestParams;
interface DeleteWorkflowResponse {
}

interface ListWorkflowsRequestHeaders {
}
interface ListWorkflowsRequestQuery {
    nextToken?: string;
    tags?: {
        [k: string]: string;
    };
    conversationId?: string;
    userId?: string;
    parentWorkflowId?: string;
    statuses?: ("pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled")[];
    name?: string;
}
interface ListWorkflowsRequestParams {
}
interface ListWorkflowsRequestBody {
}
type ListWorkflowsInput = ListWorkflowsRequestBody & ListWorkflowsRequestHeaders & ListWorkflowsRequestQuery & ListWorkflowsRequestParams;
interface ListWorkflowsResponse {
    workflows: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateWorkflowRequestHeaders {
}
interface GetOrCreateWorkflowRequestQuery {
}
interface GetOrCreateWorkflowRequestParams {
}
interface GetOrCreateWorkflowRequestBody {
    /**
     * Name of the workflow
     */
    name: string;
    /**
     * Content related to the workflow
     */
    input?: {
        [k: string]: any;
    };
    /**
     * Parent workflow id is the parent workflow that created this workflow
     */
    parentWorkflowId?: string;
    /**
     * Conversation id related to this workflow
     */
    conversationId?: string;
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    status: "pending" | "in_progress" | "listening";
    /**
     * Event id must be specified if the workflow is created with the status in_progress
     */
    eventId?: string;
    /**
     * Optional list of tag names to use for strict matching when looking up existing workflows. If provided, all specified tags must match exactly for a workflow to be considered a match. For example, with an existing workflow whose tags are {"foo": "a", "bar": "b", baz: "c"}: Without this parameter, ALL tags must match exactly. With ["bar","baz"], all listed tags must match their values, and other tags are not considered.
     */
    discriminateByTags?: string[];
}
type GetOrCreateWorkflowInput = GetOrCreateWorkflowRequestBody & GetOrCreateWorkflowRequestHeaders & GetOrCreateWorkflowRequestQuery & GetOrCreateWorkflowRequestParams;
interface GetOrCreateWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface ListTagValuesRequestHeaders {
}
interface ListTagValuesRequestQuery {
    nextToken?: string;
    type: "user" | "conversation" | "message";
}
interface ListTagValuesRequestParams {
    key: string;
}
interface ListTagValuesRequestBody {
}
type ListTagValuesInput = ListTagValuesRequestBody & ListTagValuesRequestHeaders & ListTagValuesRequestQuery & ListTagValuesRequestParams;
interface ListTagValuesResponse {
    tags: {
        value: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface TrackAnalyticsRequestHeaders {
}
interface TrackAnalyticsRequestQuery {
}
interface TrackAnalyticsRequestParams {
}
interface TrackAnalyticsRequestBody {
    name: string;
    count: number;
}
type TrackAnalyticsInput = TrackAnalyticsRequestBody & TrackAnalyticsRequestHeaders & TrackAnalyticsRequestQuery & TrackAnalyticsRequestParams;
interface TrackAnalyticsResponse {
}

interface RunVrlRequestHeaders {
}
interface RunVrlRequestQuery {
}
interface RunVrlRequestParams {
}
interface RunVrlRequestBody {
    data: {
        [k: string]: any;
    };
    script: string;
}
type RunVrlInput = RunVrlRequestBody & RunVrlRequestHeaders & RunVrlRequestQuery & RunVrlRequestParams;
interface RunVrlResponse {
    data: {
        [k: string]: any;
    };
    result?: any;
}

interface GetAccountRequestHeaders {
}
interface GetAccountRequestQuery {
}
interface GetAccountRequestParams {
}
interface GetAccountRequestBody {
}
type GetAccountInput = GetAccountRequestBody & GetAccountRequestHeaders & GetAccountRequestQuery & GetAccountRequestParams;
interface GetAccountResponse {
    account: {
        id: string;
        email: string;
        displayName?: string;
        emailVerified: boolean;
        profilePicture?: string;
        /**
         * Creation date of the [Account](#schema_account) in ISO 8601 format
         */
        createdAt: string;
    };
}

interface UpdateAccountRequestHeaders {
}
interface UpdateAccountRequestQuery {
}
interface UpdateAccountRequestParams {
}
interface UpdateAccountRequestBody {
    displayName?: string;
    profilePicture?: string;
    refresh?: boolean;
}
type UpdateAccountInput = UpdateAccountRequestBody & UpdateAccountRequestHeaders & UpdateAccountRequestQuery & UpdateAccountRequestParams;
interface UpdateAccountResponse {
    account: {
        id: string;
        email: string;
        displayName?: string;
        emailVerified: boolean;
        profilePicture?: string;
        /**
         * Creation date of the [Account](#schema_account) in ISO 8601 format
         */
        createdAt: string;
    };
}

interface DeleteAccountRequestHeaders {
}
interface DeleteAccountRequestQuery {
}
interface DeleteAccountRequestParams {
}
interface DeleteAccountRequestBody {
}
type DeleteAccountInput = DeleteAccountRequestBody & DeleteAccountRequestHeaders & DeleteAccountRequestQuery & DeleteAccountRequestParams;
interface DeleteAccountResponse {
}

interface ListPersonalAccessTokensRequestHeaders {
}
interface ListPersonalAccessTokensRequestQuery {
}
interface ListPersonalAccessTokensRequestParams {
}
interface ListPersonalAccessTokensRequestBody {
}
type ListPersonalAccessTokensInput = ListPersonalAccessTokensRequestBody & ListPersonalAccessTokensRequestHeaders & ListPersonalAccessTokensRequestQuery & ListPersonalAccessTokensRequestParams;
interface ListPersonalAccessTokensResponse {
    pats: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreatePersonalAccessTokenRequestHeaders {
}
interface CreatePersonalAccessTokenRequestQuery {
}
interface CreatePersonalAccessTokenRequestParams {
}
interface CreatePersonalAccessTokenRequestBody {
    /**
     * Note to identify the PAT
     */
    note: string;
}
type CreatePersonalAccessTokenInput = CreatePersonalAccessTokenRequestBody & CreatePersonalAccessTokenRequestHeaders & CreatePersonalAccessTokenRequestQuery & CreatePersonalAccessTokenRequestParams;
interface CreatePersonalAccessTokenResponse {
    pat: {
        id: string;
        createdAt: string;
        note: string;
        /**
         * The PAT value. This will only be returned here when created and cannot be retrieved later.
         */
        value: string;
    };
}

interface DeletePersonalAccessTokenRequestHeaders {
}
interface DeletePersonalAccessTokenRequestQuery {
}
interface DeletePersonalAccessTokenRequestParams {
    id: string;
}
interface DeletePersonalAccessTokenRequestBody {
}
type DeletePersonalAccessTokenInput = DeletePersonalAccessTokenRequestBody & DeletePersonalAccessTokenRequestHeaders & DeletePersonalAccessTokenRequestQuery & DeletePersonalAccessTokenRequestParams;
interface DeletePersonalAccessTokenResponse {
}

interface SetAccountPreferenceRequestHeaders {
}
interface SetAccountPreferenceRequestQuery {
}
interface SetAccountPreferenceRequestParams {
    key: string;
}
interface SetAccountPreferenceRequestBody {
    value?: any;
}
type SetAccountPreferenceInput = SetAccountPreferenceRequestBody & SetAccountPreferenceRequestHeaders & SetAccountPreferenceRequestQuery & SetAccountPreferenceRequestParams;
interface SetAccountPreferenceResponse {
}

interface GetAccountPreferenceRequestHeaders {
}
interface GetAccountPreferenceRequestQuery {
}
interface GetAccountPreferenceRequestParams {
    key: string;
}
interface GetAccountPreferenceRequestBody {
}
type GetAccountPreferenceInput = GetAccountPreferenceRequestBody & GetAccountPreferenceRequestHeaders & GetAccountPreferenceRequestQuery & GetAccountPreferenceRequestParams;
interface GetAccountPreferenceResponse {
    value?: any;
}

interface ListPublicIntegrationsRequestHeaders {
}
interface ListPublicIntegrationsRequestQuery {
    nextToken?: string;
    limit?: number;
    name?: string;
    version?: string;
    interfaceId?: string;
    interfaceName?: string;
    installedByBotId?: string;
    verificationStatus?: "unapproved" | "pending" | "approved" | "rejected";
    search?: string;
    sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount";
    direction?: "asc" | "desc";
}
interface ListPublicIntegrationsRequestParams {
}
interface ListPublicIntegrationsRequestBody {
}
type ListPublicIntegrationsInput = ListPublicIntegrationsRequestBody & ListPublicIntegrationsRequestHeaders & ListPublicIntegrationsRequestQuery & ListPublicIntegrationsRequestParams;
interface ListPublicIntegrationsResponse {
    integrations: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
        meta: {
            installs: number;
            views: number;
        };
        /**
         * Metadata about which fields matched the search criteria
         */
        matchedOn?: {
            /**
             * Whether the integration name matched the search term
             */
            name?: boolean;
            /**
             * Whether the integration title matched the search term
             */
            title?: boolean;
            /**
             * Whether the integration description matched the search term
             */
            description?: boolean;
            /**
             * Action names that matched the search term
             */
            actions?: string[];
            /**
             * Interface names that matched the search term
             */
            interfaces?: string[];
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPublicIntegrationByIdRequestHeaders {
}
interface GetPublicIntegrationByIdRequestQuery {
}
interface GetPublicIntegrationByIdRequestParams {
    id: string;
}
interface GetPublicIntegrationByIdRequestBody {
}
type GetPublicIntegrationByIdInput = GetPublicIntegrationByIdRequestBody & GetPublicIntegrationByIdRequestHeaders & GetPublicIntegrationByIdRequestQuery & GetPublicIntegrationByIdRequestParams;
interface GetPublicIntegrationByIdResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
        meta: {
            installs: number;
            views: number;
        };
    };
}

interface GetPublicIntegrationRequestHeaders {
}
interface GetPublicIntegrationRequestQuery {
}
interface GetPublicIntegrationRequestParams {
    name: string;
    version: string;
}
interface GetPublicIntegrationRequestBody {
}
type GetPublicIntegrationInput = GetPublicIntegrationRequestBody & GetPublicIntegrationRequestHeaders & GetPublicIntegrationRequestQuery & GetPublicIntegrationRequestParams;
interface GetPublicIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
        meta: {
            installs: number;
            views: number;
        };
    };
}

interface ListPublicPluginsRequestHeaders {
}
interface ListPublicPluginsRequestQuery {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListPublicPluginsRequestParams {
}
interface ListPublicPluginsRequestBody {
}
type ListPublicPluginsInput = ListPublicPluginsRequestBody & ListPublicPluginsRequestHeaders & ListPublicPluginsRequestQuery & ListPublicPluginsRequestParams;
interface ListPublicPluginsResponse {
    plugins: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPublicPluginByIdRequestHeaders {
}
interface GetPublicPluginByIdRequestQuery {
}
interface GetPublicPluginByIdRequestParams {
    id: string;
}
interface GetPublicPluginByIdRequestBody {
}
type GetPublicPluginByIdInput = GetPublicPluginByIdRequestBody & GetPublicPluginByIdRequestHeaders & GetPublicPluginByIdRequestQuery & GetPublicPluginByIdRequestParams;
interface GetPublicPluginByIdResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetDereferencedPublicPluginByIdRequestHeaders {
}
interface GetDereferencedPublicPluginByIdRequestQuery {
    /**
     * Mapping of interface aliases to integration IDs
     */
    interfaces: {
        /**
         * integration id
         */
        [k: string]: string;
    };
}
interface GetDereferencedPublicPluginByIdRequestParams {
    id: string;
}
interface GetDereferencedPublicPluginByIdRequestBody {
}
type GetDereferencedPublicPluginByIdInput = GetDereferencedPublicPluginByIdRequestBody & GetDereferencedPublicPluginByIdRequestHeaders & GetDereferencedPublicPluginByIdRequestQuery & GetDereferencedPublicPluginByIdRequestParams;
interface GetDereferencedPublicPluginByIdResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPublicPluginRequestHeaders {
}
interface GetPublicPluginRequestQuery {
}
interface GetPublicPluginRequestParams {
    name: string;
    version: string;
}
interface GetPublicPluginRequestBody {
}
type GetPublicPluginInput = GetPublicPluginRequestBody & GetPublicPluginRequestHeaders & GetPublicPluginRequestQuery & GetPublicPluginRequestParams;
interface GetPublicPluginResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPublicPluginCodeRequestHeaders {
}
interface GetPublicPluginCodeRequestQuery {
}
interface GetPublicPluginCodeRequestParams {
    id: string;
    platform: "node" | "browser";
}
interface GetPublicPluginCodeRequestBody {
}
type GetPublicPluginCodeInput = GetPublicPluginCodeRequestBody & GetPublicPluginCodeRequestHeaders & GetPublicPluginCodeRequestQuery & GetPublicPluginCodeRequestParams;
interface GetPublicPluginCodeResponse {
    code: string;
}

interface ListPublicInterfacesRequestHeaders {
}
interface ListPublicInterfacesRequestQuery {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListPublicInterfacesRequestParams {
}
interface ListPublicInterfacesRequestBody {
}
type ListPublicInterfacesInput = ListPublicInterfacesRequestBody & ListPublicInterfacesRequestHeaders & ListPublicInterfacesRequestQuery & ListPublicInterfacesRequestParams;
interface ListPublicInterfacesResponse {
    interfaces: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPublicInterfaceByIdRequestHeaders {
}
interface GetPublicInterfaceByIdRequestQuery {
}
interface GetPublicInterfaceByIdRequestParams {
    id: string;
}
interface GetPublicInterfaceByIdRequestBody {
}
type GetPublicInterfaceByIdInput = GetPublicInterfaceByIdRequestBody & GetPublicInterfaceByIdRequestHeaders & GetPublicInterfaceByIdRequestQuery & GetPublicInterfaceByIdRequestParams;
interface GetPublicInterfaceByIdResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPublicInterfaceRequestHeaders {
}
interface GetPublicInterfaceRequestQuery {
}
interface GetPublicInterfaceRequestParams {
    name: string;
    version: string;
}
interface GetPublicInterfaceRequestBody {
}
type GetPublicInterfaceInput = GetPublicInterfaceRequestBody & GetPublicInterfaceRequestHeaders & GetPublicInterfaceRequestQuery & GetPublicInterfaceRequestParams;
interface GetPublicInterfaceResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface CreateBotRequestHeaders {
}
interface CreateBotRequestQuery {
}
interface CreateBotRequestParams {
}
interface CreateBotRequestBody {
    /**
     * A mapping of states to their definition
     */
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    /**
     * Events definition
     */
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    recurringEvents?: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
        };
    };
    /**
     * Subscriptions of the bot
     */
    subscriptions?: {
        /**
         * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
         */
        events: {
            [k: string]: {};
        } | null;
    };
    /**
     * Actions definition
     */
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    configuration?: {
        /**
         * Configuration data
         */
        data?: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
    };
    user?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    conversation?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    message?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Optional attributes of the [Bot](#schema_bot)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * JavaScript code of the bot
     */
    code?: string;
    /**
     * Optional name for the bot, if not provided will be auto-generated
     */
    name?: string;
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias?: {
        url: string;
        name: string;
    }[];
    /**
     * URL of the [Bot](#schema_bot); Only available for dev bots
     */
    url?: string;
    /**
     * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
     */
    dev?: boolean;
}
type CreateBotInput = CreateBotRequestBody & CreateBotRequestHeaders & CreateBotRequestQuery & CreateBotRequestParams;
interface CreateBotResponse {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration. If the `x-multiple-integrations` header is present, this object is keyed by integration aliases. Otherwise, this object is keyed by integration ids.
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * Disabled channels for this integration
                 */
                disabledChannels: string[];
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * @deprecated
                 * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
                 */
                public: boolean;
                /**
                 * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
                 */
                visibility: "public" | "private" | "unlisted";
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * A mapping of plugin aliases to their configuration
         */
        plugins: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Plugin](#schema_plugin)
                 */
                name: string;
                /**
                 * Version of the [Plugin](#schema_plugin)
                 */
                version: string;
                configuration: {
                    [k: string]: any;
                };
                /**
                 * A mapping of plugin interface aliases to their backing integrations
                 */
                interfaces?: {
                    [k: string]: {
                        integrationId: string;
                        interfaceId: string;
                    };
                };
                /**
                 * ID of the [Plugin](#schema_plugin)
                 */
                id: string;
                /**
                 * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the plugin. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the plugin. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the plugin. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * URL of the readme of the plugin. This is the readme that will be displayed in the UI
                 */
                readmeUrl: string;
                /**
                 * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
            };
        };
        /**
         * Maximum execution time of the bot (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface UpdateBotRequestHeaders {
}
interface UpdateBotRequestQuery {
}
interface UpdateBotRequestParams {
    id: string;
}
interface UpdateBotRequestBody {
    /**
     * URL of the [Bot](#schema_bot); Only available for dev bots
     */
    url?: string;
    /**
     * Type of the [Bot](#schema_bot) authentication (`iam`)
     */
    authentication?: "iam";
    configuration?: {
        /**
         * Configuration data
         */
        data?: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
    };
    /**
     * Optional attributes of the [Bot](#schema_bot)
     */
    tags?: {
        [k: string]: string;
    };
    blocked?: boolean;
    /**
     * Maximum execution time (in seconds).
     */
    maxExecutionTime?: number;
    /**
     * Indicates if the [Bot](#schema_bot) should be in always alive mode
     */
    alwaysAlive?: boolean;
    user?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    message?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    conversation?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        } | null;
    };
    recurringEvents?: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
        } | null;
    };
    integrations?: {
        [k: string]: {
            enabled?: boolean;
            /**
             * Integration's definition ID. If defined, the record's key is treated as an alias for the integration instance.
             */
            integrationId?: string;
            /**
             * Integration's configuration type. Set to default if null.
             */
            configurationType?: string | null;
            configuration?: {
                [k: string]: any;
            };
            /**
             * Disabled channels for this integration
             */
            disabledChannels?: string[];
        } | null;
    };
    /**
     * A mapping of plugin aliases to their configuration
     */
    plugins?: {
        [k: string]: {
            id: string;
            enabled?: boolean;
            configuration?: {
                [k: string]: any;
            };
            /**
             * A mapping of plugin interface aliases to their backing integrations
             */
            interfaces?: {
                [k: string]: {
                    integrationId: string;
                };
            };
        } | null;
    };
    subscriptions?: {
        events: {
            [k: string]: {} | null;
        } | null;
    };
    /**
     * JavaScript code of the bot
     */
    code?: string;
    /**
     * Optional name for the bot, if not provided will be auto-generated
     */
    name?: string;
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias?: {
        url: string;
        name: string;
    }[];
    layers?: string[];
    /**
     * UNUSED. Please ignore this field. It will be removed in the near future.
     */
    shouldMergePlugins?: boolean;
}
type UpdateBotInput = UpdateBotRequestBody & UpdateBotRequestHeaders & UpdateBotRequestQuery & UpdateBotRequestParams;
interface UpdateBotResponse {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration. If the `x-multiple-integrations` header is present, this object is keyed by integration aliases. Otherwise, this object is keyed by integration ids.
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * Disabled channels for this integration
                 */
                disabledChannels: string[];
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * @deprecated
                 * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
                 */
                public: boolean;
                /**
                 * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
                 */
                visibility: "public" | "private" | "unlisted";
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * A mapping of plugin aliases to their configuration
         */
        plugins: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Plugin](#schema_plugin)
                 */
                name: string;
                /**
                 * Version of the [Plugin](#schema_plugin)
                 */
                version: string;
                configuration: {
                    [k: string]: any;
                };
                /**
                 * A mapping of plugin interface aliases to their backing integrations
                 */
                interfaces?: {
                    [k: string]: {
                        integrationId: string;
                        interfaceId: string;
                    };
                };
                /**
                 * ID of the [Plugin](#schema_plugin)
                 */
                id: string;
                /**
                 * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the plugin. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the plugin. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the plugin. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * URL of the readme of the plugin. This is the readme that will be displayed in the UI
                 */
                readmeUrl: string;
                /**
                 * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
            };
        };
        /**
         * Maximum execution time of the bot (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface TransferBotRequestHeaders {
}
interface TransferBotRequestQuery {
}
interface TransferBotRequestParams {
    id: string;
}
interface TransferBotRequestBody {
    /**
     * The ID of the workspace you want to transfer the bot to.
     */
    targetWorkspaceId: string;
}
type TransferBotInput = TransferBotRequestBody & TransferBotRequestHeaders & TransferBotRequestQuery & TransferBotRequestParams;
interface TransferBotResponse {
}

interface ListBotsRequestHeaders {
}
interface ListBotsRequestQuery {
    dev?: boolean;
    tags?: {
        [k: string]: string;
    };
    nextToken?: string;
    sortField?: "createdAt" | "updatedAt";
    sortDirection?: "asc" | "desc";
}
interface ListBotsRequestParams {
}
interface ListBotsRequestBody {
}
type ListBotsInput = ListBotsRequestBody & ListBotsRequestHeaders & ListBotsRequestQuery & ListBotsRequestParams;
interface ListBotsResponse {
    bots: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        name: string;
        deployedAt?: string;
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetBotRequestHeaders {
}
interface GetBotRequestQuery {
    shouldMergePlugins?: boolean;
}
interface GetBotRequestParams {
    id: string;
}
interface GetBotRequestBody {
}
type GetBotInput = GetBotRequestBody & GetBotRequestHeaders & GetBotRequestQuery & GetBotRequestParams;
interface GetBotResponse {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration. If the `x-multiple-integrations` header is present, this object is keyed by integration aliases. Otherwise, this object is keyed by integration ids.
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * Disabled channels for this integration
                 */
                disabledChannels: string[];
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * @deprecated
                 * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
                 */
                public: boolean;
                /**
                 * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
                 */
                visibility: "public" | "private" | "unlisted";
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * A mapping of plugin aliases to their configuration
         */
        plugins: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Plugin](#schema_plugin)
                 */
                name: string;
                /**
                 * Version of the [Plugin](#schema_plugin)
                 */
                version: string;
                configuration: {
                    [k: string]: any;
                };
                /**
                 * A mapping of plugin interface aliases to their backing integrations
                 */
                interfaces?: {
                    [k: string]: {
                        integrationId: string;
                        interfaceId: string;
                    };
                };
                /**
                 * ID of the [Plugin](#schema_plugin)
                 */
                id: string;
                /**
                 * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the plugin. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the plugin. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the plugin. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * URL of the readme of the plugin. This is the readme that will be displayed in the UI
                 */
                readmeUrl: string;
                /**
                 * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
            };
        };
        /**
         * Maximum execution time of the bot (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * Tags of [Bot](#schema_bot)
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface DeleteBotRequestHeaders {
}
interface DeleteBotRequestQuery {
}
interface DeleteBotRequestParams {
    id: string;
}
interface DeleteBotRequestBody {
}
type DeleteBotInput = DeleteBotRequestBody & DeleteBotRequestHeaders & DeleteBotRequestQuery & DeleteBotRequestParams;
interface DeleteBotResponse {
}

interface GetBotLogsRequestHeaders {
}
interface GetBotLogsRequestQuery {
    timeStart: string;
    timeEnd?: string;
    level?: string;
    userId?: string;
    workflowId?: string;
    conversationId?: string;
    messageContains?: string;
    nextToken?: string;
}
interface GetBotLogsRequestParams {
    id: string;
}
interface GetBotLogsRequestBody {
}
type GetBotLogsInput = GetBotLogsRequestBody & GetBotLogsRequestHeaders & GetBotLogsRequestQuery & GetBotLogsRequestParams;
interface GetBotLogsResponse {
    logs: {
        timestamp: string;
        level: string;
        message: string;
        workflowId?: string;
        userId?: string;
        conversationId?: string;
    }[];
    nextToken?: string;
}

interface GetBotWebchatRequestHeaders {
}
interface GetBotWebchatRequestQuery {
    type: "preconfigured" | "configurable" | "fullscreen" | "sharableUrl";
}
interface GetBotWebchatRequestParams {
    id: string;
}
interface GetBotWebchatRequestBody {
}
type GetBotWebchatInput = GetBotWebchatRequestBody & GetBotWebchatRequestHeaders & GetBotWebchatRequestQuery & GetBotWebchatRequestParams;
interface GetBotWebchatResponse {
    code: string;
}

interface GetBotAnalyticsRequestHeaders {
}
interface GetBotAnalyticsRequestQuery {
    startDate: string;
    endDate: string;
}
interface GetBotAnalyticsRequestParams {
    id: string;
}
interface GetBotAnalyticsRequestBody {
}
type GetBotAnalyticsInput = GetBotAnalyticsRequestBody & GetBotAnalyticsRequestHeaders & GetBotAnalyticsRequestQuery & GetBotAnalyticsRequestParams;
interface GetBotAnalyticsResponse {
    records: {
        /**
         * ISO 8601 date string of the beginning (inclusive) of the period
         */
        startDateTimeUtc: string;
        /**
         * ISO 8601 date string of the end (inclusive) of the period
         */
        endDateTimeUtc: string;
        returningUsers: number;
        newUsers: number;
        sessions: number;
        /**
         * Deprecated. Use `userMessages` instead.
         */
        messages: number;
        userMessages: number;
        botMessages: number;
        events: number;
        eventTypes: {
            [k: string]: number;
        };
        customEvents: {
            [k: string]: number;
        };
        llm: {
            calls: number;
            errors: number;
            inputTokens: number;
            outputTokens: number;
            /**
             * The time it took for the LLM to complete its response. Values are expressed in milliseconds
             */
            latency: {
                mean: number;
                sd: number;
                min: number;
                max: number;
            };
            /**
             * LLM response generation speed expressed in output tokens per second.
             */
            tokensPerSecond: {
                mean: number;
                sd: number;
                min: number;
                max: number;
            };
            /**
             * Values are expressed in U.S. dollars
             */
            cost: {
                sum: number;
                mean: number;
                sd: number;
                min: number;
                max: number;
            };
        };
    }[];
}

interface ListActionRunsRequestHeaders {
}
interface ListActionRunsRequestQuery {
    integrationName: string;
    timestampFrom?: string;
    timestampUntil?: string;
    nextToken?: string;
}
interface ListActionRunsRequestParams {
    id: string;
}
interface ListActionRunsRequestBody {
}
type ListActionRunsInput = ListActionRunsRequestBody & ListActionRunsRequestHeaders & ListActionRunsRequestQuery & ListActionRunsRequestParams;
interface ListActionRunsResponse {
    data: {
        /**
         * ISO 8601 timestamp of the action run
         */
        timestamp: string;
        integrationName?: string;
        actionType: string;
        /**
         * Input of the action
         */
        input: {
            [k: string]: any;
        };
        /**
         * Output of the action
         */
        output: {
            [k: string]: any;
        } | null;
        status: "SUCCESS" | "FAILURE";
        durationMs: number;
        cached: boolean;
        errorMessage?: string | null;
    }[];
    meta: {
        nextToken?: string;
    };
}

interface GetBotIssueRequestHeaders {
}
interface GetBotIssueRequestQuery {
}
interface GetBotIssueRequestParams {
    id: string;
    issueId: string;
}
interface GetBotIssueRequestBody {
}
type GetBotIssueInput = GetBotIssueRequestBody & GetBotIssueRequestHeaders & GetBotIssueRequestQuery & GetBotIssueRequestParams;
interface GetBotIssueResponse {
    issue: {
        id: string;
        code: string;
        createdAt: string;
        lastSeenAt: string;
        title: string;
        description: string;
        groupedData: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
        eventsCount: number;
        category: "user_code" | "limits" | "configuration" | "other";
        resolutionLink: string | null;
    };
}

interface ListBotIssuesRequestHeaders {
}
interface ListBotIssuesRequestQuery {
    nextToken?: string;
}
interface ListBotIssuesRequestParams {
    id: string;
}
interface ListBotIssuesRequestBody {
}
type ListBotIssuesInput = ListBotIssuesRequestBody & ListBotIssuesRequestHeaders & ListBotIssuesRequestQuery & ListBotIssuesRequestParams;
interface ListBotIssuesResponse {
    issues: {
        id: string;
        code: string;
        createdAt: string;
        lastSeenAt: string;
        title: string;
        description: string;
        groupedData: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
        eventsCount: number;
        category: "user_code" | "limits" | "configuration" | "other";
        resolutionLink: string | null;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface DeleteBotIssueRequestHeaders {
}
interface DeleteBotIssueRequestQuery {
}
interface DeleteBotIssueRequestParams {
    id: string;
    issueId: string;
}
interface DeleteBotIssueRequestBody {
}
type DeleteBotIssueInput = DeleteBotIssueRequestBody & DeleteBotIssueRequestHeaders & DeleteBotIssueRequestQuery & DeleteBotIssueRequestParams;
interface DeleteBotIssueResponse {
}

interface ListBotIssueEventsRequestHeaders {
}
interface ListBotIssueEventsRequestQuery {
}
interface ListBotIssueEventsRequestParams {
    id: string;
    issueId: string;
}
interface ListBotIssueEventsRequestBody {
}
type ListBotIssueEventsInput = ListBotIssueEventsRequestBody & ListBotIssueEventsRequestHeaders & ListBotIssueEventsRequestQuery & ListBotIssueEventsRequestParams;
interface ListBotIssueEventsResponse {
    issueEvents: {
        id: string;
        createdAt: string;
        data: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
    }[];
}

interface ListBotVersionsRequestHeaders {
}
interface ListBotVersionsRequestQuery {
}
interface ListBotVersionsRequestParams {
    id: string;
}
interface ListBotVersionsRequestBody {
}
type ListBotVersionsInput = ListBotVersionsRequestBody & ListBotVersionsRequestHeaders & ListBotVersionsRequestQuery & ListBotVersionsRequestParams;
interface ListBotVersionsResponse {
    versions: {
        id: string;
        name: string;
        description?: string;
    }[];
}

interface GetBotVersionRequestHeaders {
}
interface GetBotVersionRequestQuery {
}
interface GetBotVersionRequestParams {
    id: string;
    versionId: string;
}
interface GetBotVersionRequestBody {
}
type GetBotVersionInput = GetBotVersionRequestBody & GetBotVersionRequestHeaders & GetBotVersionRequestQuery & GetBotVersionRequestParams;
interface GetBotVersionResponse {
    url: string;
}

interface GetBotJsonRequestHeaders {
}
interface GetBotJsonRequestQuery {
}
interface GetBotJsonRequestParams {
    id: string;
}
interface GetBotJsonRequestBody {
}
type GetBotJsonInput = GetBotJsonRequestBody & GetBotJsonRequestHeaders & GetBotJsonRequestQuery & GetBotJsonRequestParams;
interface GetBotJsonResponse {
    [k: string]: any;
}

interface PublishFromBotJsonRequestHeaders {
}
interface PublishFromBotJsonRequestQuery {
}
interface PublishFromBotJsonRequestParams {
    id: string;
}
interface PublishFromBotJsonRequestBody {
    botJson: {
        [k: string]: any;
    };
}
type PublishFromBotJsonInput = PublishFromBotJsonRequestBody & PublishFromBotJsonRequestHeaders & PublishFromBotJsonRequestQuery & PublishFromBotJsonRequestParams;
interface PublishFromBotJsonResponse {
    [k: string]: any;
}

interface CreateBotVersionRequestHeaders {
}
interface CreateBotVersionRequestQuery {
}
interface CreateBotVersionRequestParams {
    id: string;
}
interface CreateBotVersionRequestBody {
    name: string;
    description?: string;
}
type CreateBotVersionInput = CreateBotVersionRequestBody & CreateBotVersionRequestHeaders & CreateBotVersionRequestQuery & CreateBotVersionRequestParams;
interface CreateBotVersionResponse {
    version: {
        id: string;
        name: string;
        description?: string;
    };
}

interface DeployBotVersionRequestHeaders {
}
interface DeployBotVersionRequestQuery {
}
interface DeployBotVersionRequestParams {
    id: string;
}
interface DeployBotVersionRequestBody {
    versionId: string;
}
type DeployBotVersionInput = DeployBotVersionRequestBody & DeployBotVersionRequestHeaders & DeployBotVersionRequestQuery & DeployBotVersionRequestParams;
interface DeployBotVersionResponse {
}

interface CreateIntegrationShareableIdRequestHeaders {
}
interface CreateIntegrationShareableIdRequestQuery {
}
interface CreateIntegrationShareableIdRequestParams {
    botId: string;
    integrationId: string;
}
interface CreateIntegrationShareableIdRequestBody {
}
type CreateIntegrationShareableIdInput = CreateIntegrationShareableIdRequestBody & CreateIntegrationShareableIdRequestHeaders & CreateIntegrationShareableIdRequestQuery & CreateIntegrationShareableIdRequestParams;
interface CreateIntegrationShareableIdResponse {
    shareableId: string;
}

interface DeleteIntegrationShareableIdRequestHeaders {
}
interface DeleteIntegrationShareableIdRequestQuery {
}
interface DeleteIntegrationShareableIdRequestParams {
    botId: string;
    integrationId: string;
}
interface DeleteIntegrationShareableIdRequestBody {
}
type DeleteIntegrationShareableIdInput = DeleteIntegrationShareableIdRequestBody & DeleteIntegrationShareableIdRequestHeaders & DeleteIntegrationShareableIdRequestQuery & DeleteIntegrationShareableIdRequestParams;
interface DeleteIntegrationShareableIdResponse {
}

interface GetIntegrationShareableIdRequestHeaders {
}
interface GetIntegrationShareableIdRequestQuery {
}
interface GetIntegrationShareableIdRequestParams {
    botId: string;
    integrationId: string;
}
interface GetIntegrationShareableIdRequestBody {
}
type GetIntegrationShareableIdInput = GetIntegrationShareableIdRequestBody & GetIntegrationShareableIdRequestHeaders & GetIntegrationShareableIdRequestQuery & GetIntegrationShareableIdRequestParams;
interface GetIntegrationShareableIdResponse {
    shareableId: string;
    isExpired: boolean;
}

interface UnlinkSandboxedConversationsRequestHeaders {
}
interface UnlinkSandboxedConversationsRequestQuery {
}
interface UnlinkSandboxedConversationsRequestParams {
    botId: string;
    integrationId: string;
}
interface UnlinkSandboxedConversationsRequestBody {
}
type UnlinkSandboxedConversationsInput = UnlinkSandboxedConversationsRequestBody & UnlinkSandboxedConversationsRequestHeaders & UnlinkSandboxedConversationsRequestQuery & UnlinkSandboxedConversationsRequestParams;
interface UnlinkSandboxedConversationsResponse {
}

interface ListBotApiKeysRequestHeaders {
}
interface ListBotApiKeysRequestQuery {
    botId: string;
}
interface ListBotApiKeysRequestParams {
}
interface ListBotApiKeysRequestBody {
}
type ListBotApiKeysInput = ListBotApiKeysRequestBody & ListBotApiKeysRequestHeaders & ListBotApiKeysRequestQuery & ListBotApiKeysRequestParams;
interface ListBotApiKeysResponse {
    baks: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreateBotApiKeyRequestHeaders {
}
interface CreateBotApiKeyRequestQuery {
}
interface CreateBotApiKeyRequestParams {
}
interface CreateBotApiKeyRequestBody {
    botId: string;
    note?: string;
}
type CreateBotApiKeyInput = CreateBotApiKeyRequestBody & CreateBotApiKeyRequestHeaders & CreateBotApiKeyRequestQuery & CreateBotApiKeyRequestParams;
interface CreateBotApiKeyResponse {
    id: string;
    createdAt: string;
    note: string;
    /**
     * The BAK value. This will only be returned here when created and cannot be retrieved later.
     */
    value: string;
}

interface DeleteBotApiKeyRequestHeaders {
}
interface DeleteBotApiKeyRequestQuery {
}
interface DeleteBotApiKeyRequestParams {
    id: string;
}
interface DeleteBotApiKeyRequestBody {
}
type DeleteBotApiKeyInput = DeleteBotApiKeyRequestBody & DeleteBotApiKeyRequestHeaders & DeleteBotApiKeyRequestQuery & DeleteBotApiKeyRequestParams;
interface DeleteBotApiKeyResponse {
}

interface GetBotAllowlistRequestHeaders {
}
interface GetBotAllowlistRequestQuery {
}
interface GetBotAllowlistRequestParams {
    botId: string;
}
interface GetBotAllowlistRequestBody {
}
type GetBotAllowlistInput = GetBotAllowlistRequestBody & GetBotAllowlistRequestHeaders & GetBotAllowlistRequestQuery & GetBotAllowlistRequestParams;
interface GetBotAllowlistResponse {
    /**
     * Allowlist setting of the bot
     */
    setting: "ALL_WORKSPACE_USERS" | "SELECTED_USERS";
    users: {
        id: string;
    }[];
}

interface UpdateBotAllowlistRequestHeaders {
}
interface UpdateBotAllowlistRequestQuery {
}
interface UpdateBotAllowlistRequestParams {
    botId: string;
}
interface UpdateBotAllowlistRequestBody {
    /**
     * Allowlist setting of the bot
     */
    setting?: "ALL_WORKSPACE_USERS" | "SELECTED_USERS";
    users?: {
        /**
         * If `true`, the user should be added to the allowlist. If `false`, the user should be removed from the allowlist. This performs a partial update, so any existing users not included here will be kept in the allowlist
         */
        [k: string]: boolean;
    };
}
type UpdateBotAllowlistInput = UpdateBotAllowlistRequestBody & UpdateBotAllowlistRequestHeaders & UpdateBotAllowlistRequestQuery & UpdateBotAllowlistRequestParams;
interface UpdateBotAllowlistResponse {
}

interface ListWorkspaceInvoicesRequestHeaders {
}
interface ListWorkspaceInvoicesRequestQuery {
}
interface ListWorkspaceInvoicesRequestParams {
    id: string;
}
interface ListWorkspaceInvoicesRequestBody {
}
type ListWorkspaceInvoicesInput = ListWorkspaceInvoicesRequestBody & ListWorkspaceInvoicesRequestHeaders & ListWorkspaceInvoicesRequestQuery & ListWorkspaceInvoicesRequestParams;
interface ListWorkspaceInvoicesResponse {
    invoices: {
        id: string;
        period: {
            month: number;
            year: number;
        };
        /**
         * Date on which the invoice was generated.
         */
        date: string;
        /**
         * Total amount to pay of the invoice.
         */
        amount: number;
        /**
         * Currency of the invoice amount.
         */
        currency: string;
        paymentStatus: ("deleted" | "draft" | "open" | "paid" | "uncollectible" | "void") | null;
        /**
         * Date on which the invoice is due.
         */
        dueDate?: string;
        /**
         * Number of times payment has been unsuccessfully attempted on the invoice.
         */
        paymentAttemptCount: number | null;
        /**
         * Date on which the next payment attempt will be made.
         */
        nextPaymentAttemptDate: string | null;
        /**
         * URL to download the PDF file of the invoice.
         */
        pdfUrl: string;
    }[];
}

interface GetUpcomingInvoiceRequestHeaders {
}
interface GetUpcomingInvoiceRequestQuery {
}
interface GetUpcomingInvoiceRequestParams {
    id: string;
}
interface GetUpcomingInvoiceRequestBody {
}
type GetUpcomingInvoiceInput = GetUpcomingInvoiceRequestBody & GetUpcomingInvoiceRequestHeaders & GetUpcomingInvoiceRequestQuery & GetUpcomingInvoiceRequestParams;
interface GetUpcomingInvoiceResponse {
    /**
     * Total amount to pay of the invoice.
     */
    total: number;
    /**
     * List of items included in the invoice.
     */
    lineItems: {
        id: string;
        /**
         * Description of the line item.
         */
        description: string;
        /**
         * Total amount to pay (in cents) of the line item.
         */
        totalInCents: number;
        /**
         * Three-letter ISO currency code, in lowercase.
         */
        currency: string;
        /**
         * Price per unit (in cents) of the line item.
         */
        pricePerUnitInCents: number | null;
        /**
         * The quantity of the subscription, if the line item is a subscription or a proration.
         */
        quantity: number | null;
        /**
         * Type of the line item.
         */
        type: "invoiceitem" | "subscription";
        /**
         * Start date of the line item period.
         */
        periodStart: string | null;
        /**
         * End date of the line item period.
         */
        periodEnd: string | null;
    }[];
}

interface ChargeWorkspaceUnpaidInvoicesRequestHeaders {
}
interface ChargeWorkspaceUnpaidInvoicesRequestQuery {
}
interface ChargeWorkspaceUnpaidInvoicesRequestParams {
    id: string;
}
interface ChargeWorkspaceUnpaidInvoicesRequestBody {
    /**
     * @minItems 1
     */
    invoiceIds?: string[];
}
type ChargeWorkspaceUnpaidInvoicesInput = ChargeWorkspaceUnpaidInvoicesRequestBody & ChargeWorkspaceUnpaidInvoicesRequestHeaders & ChargeWorkspaceUnpaidInvoicesRequestQuery & ChargeWorkspaceUnpaidInvoicesRequestParams;
interface ChargeWorkspaceUnpaidInvoicesResponse {
    /**
     * Invoices that were successfully charged by this request.
     */
    chargedInvoices: {
        id: string;
        amount: number;
    }[];
    /**
     * Invoices that failed to be charged by this request.
     */
    failedInvoices: {
        id: string;
        amount: number;
        failedReason: string;
    }[];
}

interface CreateWorkspaceRequestHeaders {
}
interface CreateWorkspaceRequestQuery {
}
interface CreateWorkspaceRequestParams {
}
interface CreateWorkspaceRequestBody {
    name: string;
}
type CreateWorkspaceInput = CreateWorkspaceRequestBody & CreateWorkspaceRequestHeaders & CreateWorkspaceRequestQuery & CreateWorkspaceRequestParams;
interface CreateWorkspaceResponse {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface GetPublicWorkspaceRequestHeaders {
}
interface GetPublicWorkspaceRequestQuery {
}
interface GetPublicWorkspaceRequestParams {
    id: string;
}
interface GetPublicWorkspaceRequestBody {
}
type GetPublicWorkspaceInput = GetPublicWorkspaceRequestBody & GetPublicWorkspaceRequestHeaders & GetPublicWorkspaceRequestQuery & GetPublicWorkspaceRequestParams;
interface GetPublicWorkspaceResponse$1 {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    handle?: string;
}

interface GetWorkspaceRequestHeaders {
}
interface GetWorkspaceRequestQuery {
}
interface GetWorkspaceRequestParams {
    id: string;
}
interface GetWorkspaceRequestBody {
}
type GetWorkspaceInput = GetWorkspaceRequestBody & GetWorkspaceRequestHeaders & GetWorkspaceRequestQuery & GetWorkspaceRequestParams;
interface GetWorkspaceResponse {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface ListWorkspaceUsagesRequestHeaders {
}
interface ListWorkspaceUsagesRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface ListWorkspaceUsagesRequestParams {
    id: string;
}
interface ListWorkspaceUsagesRequestBody {
}
type ListWorkspaceUsagesInput = ListWorkspaceUsagesRequestBody & ListWorkspaceUsagesRequestHeaders & ListWorkspaceUsagesRequestQuery & ListWorkspaceUsagesRequestParams;
interface ListWorkspaceUsagesResponse {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface BreakDownWorkspaceUsageByBotRequestHeaders {
}
interface BreakDownWorkspaceUsageByBotRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface BreakDownWorkspaceUsageByBotRequestParams {
    id: string;
}
interface BreakDownWorkspaceUsageByBotRequestBody {
}
type BreakDownWorkspaceUsageByBotInput = BreakDownWorkspaceUsageByBotRequestBody & BreakDownWorkspaceUsageByBotRequestHeaders & BreakDownWorkspaceUsageByBotRequestQuery & BreakDownWorkspaceUsageByBotRequestParams;
interface BreakDownWorkspaceUsageByBotResponse {
    data: {
        botId: string;
        value: number;
    }[];
}

interface GetAllWorkspaceQuotaCompletionRequestHeaders {
}
interface GetAllWorkspaceQuotaCompletionRequestQuery {
}
interface GetAllWorkspaceQuotaCompletionRequestParams {
}
interface GetAllWorkspaceQuotaCompletionRequestBody {
}
type GetAllWorkspaceQuotaCompletionInput = GetAllWorkspaceQuotaCompletionRequestBody & GetAllWorkspaceQuotaCompletionRequestHeaders & GetAllWorkspaceQuotaCompletionRequestQuery & GetAllWorkspaceQuotaCompletionRequestParams;
interface GetAllWorkspaceQuotaCompletionResponse {
    [k: string]: {
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
        completion: number;
    };
}

interface GetWorkspaceQuotaRequestHeaders {
}
interface GetWorkspaceQuotaRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface GetWorkspaceQuotaRequestParams {
    id: string;
}
interface GetWorkspaceQuotaRequestBody {
}
type GetWorkspaceQuotaInput = GetWorkspaceQuotaRequestBody & GetWorkspaceQuotaRequestHeaders & GetWorkspaceQuotaRequestQuery & GetWorkspaceQuotaRequestParams;
interface GetWorkspaceQuotaResponse {
    quota: {
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the quota that is used
         */
        value: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    };
}

interface ListWorkspaceQuotasRequestHeaders {
}
interface ListWorkspaceQuotasRequestQuery {
    period?: string;
}
interface ListWorkspaceQuotasRequestParams {
    id: string;
}
interface ListWorkspaceQuotasRequestBody {
}
type ListWorkspaceQuotasInput = ListWorkspaceQuotasRequestBody & ListWorkspaceQuotasRequestHeaders & ListWorkspaceQuotasRequestQuery & ListWorkspaceQuotasRequestParams;
interface ListWorkspaceQuotasResponse {
    quotas: {
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the quota that is used
         */
        value: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface UpdateWorkspaceRequestHeaders {
}
interface UpdateWorkspaceRequestQuery {
}
interface UpdateWorkspaceRequestParams {
    id: string;
}
interface UpdateWorkspaceRequestBody {
    name?: string;
    spendingLimit?: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    /**
     * @maxItems 5
     */
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}
type UpdateWorkspaceInput = UpdateWorkspaceRequestBody & UpdateWorkspaceRequestHeaders & UpdateWorkspaceRequestQuery & UpdateWorkspaceRequestParams;
interface UpdateWorkspaceResponse$1 {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface CheckHandleAvailabilityRequestHeaders {
}
interface CheckHandleAvailabilityRequestQuery {
}
interface CheckHandleAvailabilityRequestParams {
}
interface CheckHandleAvailabilityRequestBody {
    handle: string;
}
type CheckHandleAvailabilityInput = CheckHandleAvailabilityRequestBody & CheckHandleAvailabilityRequestHeaders & CheckHandleAvailabilityRequestQuery & CheckHandleAvailabilityRequestParams;
interface CheckHandleAvailabilityResponse {
    available: boolean;
    suggestions: string[];
    usedBy?: string;
}

interface ListWorkspacesRequestHeaders {
}
interface ListWorkspacesRequestQuery {
    nextToken?: string;
    handle?: string;
}
interface ListWorkspacesRequestParams {
}
interface ListWorkspacesRequestBody {
}
type ListWorkspacesInput = ListWorkspacesRequestBody & ListWorkspacesRequestHeaders & ListWorkspacesRequestQuery & ListWorkspacesRequestParams;
interface ListWorkspacesResponse {
    workspaces: UpdateWorkspaceResponse[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}
interface UpdateWorkspaceResponse {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface ListPublicWorkspacesRequestHeaders {
}
interface ListPublicWorkspacesRequestQuery {
    nextToken?: string;
    workspaceIds?: string[];
    search?: string;
}
interface ListPublicWorkspacesRequestParams {
}
interface ListPublicWorkspacesRequestBody {
}
type ListPublicWorkspacesInput = ListPublicWorkspacesRequestBody & ListPublicWorkspacesRequestHeaders & ListPublicWorkspacesRequestQuery & ListPublicWorkspacesRequestParams;
interface ListPublicWorkspacesResponse {
    workspaces: GetPublicWorkspaceResponse[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}
interface GetPublicWorkspaceResponse {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    handle?: string;
}

interface DeleteWorkspaceRequestHeaders {
}
interface DeleteWorkspaceRequestQuery {
}
interface DeleteWorkspaceRequestParams {
    id: string;
}
interface DeleteWorkspaceRequestBody {
}
type DeleteWorkspaceInput = DeleteWorkspaceRequestBody & DeleteWorkspaceRequestHeaders & DeleteWorkspaceRequestQuery & DeleteWorkspaceRequestParams;
interface DeleteWorkspaceResponse {
}

interface GetAuditRecordsRequestHeaders {
}
interface GetAuditRecordsRequestQuery {
    nextToken?: string;
}
interface GetAuditRecordsRequestParams {
    id: string;
}
interface GetAuditRecordsRequestBody {
}
type GetAuditRecordsInput = GetAuditRecordsRequestBody & GetAuditRecordsRequestHeaders & GetAuditRecordsRequestQuery & GetAuditRecordsRequestParams;
interface GetAuditRecordsResponse {
    records: {
        id: string;
        recordedAt: string;
        userId: string | null;
        userEmail?: string | null;
        resourceId: string | null;
        resourceName?: string | null;
        value?: string | null;
        action: "UNKNOWN" | "ADD_WORKSPACE_MEMBER" | "REMOVE_WORKSPACE_MEMBER" | "UPDATE_WORKSPACE_MEMBER" | "CLOSE_WORKSPACE" | "CREATE_BOT" | "CREATE_WORKSPACE" | "DELETE_BOT" | "DEPLOY_BOT" | "TRANSFER_BOT" | "DOWNLOAD_BOT_ARCHIVE" | "UPDATE_BOT" | "UPDATE_BOT_CHANNEL" | "UPDATE_BOT_CONFIG" | "UPDATE_PAYMENT_METHOD" | "UPDATE_WORKSPACE" | "SET_SPENDING_LIMIT" | "SET_AI_SPENDING_LIMIT" | "UPDATE_WORKSPACE_BILLING_READONLY";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface SetWorkspacePreferenceRequestHeaders {
}
interface SetWorkspacePreferenceRequestQuery {
}
interface SetWorkspacePreferenceRequestParams {
    key: string;
}
interface SetWorkspacePreferenceRequestBody {
    value?: any;
}
type SetWorkspacePreferenceInput = SetWorkspacePreferenceRequestBody & SetWorkspacePreferenceRequestHeaders & SetWorkspacePreferenceRequestQuery & SetWorkspacePreferenceRequestParams;
interface SetWorkspacePreferenceResponse {
}

interface GetWorkspacePreferenceRequestHeaders {
}
interface GetWorkspacePreferenceRequestQuery {
}
interface GetWorkspacePreferenceRequestParams {
    key: string;
}
interface GetWorkspacePreferenceRequestBody {
}
type GetWorkspacePreferenceInput = GetWorkspacePreferenceRequestBody & GetWorkspacePreferenceRequestHeaders & GetWorkspacePreferenceRequestQuery & GetWorkspacePreferenceRequestParams;
interface GetWorkspacePreferenceResponse {
    value?: any;
}

interface ListWorkspaceMembersRequestHeaders {
}
interface ListWorkspaceMembersRequestQuery {
    nextToken?: string;
}
interface ListWorkspaceMembersRequestParams {
}
interface ListWorkspaceMembersRequestBody {
}
type ListWorkspaceMembersInput = ListWorkspaceMembersRequestBody & ListWorkspaceMembersRequestHeaders & ListWorkspaceMembersRequestQuery & ListWorkspaceMembersRequestParams;
interface ListWorkspaceMembersResponse {
    members: UpdateWorkspaceMemberResponse$1[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}
interface UpdateWorkspaceMemberResponse$1 {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface GetWorkspaceMemberRequestHeaders {
}
interface GetWorkspaceMemberRequestQuery {
}
interface GetWorkspaceMemberRequestParams {
}
interface GetWorkspaceMemberRequestBody {
}
type GetWorkspaceMemberInput = GetWorkspaceMemberRequestBody & GetWorkspaceMemberRequestHeaders & GetWorkspaceMemberRequestQuery & GetWorkspaceMemberRequestParams;
interface GetWorkspaceMemberResponse {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface DeleteWorkspaceMemberRequestHeaders {
}
interface DeleteWorkspaceMemberRequestQuery {
}
interface DeleteWorkspaceMemberRequestParams {
    id: string;
}
interface DeleteWorkspaceMemberRequestBody {
}
type DeleteWorkspaceMemberInput = DeleteWorkspaceMemberRequestBody & DeleteWorkspaceMemberRequestHeaders & DeleteWorkspaceMemberRequestQuery & DeleteWorkspaceMemberRequestParams;
interface DeleteWorkspaceMemberResponse {
}

interface CreateWorkspaceMemberRequestHeaders {
}
interface CreateWorkspaceMemberRequestQuery {
}
interface CreateWorkspaceMemberRequestParams {
}
interface CreateWorkspaceMemberRequestBody {
    email: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
}
type CreateWorkspaceMemberInput = CreateWorkspaceMemberRequestBody & CreateWorkspaceMemberRequestHeaders & CreateWorkspaceMemberRequestQuery & CreateWorkspaceMemberRequestParams;
interface CreateWorkspaceMemberResponse {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface UpdateWorkspaceMemberRequestHeaders {
}
interface UpdateWorkspaceMemberRequestQuery {
}
interface UpdateWorkspaceMemberRequestParams {
    id: string;
}
interface UpdateWorkspaceMemberRequestBody {
    role?: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
}
type UpdateWorkspaceMemberInput = UpdateWorkspaceMemberRequestBody & UpdateWorkspaceMemberRequestHeaders & UpdateWorkspaceMemberRequestQuery & UpdateWorkspaceMemberRequestParams;
interface UpdateWorkspaceMemberResponse {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface ListIntegrationApiKeysRequestHeaders {
}
interface ListIntegrationApiKeysRequestQuery {
    integrationId: string;
}
interface ListIntegrationApiKeysRequestParams {
}
interface ListIntegrationApiKeysRequestBody {
}
type ListIntegrationApiKeysInput = ListIntegrationApiKeysRequestBody & ListIntegrationApiKeysRequestHeaders & ListIntegrationApiKeysRequestQuery & ListIntegrationApiKeysRequestParams;
interface ListIntegrationApiKeysResponse {
    iaks: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreateIntegrationApiKeyRequestHeaders {
}
interface CreateIntegrationApiKeyRequestQuery {
}
interface CreateIntegrationApiKeyRequestParams {
}
interface CreateIntegrationApiKeyRequestBody {
    integrationId: string;
    note?: string;
}
type CreateIntegrationApiKeyInput = CreateIntegrationApiKeyRequestBody & CreateIntegrationApiKeyRequestHeaders & CreateIntegrationApiKeyRequestQuery & CreateIntegrationApiKeyRequestParams;
interface CreateIntegrationApiKeyResponse {
    id: string;
    createdAt: string;
    note: string;
    /**
     * The IAK value. This will only be returned here when created and cannot be retrieved later.
     */
    value: string;
}

interface DeleteIntegrationApiKeyRequestHeaders {
}
interface DeleteIntegrationApiKeyRequestQuery {
}
interface DeleteIntegrationApiKeyRequestParams {
    id: string;
}
interface DeleteIntegrationApiKeyRequestBody {
}
type DeleteIntegrationApiKeyInput = DeleteIntegrationApiKeyRequestBody & DeleteIntegrationApiKeyRequestHeaders & DeleteIntegrationApiKeyRequestQuery & DeleteIntegrationApiKeyRequestParams;
interface DeleteIntegrationApiKeyResponse {
}

interface CreateIntegrationRequestHeaders {
}
interface CreateIntegrationRequestQuery {
}
interface CreateIntegrationRequestParams {
}
interface CreateIntegrationRequestBody {
    /**
     * Name of the [Integration](#schema_integration)
     */
    name: string;
    /**
     * Version of the [Integration](#schema_integration)
     */
    version: string;
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            required?: boolean;
            linkTemplateScript?: string;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                required?: boolean;
                linkTemplateScript?: string;
            };
        };
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    identifier?: {
        fallbackHandlerScript?: string;
        extractScript?: string;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
        };
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        };
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * URL of the integration
     */
    url?: string;
    /**
     * Indicates if the integration is a development integration; Dev integrations run locally
     */
    dev?: boolean;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type CreateIntegrationInput = CreateIntegrationRequestBody & CreateIntegrationRequestHeaders & CreateIntegrationRequestQuery & CreateIntegrationRequestParams;
interface CreateIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface ValidateIntegrationCreationRequestHeaders {
}
interface ValidateIntegrationCreationRequestQuery {
}
interface ValidateIntegrationCreationRequestParams {
}
interface ValidateIntegrationCreationRequestBody {
    /**
     * Name of the [Integration](#schema_integration)
     */
    name: string;
    /**
     * Version of the [Integration](#schema_integration)
     */
    version: string;
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            required?: boolean;
            linkTemplateScript?: string;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                required?: boolean;
                linkTemplateScript?: string;
            };
        };
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    identifier?: {
        fallbackHandlerScript?: string;
        extractScript?: string;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
        };
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        };
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * URL of the integration
     */
    url?: string;
    /**
     * Indicates if the integration is a development integration; Dev integrations run locally
     */
    dev?: boolean;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type ValidateIntegrationCreationInput = ValidateIntegrationCreationRequestBody & ValidateIntegrationCreationRequestHeaders & ValidateIntegrationCreationRequestQuery & ValidateIntegrationCreationRequestParams;
interface ValidateIntegrationCreationResponse {
}

interface UpdateIntegrationRequestHeaders {
}
interface UpdateIntegrationRequestQuery {
}
interface UpdateIntegrationRequestParams {
    id: string;
}
interface UpdateIntegrationRequestBody {
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            linkTemplateScript?: string | null;
            required?: boolean;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                linkTemplateScript?: string | null;
                required?: boolean;
            };
        } | null;
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages?: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                } | null;
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
        } | null;
    };
    /**
     * Maximum execution time of the integration (in seconds).
     */
    maxExecutionTime?: number;
    identifier?: {
        extractScript?: string | null;
        fallbackHandlerScript?: string | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        } | null;
    };
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * URL of the integration
     */
    url?: string | null;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type UpdateIntegrationInput = UpdateIntegrationRequestBody & UpdateIntegrationRequestHeaders & UpdateIntegrationRequestQuery & UpdateIntegrationRequestParams;
interface UpdateIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface ValidateIntegrationUpdateRequestHeaders {
}
interface ValidateIntegrationUpdateRequestQuery {
}
interface ValidateIntegrationUpdateRequestParams {
    id: string;
}
interface ValidateIntegrationUpdateRequestBody {
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            linkTemplateScript?: string | null;
            required?: boolean;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                linkTemplateScript?: string | null;
                required?: boolean;
            };
        } | null;
    };
    /**
     * **EXPERIMENTAL** Extra integration operations that should be sent or not to the integration instances. The key is the operation name.
     */
    extraOperations?: {
        [k: string]: {
            enabled: boolean;
        };
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages?: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                } | null;
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
        } | null;
    };
    /**
     * Maximum execution time of the integration (in seconds).
     */
    maxExecutionTime?: number;
    identifier?: {
        extractScript?: string | null;
        fallbackHandlerScript?: string | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    interfaces?: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            entities?: {
                [k: string]: {
                    name: string;
                };
            };
            actions?: {
                [k: string]: {
                    name: string;
                };
            };
            events?: {
                [k: string]: {
                    name: string;
                };
            };
            channels?: {
                [k: string]: {
                    name: string;
                };
            };
        } | null;
    };
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * URL of the integration
     */
    url?: string | null;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public?: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility?: "public" | "private" | "unlisted";
    layers?: string[];
}
type ValidateIntegrationUpdateInput = ValidateIntegrationUpdateRequestBody & ValidateIntegrationUpdateRequestHeaders & ValidateIntegrationUpdateRequestQuery & ValidateIntegrationUpdateRequestParams;
interface ValidateIntegrationUpdateResponse {
}

interface ListIntegrationsRequestHeaders {
}
interface ListIntegrationsRequestQuery {
    nextToken?: string;
    limit?: number;
    name?: string;
    version?: string;
    interfaceId?: string;
    interfaceName?: string;
    installedByBotId?: string;
    verificationStatus?: "unapproved" | "pending" | "approved" | "rejected";
    search?: string;
    sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount";
    direction?: "asc" | "desc";
    visibility?: "public" | "private";
    dev?: boolean;
}
interface ListIntegrationsRequestParams {
}
interface ListIntegrationsRequestBody {
}
type ListIntegrationsInput = ListIntegrationsRequestBody & ListIntegrationsRequestHeaders & ListIntegrationsRequestQuery & ListIntegrationsRequestParams;
interface ListIntegrationsResponse {
    integrations: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Metadata about which fields matched the search criteria
         */
        matchedOn?: {
            /**
             * Whether the integration name matched the search term
             */
            name?: boolean;
            /**
             * Whether the integration title matched the search term
             */
            title?: boolean;
            /**
             * Whether the integration description matched the search term
             */
            description?: boolean;
            /**
             * Action names that matched the search term
             */
            actions?: string[];
            /**
             * Interface names that matched the search term
             */
            interfaces?: string[];
        };
        ownerWorkspace?: {
            id: string;
            handle: string | null;
            name: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetIntegrationRequestHeaders {
}
interface GetIntegrationRequestQuery {
}
interface GetIntegrationRequestParams {
    id: string;
}
interface GetIntegrationRequestBody {
}
type GetIntegrationInput = GetIntegrationRequestBody & GetIntegrationRequestHeaders & GetIntegrationRequestQuery & GetIntegrationRequestParams;
interface GetIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface GetIntegrationLogsRequestHeaders {
}
interface GetIntegrationLogsRequestQuery {
    timeStart: string;
    timeEnd?: string;
    level?: string;
    userId?: string;
    conversationId?: string;
    messageContains?: string;
    nextToken?: string;
}
interface GetIntegrationLogsRequestParams {
    id: string;
}
interface GetIntegrationLogsRequestBody {
}
type GetIntegrationLogsInput = GetIntegrationLogsRequestBody & GetIntegrationLogsRequestHeaders & GetIntegrationLogsRequestQuery & GetIntegrationLogsRequestParams;
interface GetIntegrationLogsResponse {
    logs: {
        timestamp: string;
        level: string;
        message: string;
        workflowId?: string;
        userId?: string;
        conversationId?: string;
    }[];
    nextToken?: string;
}

interface GetIntegrationByNameRequestHeaders {
}
interface GetIntegrationByNameRequestQuery {
}
interface GetIntegrationByNameRequestParams {
    name: string;
    version: string;
}
interface GetIntegrationByNameRequestBody {
}
type GetIntegrationByNameInput = GetIntegrationByNameRequestBody & GetIntegrationByNameRequestHeaders & GetIntegrationByNameRequestQuery & GetIntegrationByNameRequestParams;
interface GetIntegrationByNameResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        sandbox?: {
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
             */
            identifierExtractScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
             */
            messageExtractScript?: string;
        };
        /**
         * Maximum execution time of the integration (in seconds).
         */
        maxExecutionTime?: number;
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                /**
                 * ID of the interface
                 */
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                /**
                 * Version of the interface
                 */
                version: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
                channels: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * @deprecated
         * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
         */
        public: boolean;
        /**
         * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
         */
        visibility: "public" | "private" | "unlisted";
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface DeleteIntegrationRequestHeaders {
}
interface DeleteIntegrationRequestQuery {
}
interface DeleteIntegrationRequestParams {
    id: string;
}
interface DeleteIntegrationRequestBody {
}
type DeleteIntegrationInput = DeleteIntegrationRequestBody & DeleteIntegrationRequestHeaders & DeleteIntegrationRequestQuery & DeleteIntegrationRequestParams;
interface DeleteIntegrationResponse {
}

interface RequestIntegrationVerificationRequestHeaders {
}
interface RequestIntegrationVerificationRequestQuery {
}
interface RequestIntegrationVerificationRequestParams {
}
interface RequestIntegrationVerificationRequestBody {
    integrationId: string;
}
type RequestIntegrationVerificationInput = RequestIntegrationVerificationRequestBody & RequestIntegrationVerificationRequestHeaders & RequestIntegrationVerificationRequestQuery & RequestIntegrationVerificationRequestParams;
interface RequestIntegrationVerificationResponse {
}

interface CreateInterfaceRequestHeaders {
}
interface CreateInterfaceRequestQuery {
}
interface CreateInterfaceRequestParams {
}
interface CreateInterfaceRequestBody {
    /**
     * Name of the [Interface](#schema_interface)
     */
    name: string;
    /**
     * Version of the [Interface](#schema_interface)
     */
    version: string;
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    /**
     * Base64 encoded svg of the interface icon. This icon is global to the interface each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the interface readme. The readme is specific to each interface versions.
     */
    readme?: string;
    /**
     * Title of the interface. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the interface. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
}
type CreateInterfaceInput = CreateInterfaceRequestBody & CreateInterfaceRequestHeaders & CreateInterfaceRequestQuery & CreateInterfaceRequestParams;
interface CreateInterfaceResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetInterfaceRequestHeaders {
}
interface GetInterfaceRequestQuery {
}
interface GetInterfaceRequestParams {
    id: string;
}
interface GetInterfaceRequestBody {
}
type GetInterfaceInput = GetInterfaceRequestBody & GetInterfaceRequestHeaders & GetInterfaceRequestQuery & GetInterfaceRequestParams;
interface GetInterfaceResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetInterfaceByNameRequestHeaders {
}
interface GetInterfaceByNameRequestQuery {
}
interface GetInterfaceByNameRequestParams {
    name: string;
    version: string;
}
interface GetInterfaceByNameRequestBody {
}
type GetInterfaceByNameInput = GetInterfaceByNameRequestBody & GetInterfaceByNameRequestHeaders & GetInterfaceByNameRequestQuery & GetInterfaceByNameRequestParams;
interface GetInterfaceByNameResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface UpdateInterfaceRequestHeaders {
}
interface UpdateInterfaceRequestQuery {
}
interface UpdateInterfaceRequestParams {
    id: string;
}
interface UpdateInterfaceRequestBody {
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages?: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                } | null;
            };
        } | null;
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    } | null;
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    /**
     * Base64 encoded svg of the interface icon. This icon is global to the interface each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the interface readme. The readme is specific to each interface versions.
     */
    readme?: string;
    /**
     * Title of the interface. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the interface. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
}
type UpdateInterfaceInput = UpdateInterfaceRequestBody & UpdateInterfaceRequestHeaders & UpdateInterfaceRequestQuery & UpdateInterfaceRequestParams;
interface UpdateInterfaceResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        channels: {
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface DeleteInterfaceRequestHeaders {
}
interface DeleteInterfaceRequestQuery {
}
interface DeleteInterfaceRequestParams {
    id: string;
}
interface DeleteInterfaceRequestBody {
}
type DeleteInterfaceInput = DeleteInterfaceRequestBody & DeleteInterfaceRequestHeaders & DeleteInterfaceRequestQuery & DeleteInterfaceRequestParams;
interface DeleteInterfaceResponse {
}

interface ListInterfacesRequestHeaders {
}
interface ListInterfacesRequestQuery {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListInterfacesRequestParams {
}
interface ListInterfacesRequestBody {
}
type ListInterfacesInput = ListInterfacesRequestBody & ListInterfacesRequestHeaders & ListInterfacesRequestQuery & ListInterfacesRequestParams;
interface ListInterfacesResponse {
    interfaces: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        /**
         * Title of the interface. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the interface. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the interface. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the interface. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreatePluginRequestHeaders {
}
interface CreatePluginRequestQuery {
}
interface CreatePluginRequestParams {
}
interface CreatePluginRequestBody {
    /**
     * Name of the [Plugin](#schema_plugin)
     */
    name: string;
    /**
     * Version of the [Plugin](#schema_plugin)
     */
    version: string;
    /**
     * Configuration definition
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    };
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    /**
     * User object configuration
     */
    user?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Conversation object configuration
     */
    conversation?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    code: {
        /**
         * Code of plugin bundled for Node.JS
         */
        node: string;
        /**
         * Code of plugin bundled for the browser
         */
        browser: string;
    };
    /**
     * Base64 encoded svg of the plugin icon. This icon is global to the plugin each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the plugin readme. The readme is specific to each plugin versions.
     */
    readme?: string;
    /**
     * Title of the plugin. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the plugin. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
    dependencies?: {
        /**
         * Mapping of interface aliases to interface references
         */
        interfaces?: {
            [k: string]: {
                /**
                 * Id of the interface. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the interface
                 */
                name?: string;
                /**
                 * Version of the interface. Accepts semver versions and version ranges
                 */
                version?: string;
            };
        };
        /**
         * Mapping of integration aliases to integration references
         */
        integrations?: {
            [k: string]: {
                /**
                 * Id of the integration. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the integration
                 */
                name?: string;
                /**
                 * Version of the integration. Accepts semver versions and version ranges
                 */
                version?: string;
            };
        };
    };
}
type CreatePluginInput = CreatePluginRequestBody & CreatePluginRequestHeaders & CreatePluginRequestQuery & CreatePluginRequestParams;
interface CreatePluginResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPluginRequestHeaders {
}
interface GetPluginRequestQuery {
}
interface GetPluginRequestParams {
    id: string;
}
interface GetPluginRequestBody {
}
type GetPluginInput = GetPluginRequestBody & GetPluginRequestHeaders & GetPluginRequestQuery & GetPluginRequestParams;
interface GetPluginResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetDereferencedPluginRequestHeaders {
}
interface GetDereferencedPluginRequestQuery {
    /**
     * Mapping of interface aliases to integration IDs
     */
    interfaces: {
        /**
         * integration id
         */
        [k: string]: string;
    };
}
interface GetDereferencedPluginRequestParams {
    id: string;
}
interface GetDereferencedPluginRequestBody {
}
type GetDereferencedPluginInput = GetDereferencedPluginRequestBody & GetDereferencedPluginRequestHeaders & GetDereferencedPluginRequestQuery & GetDereferencedPluginRequestParams;
interface GetDereferencedPluginResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface GetPluginByNameRequestHeaders {
}
interface GetPluginByNameRequestQuery {
}
interface GetPluginByNameRequestParams {
    name: string;
    version: string;
}
interface GetPluginByNameRequestBody {
}
type GetPluginByNameInput = GetPluginByNameRequestBody & GetPluginByNameRequestHeaders & GetPluginByNameRequestQuery & GetPluginByNameRequestParams;
interface GetPluginByNameResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface UpdatePluginRequestHeaders {
}
interface UpdatePluginRequestQuery {
}
interface UpdatePluginRequestParams {
    id: string;
}
interface UpdatePluginRequestBody {
    /**
     * Configuration definition
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    } | null;
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        } | null;
    };
    events?: {
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    actions?: {
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes. Set attributes to null to remove them
             */
            attributes?: {
                [k: string]: string | null;
            };
        } | null;
    };
    user?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    conversation?: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    /**
     * Optional attributes. Set attributes to null to remove them
     */
    attributes?: {
        [k: string]: string | null;
    };
    code?: {
        /**
         * Code of plugin bundled for Node.JS
         */
        node?: string;
        /**
         * Code of plugin bundled for the browser
         */
        browser?: string;
    };
    /**
     * Base64 encoded svg of the plugin icon. This icon is global to the plugin each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the plugin readme. The readme is specific to each plugin versions.
     */
    readme?: string;
    /**
     * Title of the plugin. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the plugin. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
    dependencies?: {
        /**
         * Mapping of interface aliases to interface references
         */
        interfaces?: {
            [k: string]: {
                /**
                 * Id of the interface. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the interface
                 */
                name?: string;
                /**
                 * Version of the interface. Accepts semver versions and version ranges
                 */
                version?: string;
            } | null;
        };
        /**
         * Mapping of integration aliases to integration references
         */
        integrations?: {
            [k: string]: {
                /**
                 * Id of the integration. If provided, "name" and "version" are ignored
                 */
                id?: string;
                /**
                 * Name of the integration
                 */
                name?: string;
                /**
                 * Version of the integration. Accepts semver versions and version ranges
                 */
                version?: string;
            } | null;
        };
    };
}
type UpdatePluginInput = UpdatePluginRequestBody & UpdatePluginRequestHeaders & UpdatePluginRequestQuery & UpdatePluginRequestParams;
interface UpdatePluginResponse {
    plugin: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
                /**
                 * Optional attributes
                 */
                attributes?: {
                    [k: string]: string;
                };
            };
        };
        dependencies: {
            interfaces: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
            integrations: {
                [k: string]: {
                    id: string;
                    name: string;
                    version: string;
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Optional attributes
         */
        attributes?: {
            [k: string]: string;
        };
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    };
}

interface DeletePluginRequestHeaders {
}
interface DeletePluginRequestQuery {
}
interface DeletePluginRequestParams {
    id: string;
}
interface DeletePluginRequestBody {
}
type DeletePluginInput = DeletePluginRequestBody & DeletePluginRequestHeaders & DeletePluginRequestQuery & DeletePluginRequestParams;
interface DeletePluginResponse {
}

interface ListPluginsRequestHeaders {
}
interface ListPluginsRequestQuery {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListPluginsRequestParams {
}
interface ListPluginsRequestBody {
}
type ListPluginsInput = ListPluginsRequestBody & ListPluginsRequestHeaders & ListPluginsRequestQuery & ListPluginsRequestParams;
interface ListPluginsResponse {
    plugins: {
        /**
         * ID of the [Plugin](#schema_plugin)
         */
        id: string;
        /**
         * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Plugin](#schema_plugin)
         */
        name: string;
        /**
         * Version of the [Plugin](#schema_plugin)
         */
        version: string;
        /**
         * Title of the plugin. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the plugin. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the plugin. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the plugin. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPluginCodeRequestHeaders {
}
interface GetPluginCodeRequestQuery {
}
interface GetPluginCodeRequestParams {
    id: string;
    platform: "node" | "browser";
}
interface GetPluginCodeRequestBody {
}
type GetPluginCodeInput = GetPluginCodeRequestBody & GetPluginCodeRequestHeaders & GetPluginCodeRequestQuery & GetPluginCodeRequestParams;
interface GetPluginCodeResponse {
    code: string;
}

interface GetUsageRequestHeaders {
}
interface GetUsageRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface GetUsageRequestParams {
    id: string;
}
interface GetUsageRequestBody {
}
type GetUsageInput = GetUsageRequestBody & GetUsageRequestHeaders & GetUsageRequestQuery & GetUsageRequestParams;
interface GetUsageResponse {
    usage: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    };
}

interface GetMultipleUsagesRequestHeaders {
}
interface GetMultipleUsagesRequestQuery {
    types: string[];
    ids: string[];
    period?: string;
}
interface GetMultipleUsagesRequestParams {
}
interface GetMultipleUsagesRequestBody {
}
type GetMultipleUsagesInput = GetMultipleUsagesRequestBody & GetMultipleUsagesRequestHeaders & GetMultipleUsagesRequestQuery & GetMultipleUsagesRequestParams;
interface GetMultipleUsagesResponse {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface ListUsageHistoryRequestHeaders {
}
interface ListUsageHistoryRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
}
interface ListUsageHistoryRequestParams {
    id: string;
}
interface ListUsageHistoryRequestBody {
}
type ListUsageHistoryInput = ListUsageHistoryRequestBody & ListUsageHistoryRequestHeaders & ListUsageHistoryRequestQuery & ListUsageHistoryRequestParams;
interface ListUsageHistoryResponse {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface ListUsageActivityRequestHeaders {
}
interface ListUsageActivityRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    timestampFrom?: string;
    timestampUntil?: string;
    nextToken?: string;
}
interface ListUsageActivityRequestParams {
    id: string;
}
interface ListUsageActivityRequestBody {
}
type ListUsageActivityInput = ListUsageActivityRequestBody & ListUsageActivityRequestHeaders & ListUsageActivityRequestQuery & ListUsageActivityRequestParams;
interface ListUsageActivityResponse {
    data: {
        timestamp: string;
        value: number;
        period: string;
        metadata: {
            [k: string]: any | null;
        };
    }[];
    meta: {
        nextToken?: string;
    };
}

interface ListUsageActivityDailyRequestHeaders {
}
interface ListUsageActivityDailyRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    dateFrom?: string;
    dateUntil?: string;
    nextToken?: string;
}
interface ListUsageActivityDailyRequestParams {
    id: string;
}
interface ListUsageActivityDailyRequestBody {
}
type ListUsageActivityDailyInput = ListUsageActivityDailyRequestBody & ListUsageActivityDailyRequestHeaders & ListUsageActivityDailyRequestQuery & ListUsageActivityDailyRequestParams;
interface ListUsageActivityDailyResponse {
    data: {
        key: string;
        date: string;
        value: number;
        metadata?: {
            botId: string;
            type: "IntegrationAction" | "FileIndexing" | "BingSearch" | "WebSearch";
            subtype?: string;
            source?: string;
        };
    }[];
    meta: {
        nextToken?: string;
    };
}

interface ChangeAispendQuotaRequestHeaders {
}
interface ChangeAispendQuotaRequestQuery {
}
interface ChangeAispendQuotaRequestParams {
}
interface ChangeAispendQuotaRequestBody {
    monthlySpendingLimit: number;
}
type ChangeAispendQuotaInput = ChangeAispendQuotaRequestBody & ChangeAispendQuotaRequestHeaders & ChangeAispendQuotaRequestQuery & ChangeAispendQuotaRequestParams;
interface ChangeAispendQuotaResponse {
}

interface ListActivitiesRequestHeaders {
}
interface ListActivitiesRequestQuery {
    nextToken?: string;
    taskId: string;
    botId: string;
}
interface ListActivitiesRequestParams {
}
interface ListActivitiesRequestBody {
}
type ListActivitiesInput = ListActivitiesRequestBody & ListActivitiesRequestHeaders & ListActivitiesRequestQuery & ListActivitiesRequestParams;
interface ListActivitiesResponse {
    activities: {
        id: string;
        description: string;
        taskId: string;
        category: "unknown" | "capture" | "bot_message" | "user_message" | "agent_message" | "event" | "action" | "task_status" | "subtask_status" | "exception";
        data: {
            [k: string]: any;
        };
        /**
         * Creation date of the activity in ISO 8601 format
         */
        createdAt: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface IntrospectRequestHeaders {
}
interface IntrospectRequestQuery {
}
interface IntrospectRequestParams {
}
interface IntrospectRequestBody {
    botId: string;
}
type IntrospectInput = IntrospectRequestBody & IntrospectRequestHeaders & IntrospectRequestQuery & IntrospectRequestParams;
interface IntrospectResponse {
    workspaceId: string;
    botId: string;
    userId: string;
}

interface UpsertFileRequestHeaders {
}
interface UpsertFileRequestQuery {
}
interface UpsertFileRequestParams {
}
interface UpsertFileRequestBody {
    /**
     * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
     */
    key: string;
    /**
     * File tags as an object of key-value pairs. Tag values should be of `string` (text) type.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * File size in bytes. This will count against your File Storage quota. If the `index` parameter is set to `true`, this will also count against your Vector DB Storage quota.
     */
    size: number;
    /**
     * Set to a value of 'true' to index the file in vector storage. Only certain file formats are currently supported for indexing. Files larger than 95 MB cannot be indexed. Note that if a file is indexed, it will count towards both the Vector DB Storage quota and the File Storage quota of the workspace.
     */
    index?: boolean;
    indexing?: {
        /**
         * Configuration to use for indexing the file, will be stored in the file's metadata for reference.
         */
        configuration: {
            parsing?: {
                /**
                 * The minimum length a standalone paragraph should have. If a paragraph is shorter than this, it will be merged with the next immediate paragraph.
                 */
                minimumParagraphLength?: number;
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) Enabling this will use a lightweight/inexpensive LLM to clean up the extracted content of PDF files before indexing them to increase the quality of the stored vectors, as PDFs often store raw text in unusual ways which when extracted may result in formatting issues (e.g. broken sentences/paragraphs, unexpected headings, garbled characters, etc.) that can affect retrieval performance for certain user queries if left untouched.
                 *
                 * Notes:
                 * - This feature is only available in Team and Enterprise plans.
                 * - This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred.
                 * - We recommend using this feature for PDFs that have custom layouts or design. For simple text-based PDFs like documents and books, this feature is usually not necessary.
                 * - The smart cleanup takes some time to perform due to the LLM calls involved, so enabling it will increase the total time it takes to index the file.
                 * - We take steps to prevent the original text from being fundamentally changed but due to the nature of LLMs this could theoretically still happen so it's recommended to review the passages generated for the file after indexing to ensure the content is still accurate.
                 * - This feature is limited to the first 30 pages or 20 KB of text in the PDF file (whichever comes first). If the file has more content than these limits then the rest of the file will be indexed as-is without any cleanup. If you need to clean up the content of the entire file, consider splitting it into smaller files.
                 */
                smartCleanup?: boolean;
            };
            chunking?: {
                /**
                 * The maximum length of a chunk in characters.
                 */
                maximumChunkLength?: number;
                /**
                 * The number of surrounding context levels to include in the vector embedding of the chunk.
                 */
                embeddedContextLevels?: number;
                /**
                 * Include the breadcrumb of the chunk in the vector embedding.
                 */
                embedBreadcrumb?: boolean;
            };
            summarization?: {
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) Create summaries for this file and index them as standalone vectors. Enabling this option will incur in AI Spend cost (charged to the workspace of the bot) to generate the summaries based on the amount of content in the file and the summarization model used.
                 *
                 * Please note that this feature is only available in Team and Enterprise plans.
                 */
                enable?: boolean;
                /**
                 * The model type to use for summarization.
                 */
                modelType?: "inexpensive" | "balanced" | "accurate";
                /**
                 * The minimum length a section of the file should have to create a summary of it.
                 */
                minimumInputLength?: number;
                /**
                 * The maximum length of a summary (in tokens).
                 */
                outputTokenLimit?: number;
                /**
                 * Generate a summary of the entire file and index it as a standalone vector.
                 */
                generateMasterSummary?: boolean;
            };
            /**
             * If not set, the default indexing stack will be used.
             */
            stack?: "legacy" | "realtime-v1";
            vision?: {
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) For PDF files, set this option to `true` or pass an array with specific page numbers to use a vision-enabled LLM to transcribe each page of the PDF as standalone vectors and index them.
                 *
                 * This feature is useful when a PDF file contains custom designs or layouts, or when your document has many infographics, which require visual processing in order to index the file effectively, as the default text-based indexing may not be enough to allow your bot to correctly understand the content in your PDFs.
                 *
                 * Notes:
                 * - This feature is only available in Team and Enterprise plans.
                 * - Enabling this feature will incur in AI Spend cost to use a vision-enabled LLM to index the PDF pages.
                 * - This is limited to a maximum of 100 pages of the PDF. If the file has more pages then the rest of the pages will NOT be transcribed using this vision feature, and will be processed using the default text-based indexing instead. If you need to transcribe the entire file using vision, please split it into smaller files.
                 * - Pages that are vision-transcribed will not be processed by the default text-based indexing to avoid duplicate content in the index.
                 * - This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred.
                 */
                transcribePages?: {
                    [k: string]: any;
                };
                /**
                 * (Team/Enterprise plan only, charged as AI Spend) For PDF files, set this option to `true` or pass an array with specific page numbers to use a vision-enabled LLM to index each page of the PDF as a standalone image.
                 *
                 * Enabling this feature will allow Autonomous Nodes in your bot to answer visual or higher-level questions about the content in these pages that can usually not be answered correctly by the default text-based indexing or visual transcription.
                 *
                 * This feature is useful when a PDF has:
                 * - Tables with complex layouts
                 * - Charts, diagrams or infographics
                 * - Photos or images that can be used to answer user queries
                 *
                 * Notes:
                 * - This feature is only available in Team and Enterprise plans.
                 * - Enabling this will incur in extra AI Spend cost and additional File Storage usage, in order to use a vision-enabled LLM to visually index the PDF pages and store them as standalone page images in the bot's file storage.
                 * - Enabling this may increase the overall AI Spend cost of your bot as your bot may pass one or more indexed page images to a vision-enabled LLM for answering user queries.
                 * - This is limited to the first 100 pages of the PDF. If the file has more pages then the rest of the pages will NOT be vision-indexed. If you need to visually index the entire file, please split it into smaller files.
                 * - This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred.
                 */
                indexPages?: {
                    [k: string]: any;
                };
            };
        };
    };
    /**
     * File access policies. Add "public_content" to allow public access to the file content. Add "integrations" to allow read, search and list operations for any integration installed in the bot.
     */
    accessPolicies?: ("public_content" | "integrations")[];
    /**
     * File content type. If omitted, the content type will be inferred from the file extension (if any) specified in `key`. If a content type cannot be inferred, the default is "application/octet-stream".
     */
    contentType?: string;
    /**
     * Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored.
     */
    expiresAt?: string;
    /**
     * Use when your file has "public_content" in its access policy and you need the file\'s content to be immediately accessible through its URL after the file has been uploaded without having to wait for the upload to be processed by our system.
     *
     * If set to `true`, the `x-amz-tagging` HTTP header with a value of `public=true` will need to be sent in the HTTP PUT request to the `uploadUrl` in order for the upload request to work.
     */
    publicContentImmediatelyAccessible?: boolean;
    /**
     * Custom metadata for the file expressed as an object of key-value pairs. The values can be of any type.
     */
    metadata?: {
        [k: string]: any;
    };
}
type UpsertFileInput = UpsertFileRequestBody & UpsertFileRequestHeaders & UpsertFileRequestQuery & UpsertFileRequestParams;
interface UpsertFileResponse {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
        /**
         * URL to upload the file content. File content needs to be sent to this URL via a PUT request.
         */
        uploadUrl: string;
    };
}

interface DeleteFileRequestHeaders {
}
interface DeleteFileRequestQuery {
}
interface DeleteFileRequestParams {
    id: string;
}
interface DeleteFileRequestBody {
}
type DeleteFileInput = DeleteFileRequestBody & DeleteFileRequestHeaders & DeleteFileRequestQuery & DeleteFileRequestParams;
interface DeleteFileResponse {
}

interface ListFilesRequestHeaders {
}
interface ListFilesRequestQuery {
    nextToken?: string;
    sortField?: "key" | "size" | "createdAt" | "updatedAt" | "status";
    sortDirection?: "asc" | "desc";
    tags?: any;
    /**
     * @maxItems 50
     */
    ids?: string[];
}
interface ListFilesRequestParams {
}
interface ListFilesRequestBody {
}
type ListFilesInput = ListFilesRequestBody & ListFilesRequestHeaders & ListFilesRequestQuery & ListFilesRequestParams;
interface ListFilesResponse {
    files: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any | null;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetFileRequestHeaders {
}
interface GetFileRequestQuery {
}
interface GetFileRequestParams {
    id: string;
}
interface GetFileRequestBody {
}
type GetFileInput = GetFileRequestBody & GetFileRequestHeaders & GetFileRequestQuery & GetFileRequestParams;
interface GetFileResponse {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    };
}

interface UpdateFileMetadataRequestHeaders {
}
interface UpdateFileMetadataRequestQuery {
}
interface UpdateFileMetadataRequestParams {
    id: string;
}
interface UpdateFileMetadataRequestBody {
    /**
     * Custom metadata for the file expressed as an object of key-value pairs. Omit to keep existing metadata intact. Any existing metadata keys not included will be preserved. New keys will be added. To delete a metadata key, set its value to `null`.
     */
    metadata?: {
        [k: string]: any;
    };
    /**
     * The file tags to update as an object of key-value pairs with `string` (text) values. Omit to keep existing tags intact. Any existing tags not included will be preserved. New tags will be added. To delete a tag, set its value to `null`.
     */
    tags?: {
        [k: string]: string | null;
    };
    /**
     * New access policies to set for the file. Omit to keep existing policies intact.
     */
    accessPolicies?: ("integrations" | "public_content")[];
    /**
     * Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored. Omit to keep the existing expiry intact. Set to `null` to remove the expiry.
     */
    expiresAt?: string | null;
}
type UpdateFileMetadataInput = UpdateFileMetadataRequestBody & UpdateFileMetadataRequestHeaders & UpdateFileMetadataRequestQuery & UpdateFileMetadataRequestParams;
interface UpdateFileMetadataResponse {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    };
}

interface CopyFileRequestHeaders {
    "x-destination-bot-id"?: string;
}
interface CopyFileRequestQuery {
}
interface CopyFileRequestParams {
    idOrKey: string;
    destinationKey: string;
}
interface CopyFileRequestBody {
    /**
     * Set to `true` to overwrite the file if it already exists, otherwise an error will be returned.
     *
     * When this endpoint is called using bot authentication, the existing file must have been originally created by the same bot making the file copy request in order to overwrite it.
     */
    overwrite?: boolean;
}
type CopyFileInput = CopyFileRequestBody & CopyFileRequestHeaders & CopyFileRequestQuery & CopyFileRequestParams;
interface CopyFileResponse {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Metadata of the file as an object of key/value pairs. The values can be of any type.
         */
        metadata: {
            [k: string]: any;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        owner: {
            type: "bot" | "integration" | "user";
            /**
             * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
             */
            id?: string;
            /**
             * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
             */
            name?: string;
        };
        /**
         * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
         */
        indexingStack?: "v1" | "v2";
    };
}

interface SearchFilesRequestHeaders {
}
interface SearchFilesRequestQuery {
    tags?: any;
    query: string;
    contextDepth?: number;
    limit?: number;
    consolidate?: boolean;
    includeBreadcrumb?: boolean;
    withContext?: boolean;
}
interface SearchFilesRequestParams {
}
interface SearchFilesRequestBody {
}
type SearchFilesInput = SearchFilesRequestBody & SearchFilesRequestHeaders & SearchFilesRequestQuery & SearchFilesRequestParams;
interface SearchFilesResponse {
    passages: {
        /**
         * The content of the matching passage in the file including surrounding context, if any.
         */
        content: string;
        /**
         * The score indicating the similarity of the passage to the query. A higher score indicates higher similarity.
         */
        score: number;
        /**
         * The passage metadata.
         */
        meta: {
            /**
             * The type of passage
             */
            type?: "chunk" | "summary" | "consolidated" | "image";
            /**
             * The subtype of passage, if available.
             */
            subtype?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image" | "page";
            /**
             * Page number the passage is located on. Only applicable if the passage was extracted from a PDF file.
             */
            pageNumber?: number;
            /**
             * Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file.
             */
            position?: number;
            /**
             * The URL of the source file for the vector, if applicable (e.g. for image vectors).
             */
            sourceUrl?: string;
        };
        file: {
            /**
             * File ID
             */
            id: string;
            /**
             * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
             */
            key: string;
            /**
             * MIME type of the file's content
             */
            contentType: string;
            /**
             * The tags of the file as an object of key-value pairs.
             */
            tags: {
                [k: string]: string;
            };
            /**
             * File creation timestamp in ISO 8601 format
             */
            createdAt: string;
            /**
             * File last update timestamp in ISO 8601 format
             */
            updatedAt: string;
        };
        /**
         * Surrounding passages including the current passage, based on the requested `contextDepth`. Only returned if the `withContext` parameter is set to `true`. Not supported when using the `consolidate` option.
         */
        context?: {
            /**
             * The ID of the vector that the context passage belongs to. Omitted for breadcrumbs.
             */
            id?: string;
            text: string;
            /**
             * Position of the context passage relative to the current passage. Negative for preceding passages, positive for subsequent, ommited for breadcrumbs.
             */
            offset?: number;
            /**
             * The type of context passage
             */
            type: "preceding" | "subsequent" | "current" | "breadcrumb";
        }[];
    }[];
}

interface ListFilePassagesRequestHeaders {
}
interface ListFilePassagesRequestQuery {
    nextToken?: string;
    limit?: number;
}
interface ListFilePassagesRequestParams {
    id: string;
}
interface ListFilePassagesRequestBody {
}
type ListFilePassagesInput = ListFilePassagesRequestBody & ListFilePassagesRequestHeaders & ListFilePassagesRequestQuery & ListFilePassagesRequestParams;
interface ListFilePassagesResponse {
    passages: {
        /**
         * Passage ID
         */
        id: string;
        /**
         * The content of the passage.
         */
        content: string;
        /**
         * The passage metadata.
         */
        meta: {
            /**
             * The type of passage
             */
            type?: "chunk" | "summary" | "consolidated" | "image";
            /**
             * The subtype of passage, if available.
             */
            subtype?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image" | "page";
            /**
             * Page number the passage is located on. Only applicable if the passage was extracted from a PDF file.
             */
            pageNumber?: number;
            /**
             * Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file.
             */
            position?: number;
            /**
             * The URL of the source file for the vector, if applicable (e.g. for image vectors).
             */
            sourceUrl?: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface SetFilePassagesRequestHeaders {
}
interface SetFilePassagesRequestQuery {
}
interface SetFilePassagesRequestParams {
    id: string;
}
interface SetFilePassagesRequestBody {
    /**
     * Note: The passages should appear in the array in the same order as they appear in the original document.
     */
    passages: {
        /**
         * The content of the passage, supports Markdown formatting.
         */
        content: string;
        /**
         * The type should match the Markdown format used for the passage content.
         */
        type?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image";
        pageNumber?: number;
    }[];
}
type SetFilePassagesInput = SetFilePassagesRequestBody & SetFilePassagesRequestHeaders & SetFilePassagesRequestQuery & SetFilePassagesRequestParams;
interface SetFilePassagesResponse {
}

interface ListFileTagsRequestHeaders {
}
interface ListFileTagsRequestQuery {
    nextToken?: string;
}
interface ListFileTagsRequestParams {
}
interface ListFileTagsRequestBody {
}
type ListFileTagsInput = ListFileTagsRequestBody & ListFileTagsRequestHeaders & ListFileTagsRequestQuery & ListFileTagsRequestParams;
interface ListFileTagsResponse {
    tags: string[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface ListFileTagValuesRequestHeaders {
}
interface ListFileTagValuesRequestQuery {
    nextToken?: string;
}
interface ListFileTagValuesRequestParams {
    tag: string;
}
interface ListFileTagValuesRequestBody {
}
type ListFileTagValuesInput = ListFileTagValuesRequestBody & ListFileTagValuesRequestHeaders & ListFileTagValuesRequestQuery & ListFileTagValuesRequestParams;
interface ListFileTagValuesResponse {
    values: string[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateKnowledgeBaseRequestHeaders {
}
interface CreateKnowledgeBaseRequestQuery {
}
interface CreateKnowledgeBaseRequestParams {
}
interface CreateKnowledgeBaseRequestBody {
    /**
     * Name of the knowledge base.
     */
    name: string;
    tags?: {
        [k: string]: string;
    };
}
type CreateKnowledgeBaseInput = CreateKnowledgeBaseRequestBody & CreateKnowledgeBaseRequestHeaders & CreateKnowledgeBaseRequestQuery & CreateKnowledgeBaseRequestParams;
interface CreateKnowledgeBaseResponse {
    knowledgeBase: {
        /**
         * Knowledge base ID
         */
        id: string;
        /**
         * Name of the knowledge base.
         */
        name: string;
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteKnowledgeBaseRequestHeaders {
}
interface DeleteKnowledgeBaseRequestQuery {
}
interface DeleteKnowledgeBaseRequestParams {
    id: string;
}
interface DeleteKnowledgeBaseRequestBody {
}
type DeleteKnowledgeBaseInput = DeleteKnowledgeBaseRequestBody & DeleteKnowledgeBaseRequestHeaders & DeleteKnowledgeBaseRequestQuery & DeleteKnowledgeBaseRequestParams;
interface DeleteKnowledgeBaseResponse {
}

interface UpdateKnowledgeBaseRequestHeaders {
}
interface UpdateKnowledgeBaseRequestQuery {
}
interface UpdateKnowledgeBaseRequestParams {
    id: string;
}
interface UpdateKnowledgeBaseRequestBody {
    /**
     * New name of the knowledge base.
     */
    name: string;
    /**
     * The knowledge base tags to update as an object of key-value pairs with `string` (text) values. Omit to keep existing tags intact. Any existing tags not included will be preserved. New tags will be added. To delete a tag, set its value to `null`.
     */
    tags?: {
        [k: string]: string | null;
    };
}
type UpdateKnowledgeBaseInput = UpdateKnowledgeBaseRequestBody & UpdateKnowledgeBaseRequestHeaders & UpdateKnowledgeBaseRequestQuery & UpdateKnowledgeBaseRequestParams;
interface UpdateKnowledgeBaseResponse {
    knowledgeBase: {
        /**
         * Knowledge base ID
         */
        id: string;
        /**
         * Name of the knowledge base.
         */
        name: string;
        tags: {
            [k: string]: string;
        };
    };
}

interface ListKnowledgeBasesRequestHeaders {
}
interface ListKnowledgeBasesRequestQuery {
    nextToken?: string;
    tags?: any;
}
interface ListKnowledgeBasesRequestParams {
}
interface ListKnowledgeBasesRequestBody {
}
type ListKnowledgeBasesInput = ListKnowledgeBasesRequestBody & ListKnowledgeBasesRequestHeaders & ListKnowledgeBasesRequestQuery & ListKnowledgeBasesRequestParams;
interface ListKnowledgeBasesResponse {
    knowledgeBases: {
        /**
         * Knowledge base ID
         */
        id: string;
        /**
         * Name of the knowledge base.
         */
        name: string;
        /**
         * Knowledge base creation timestamp in ISO 8601 format
         */
        createdAt: string;
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface ListTablesRequestHeaders {
}
interface ListTablesRequestQuery {
    tags?: {
        [k: string]: string;
    };
}
interface ListTablesRequestParams {
}
interface ListTablesRequestBody {
}
type ListTablesInput = ListTablesRequestBody & ListTablesRequestHeaders & ListTablesRequestQuery & ListTablesRequestParams;
interface ListTablesResponse {
    tables: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    }[];
}

interface GetTableRequestHeaders {
}
interface GetTableRequestQuery {
}
interface GetTableRequestParams {
    table: string;
}
interface GetTableRequestBody {
}
type GetTableInput = GetTableRequestBody & GetTableRequestHeaders & GetTableRequestQuery & GetTableRequestParams;
interface GetTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * The total number of rows present in the table.
     */
    rows: number;
    /**
     * The number of stale rows that are waiting to be processed
     */
    stale: number;
    /**
     * The number of rows that are waiting to be indexed (for search)
     */
    indexing: number;
}

interface GetOrCreateTableRequestHeaders {
}
interface GetOrCreateTableRequestQuery {
}
interface GetOrCreateTableRequestParams {
    table: string;
}
interface GetOrCreateTableRequestBody {
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type GetOrCreateTableInput = GetOrCreateTableRequestBody & GetOrCreateTableRequestHeaders & GetOrCreateTableRequestQuery & GetOrCreateTableRequestParams;
interface GetOrCreateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * Flag indicating if the table was newly created.
     */
    created: boolean;
    /**
     * The total number of rows present in the table.
     */
    rows: number;
    /**
     * The number of stale rows that are waiting to be processed
     */
    stale: number;
    /**
     * The number of rows that are waiting to be indexed (for search)
     */
    indexing: number;
}

interface CreateTableRequestHeaders {
}
interface CreateTableRequestQuery {
}
interface CreateTableRequestParams {
}
interface CreateTableRequestBody {
    /**
     * Required. This name is used to identify your table.
     */
    name: string;
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type CreateTableInput = CreateTableRequestBody & CreateTableRequestHeaders & CreateTableRequestQuery & CreateTableRequestParams;
interface CreateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
}

interface DuplicateTableRequestHeaders {
}
interface DuplicateTableRequestQuery {
}
interface DuplicateTableRequestParams {
    sourceTableId: string;
}
interface DuplicateTableRequestBody {
    tableName?: string;
    /**
     * Only duplicate the schema, not the content
     */
    schemaOnly?: boolean;
    /**
     * Use a different factor for the table. Leave empty to use the same as the duplicated table.
     */
    factor?: number;
}
type DuplicateTableInput = DuplicateTableRequestBody & DuplicateTableRequestHeaders & DuplicateTableRequestQuery & DuplicateTableRequestParams;
interface DuplicateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * The total number of rows present in the table.
     */
    rows: number;
}

interface ExportTableRequestHeaders {
}
interface ExportTableRequestQuery {
    format?: "csv" | "json";
    compress?: boolean;
}
interface ExportTableRequestParams {
    table: string;
}
interface ExportTableRequestBody {
}
type ExportTableInput = ExportTableRequestBody & ExportTableRequestHeaders & ExportTableRequestQuery & ExportTableRequestParams;
interface ExportTableResponse {
    job: {
        id: string;
        botId: string;
        tableId: string;
        type: "export" | "import";
        status: "pending" | "in_progress" | "finalizing" | "completed" | "failed";
        progress?: number;
        inputFileId: string | null;
        outputFileId: string | null;
        createdAt: string;
        updatedAt: string;
    };
}

interface GetTableJobsRequestHeaders {
}
interface GetTableJobsRequestQuery {
}
interface GetTableJobsRequestParams {
    table: string;
}
interface GetTableJobsRequestBody {
}
type GetTableJobsInput = GetTableJobsRequestBody & GetTableJobsRequestHeaders & GetTableJobsRequestQuery & GetTableJobsRequestParams;
interface GetTableJobsResponse {
    jobs: {
        id: string;
        botId: string;
        tableId: string;
        type: "export" | "import";
        status: "pending" | "in_progress" | "finalizing" | "completed" | "failed";
        progress?: number;
        inputFileId: string | null;
        outputFileId: string | null;
        createdAt: string;
        updatedAt: string;
    }[];
}

interface ImportTableRequestHeaders {
}
interface ImportTableRequestQuery {
}
interface ImportTableRequestParams {
    table: string;
}
interface ImportTableRequestBody {
    /**
     * The file ID to import. It must have been uploaded to the Files API before. Supported formats: CSV, JSON (gzipped or not)
     */
    fileId: string;
}
type ImportTableInput = ImportTableRequestBody & ImportTableRequestHeaders & ImportTableRequestQuery & ImportTableRequestParams;
interface ImportTableResponse {
    job: {
        id: string;
        botId: string;
        tableId: string;
        type: "export" | "import";
        status: "pending" | "in_progress" | "finalizing" | "completed" | "failed";
        progress?: number;
        inputFileId: string | null;
        outputFileId: string | null;
        createdAt: string;
        updatedAt: string;
    };
}

interface UpdateTableRequestHeaders {
}
interface UpdateTableRequestQuery {
}
interface UpdateTableRequestParams {
    table: string;
}
interface UpdateTableRequestBody {
    /**
     * Required. This name is used to identify your table.
     */
    name?: string;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema?: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type UpdateTableInput = UpdateTableRequestBody & UpdateTableRequestHeaders & UpdateTableRequestQuery & UpdateTableRequestParams;
interface UpdateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * List of columns that have become stale following the modification.
     */
    staleColumns?: string[];
}

interface RenameTableColumnRequestHeaders {
}
interface RenameTableColumnRequestQuery {
}
interface RenameTableColumnRequestParams {
    table: string;
}
interface RenameTableColumnRequestBody {
    /**
     * The existing name of the column.
     */
    name: string;
    /**
     * The new name to assign to the column.
     */
    newName: string;
}
type RenameTableColumnInput = RenameTableColumnRequestBody & RenameTableColumnRequestHeaders & RenameTableColumnRequestQuery & RenameTableColumnRequestParams;
interface RenameTableColumnResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema?: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
}

interface DeleteTableRequestHeaders {
}
interface DeleteTableRequestQuery {
}
interface DeleteTableRequestParams {
    table: string;
}
interface DeleteTableRequestBody {
}
type DeleteTableInput = DeleteTableRequestBody & DeleteTableRequestHeaders & DeleteTableRequestQuery & DeleteTableRequestParams;
interface DeleteTableResponse {
}

interface GetTableRowRequestHeaders {
}
interface GetTableRowRequestQuery {
    id: number;
}
interface GetTableRowRequestParams {
    table: string;
}
interface GetTableRowRequestBody {
}
type GetTableRowInput = GetTableRowRequestBody & GetTableRowRequestHeaders & GetTableRowRequestQuery & GetTableRowRequestParams;
interface GetTableRowResponse {
    row: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    };
}

interface FindTableRowsRequestHeaders {
}
interface FindTableRowsRequestQuery {
}
interface FindTableRowsRequestParams {
    table: string;
}
interface FindTableRowsRequestBody {
    /**
     * Limit for pagination, specifying the maximum number of rows to return.
     */
    limit?: number;
    /**
     * Offset for pagination, specifying where to start returning rows from.
     */
    offset?: number;
    /**
     * Provide a mongodb-like filter to apply to the query. Example: \{ "name": \{ "$eq": "John" \} \}
     */
    filter?: {
        [k: string]: any;
    };
    /**
     * Group the rows by a specific column and apply aggregations to them. Allowed values: key, avg, max, min, sum, count. Example: \{ "someId": "key", "orders": ["sum", "avg"] \}
     */
    group?: {
        [k: string]: any;
    };
    /**
     * Search term to apply to the row search. When using this parameter, some rows which doesn't match the search term will be returned, use the similarity field to know how much the row matches the search term.
     */
    search?: string;
    /**
     * Specifies the column by which to order the results. By default it is ordered by id. Build-in columns: id, createdAt, updatedAt
     */
    orderBy?: string;
    /**
     * Specifies the direction of sorting, either ascending or descending.
     */
    orderDirection?: "asc" | "desc";
}
type FindTableRowsInput = FindTableRowsRequestBody & FindTableRowsRequestHeaders & FindTableRowsRequestQuery & FindTableRowsRequestParams;
interface FindTableRowsResponse {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Flag indicating if there are more rows to fetch.
     */
    hasMore: boolean;
    offset: number;
    limit: number;
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
}

interface CreateTableRowsRequestHeaders {
}
interface CreateTableRowsRequestQuery {
}
interface CreateTableRowsRequestParams {
    table: string;
}
interface CreateTableRowsRequestBody {
    /**
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        [k: string]: any;
    }[];
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type CreateTableRowsInput = CreateTableRowsRequestBody & CreateTableRowsRequestHeaders & CreateTableRowsRequestQuery & CreateTableRowsRequestParams;
interface CreateTableRowsResponse {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface DeleteTableRowsRequestHeaders {
}
interface DeleteTableRowsRequestQuery {
}
interface DeleteTableRowsRequestParams {
    table: string;
}
interface DeleteTableRowsRequestBody {
    /**
     * @maxItems 1000
     */
    ids?: number[];
    /**
     * Filter to apply when deleting rows. Example: \{ "name": \{ "$eq": "John" \} \}
     */
    filter?: {
        [k: string]: any;
    };
    /**
     * Flag to delete all rows. Use with caution as this action is irreversible.
     */
    deleteAllRows?: boolean;
}
type DeleteTableRowsInput = DeleteTableRowsRequestBody & DeleteTableRowsRequestHeaders & DeleteTableRowsRequestQuery & DeleteTableRowsRequestParams;
interface DeleteTableRowsResponse {
    deletedRows: number;
}

interface UpdateTableRowsRequestHeaders {
}
interface UpdateTableRowsRequestQuery {
}
interface UpdateTableRowsRequestParams {
    table: string;
}
interface UpdateTableRowsRequestBody {
    /**
     * Rows with updated data, identified by ID.
     *
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        id: number;
        [k: string]: any;
    }[];
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type UpdateTableRowsInput = UpdateTableRowsRequestBody & UpdateTableRowsRequestHeaders & UpdateTableRowsRequestQuery & UpdateTableRowsRequestParams;
interface UpdateTableRowsResponse {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface UpsertTableRowsRequestHeaders {
}
interface UpsertTableRowsRequestQuery {
}
interface UpsertTableRowsRequestParams {
    table: string;
}
interface UpsertTableRowsRequestBody {
    /**
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        id?: number;
        [k: string]: any;
    }[];
    /**
     * Determines if a row is inserted or updated. Defaults to "id".
     */
    keyColumn?: string;
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type UpsertTableRowsInput = UpsertTableRowsRequestBody & UpsertTableRowsRequestHeaders & UpsertTableRowsRequestQuery & UpsertTableRowsRequestParams;
interface UpsertTableRowsResponse {
    inserted: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    updated: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface Bot {
    /**
     * Id of the [Bot](#schema_bot)
     */
    id: string;
    /**
     * Creation date of the [Bot](#schema_bot) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Bot](#schema_bot) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Signing secret of the [Bot](#schema_bot)
     */
    signingSecret: string;
    /**
     * A mapping of integrations to their configuration. If the `x-multiple-integrations` header is present, this object is keyed by integration aliases. Otherwise, this object is keyed by integration ids.
     */
    integrations: {
        [k: string]: {
            enabled: boolean;
            /**
             * Name of the [Integration](#schema_integration)
             */
            name: string;
            /**
             * Version of the [Integration](#schema_integration)
             */
            version: string;
            webhookUrl: string;
            webhookId: string;
            identifier?: string;
            configurationType: string | null;
            configuration: {
                [k: string]: any;
            };
            status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
            statusReason: string | null;
            /**
             * Disabled channels for this integration
             */
            disabledChannels: string[];
            /**
             * ID of the [Integration](#schema_integration)
             */
            id: string;
            /**
             * Creation date of the [Integration](#schema_integration) in ISO 8601 format
             */
            createdAt: string;
            /**
             * Updating date of the [Integration](#schema_integration) in ISO 8601 format
             */
            updatedAt: string;
            /**
             * Title of the integration. This is the name that will be displayed in the UI
             */
            title: string;
            /**
             * Description of the integration. This is the description that will be displayed in the UI
             */
            description: string;
            /**
             * URL of the icon of the integration. This is the icon that will be displayed in the UI
             */
            iconUrl: string;
            /**
             * @deprecated
             * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
             */
            public: boolean;
            /**
             * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
             */
            visibility: "public" | "private" | "unlisted";
            /**
             * Status of the integration version verification
             */
            verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        };
    };
    /**
     * A mapping of plugin aliases to their configuration
     */
    plugins: {
        [k: string]: {
            enabled: boolean;
            /**
             * Name of the [Plugin](#schema_plugin)
             */
            name: string;
            /**
             * Version of the [Plugin](#schema_plugin)
             */
            version: string;
            configuration: {
                [k: string]: any;
            };
            /**
             * A mapping of plugin interface aliases to their backing integrations
             */
            interfaces?: {
                [k: string]: {
                    integrationId: string;
                    interfaceId: string;
                };
            };
            /**
             * ID of the [Plugin](#schema_plugin)
             */
            id: string;
            /**
             * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
             */
            createdAt: string;
            /**
             * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
             */
            updatedAt: string;
            /**
             * Title of the plugin. This is the name that will be displayed in the UI
             */
            title: string;
            /**
             * Description of the plugin. This is the description that will be displayed in the UI
             */
            description: string;
            /**
             * URL of the icon of the plugin. This is the icon that will be displayed in the UI
             */
            iconUrl: string;
            /**
             * URL of the readme of the plugin. This is the readme that will be displayed in the UI
             */
            readmeUrl: string;
            /**
             * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
             */
            public: boolean;
        };
    };
    /**
     * Maximum execution time of the bot (in seconds).
     */
    maxExecutionTime?: number;
    /**
     * User object configuration
     */
    user: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Conversation object configuration
     */
    conversation: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Message object configuration
     */
    message: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * A mapping of states to their definition
     */
    states: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    /**
     * Configuration of the bot
     */
    configuration: {
        /**
         * Configuration data
         */
        data: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    };
    /**
     * Events definition
     */
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    /**
     * Recurring events
     */
    recurringEvents: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
            /**
             * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
             */
            failedAttempts: number;
            /**
             * The reason why the recurring event failed to run in the last attempt.
             */
            lastFailureReason: string | null;
        };
    };
    /**
     * Subscriptions of the bot
     */
    subscriptions: {
        /**
         * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
         */
        events: {
            [k: string]: {};
        } | null;
    };
    /**
     * Actions definition
     */
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    /**
     * Tags of [Bot](#schema_bot)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Name of the [Bot](#schema_bot)
     */
    name: string;
    /**
     * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
     */
    deployedAt?: string;
    /**
     * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
     */
    dev: boolean;
    /**
     * Id of the user that created the bot
     */
    createdBy?: string;
    /**
     * Indicates if the [Bot](#schema_bot) should be in always alive mode
     */
    alwaysAlive: boolean;
    /**
     * Status of the bot
     */
    status: "active" | "deploying";
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias: {
        /**
         * URL of the media file
         */
        url: string;
        /**
         * Name of the media file
         */
        name: string;
    }[];
}
interface Integration {
    /**
     * ID of the [Integration](#schema_integration)
     */
    id: string;
    /**
     * Creation date of the [Integration](#schema_integration) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Integration](#schema_integration) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Global identifier configuration of the [Integration](#schema_integration)
     */
    identifier: {
        /**
         * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
         */
        fallbackHandlerScript?: string;
        /**
         * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
         */
        extractScript?: string;
    };
    sandbox?: {
        /**
         * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox
         */
        identifierExtractScript?: string;
        /**
         * VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox
         */
        messageExtractScript?: string;
    };
    /**
     * Maximum execution time of the integration (in seconds).
     */
    maxExecutionTime?: number;
    /**
     * URL of the [Integration](#schema_integration)
     */
    url: string;
    /**
     * Name of the [Integration](#schema_integration)
     */
    name: string;
    /**
     * Version of the [Integration](#schema_integration)
     */
    version: string;
    interfaces: {
        [k: string]: {
            /**
             * ID of the interface
             */
            id: string;
            /**
             * Name of the interface
             */
            name: string;
            /**
             * Version of the interface
             */
            version: string;
            entities: {
                [k: string]: {
                    name: string;
                };
            };
            actions: {
                [k: string]: {
                    name: string;
                };
            };
            events: {
                [k: string]: {
                    name: string;
                };
            };
            channels: {
                [k: string]: {
                    name: string;
                };
            };
        };
    };
    /**
     * Configuration definition
     */
    configuration: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            linkTemplateScript?: string;
            required: boolean;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    };
    configurations: {
        /**
         * Configuration definition
         */
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    channels: {
        /**
         * Channel definition
         */
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
            /**
             * Conversation object configuration
             */
            conversation: {
                tags: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
            };
            /**
             * Message object configuration
             */
            message: {
                tags: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
        };
    };
    states: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    /**
     * User object configuration
     */
    user: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
    };
    entities: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    /**
     * Indicates if the integration is a development integration; Dev integrations run locally
     */
    dev: boolean;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description: string;
    /**
     * URL of the icon of the integration. This is the icon that will be displayed in the UI
     */
    iconUrl: string;
    /**
     * URL of the readme of the integration. This is the readme that will be displayed in the UI
     */
    readmeUrl: string;
    /**
     * @deprecated
     * [DEPRECATED] Indicates whether the integration is public. Please use the "visibility" parameter instead.
     */
    public: boolean;
    /**
     * The integration's visibility. Public integrations are available to all and cannot be updated without creating a new version. Unlisted integrations behave identically to public integrations, but they are not listed in the integration hub. By default, integrations are private and only accessible to the workspace that created them.
     */
    visibility: "public" | "private" | "unlisted";
    /**
     * Status of the integration version verification
     */
    verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets: string[];
}
interface Interface {
    /**
     * ID of the [Interface](#schema_interface)
     */
    id: string;
    /**
     * Creation date of the [Interface](#schema_interface) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Interface](#schema_interface) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Name of the [Interface](#schema_interface)
     */
    name: string;
    /**
     * Version of the [Interface](#schema_interface)
     */
    version: string;
    entities: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    channels: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    /**
     * Title of the interface. This is the name that will be displayed in the UI
     */
    title: string;
    /**
     * Description of the interface. This is the description that will be displayed in the UI
     */
    description: string;
    /**
     * URL of the icon of the interface. This is the icon that will be displayed in the UI
     */
    iconUrl: string;
    /**
     * URL of the readme of the interface. This is the readme that will be displayed in the UI
     */
    readmeUrl: string;
    /**
     * Indicates if the interface is public. Public interfaces are available to all and cannot be updated without creating a new version.
     */
    public: boolean;
}
interface Plugin {
    /**
     * ID of the [Plugin](#schema_plugin)
     */
    id: string;
    /**
     * Name of the [Plugin](#schema_plugin)
     */
    name: string;
    /**
     * Version of the [Plugin](#schema_plugin)
     */
    version: string;
    /**
     * Creation date of the [Plugin](#schema_plugin) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Plugin](#schema_plugin) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Configuration definition
     */
    configuration: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    };
    states: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
            /**
             * Optional attributes
             */
            attributes?: {
                [k: string]: string;
            };
        };
    };
    dependencies: {
        interfaces: {
            [k: string]: {
                id: string;
                name: string;
                version: string;
            };
        };
        integrations: {
            [k: string]: {
                id: string;
                name: string;
                version: string;
            };
        };
    };
    /**
     * User object configuration
     */
    user: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Conversation object configuration
     */
    conversation: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Optional attributes
     */
    attributes?: {
        [k: string]: string;
    };
    /**
     * Title of the plugin. This is the name that will be displayed in the UI
     */
    title: string;
    /**
     * Description of the plugin. This is the description that will be displayed in the UI
     */
    description: string;
    /**
     * URL of the icon of the plugin. This is the icon that will be displayed in the UI
     */
    iconUrl: string;
    /**
     * URL of the readme of the plugin. This is the readme that will be displayed in the UI
     */
    readmeUrl: string;
    /**
     * Indicates if the plugin is public. Public plugins are available to all and cannot be updated without creating a new version.
     */
    public: boolean;
}
interface Workspace {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2" | "v3";
    plan: "community" | "team" | "enterprise" | "plus";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}
interface WorkspaceMember {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}
interface Account {
    id: string;
    email: string;
    displayName?: string;
    emailVerified: boolean;
    profilePicture?: string;
    /**
     * Creation date of the [Account](#schema_account) in ISO 8601 format
     */
    createdAt: string;
}
interface Usage {
    /**
     * Id of the usage that it is linked to. It can either be a workspace id or a bot id
     */
    id: string;
    /**
     * Period of the quota that it is applied to
     */
    period: string;
    /**
     * Value of the current usage
     */
    value: number;
    /**
     * Quota of the current usage
     */
    quota: number;
    /**
     * Usage type that can be used
     */
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
}
interface Issue {
    id: string;
    code: string;
    createdAt: string;
    lastSeenAt: string;
    title: string;
    description: string;
    groupedData: {
        [k: string]: {
            raw: string;
            pretty?: string;
        };
    };
    eventsCount: number;
    category: "user_code" | "limits" | "configuration" | "other";
    resolutionLink: string | null;
}
interface IssueEvent {
    id: string;
    createdAt: string;
    data: {
        [k: string]: {
            raw: string;
            pretty?: string;
        };
    };
}
interface Activity {
    id: string;
    description: string;
    taskId: string;
    category: "unknown" | "capture" | "bot_message" | "user_message" | "agent_message" | "event" | "action" | "task_status" | "subtask_status" | "exception";
    data: {
        [k: string]: any;
    };
    /**
     * Creation date of the activity in ISO 8601 format
     */
    createdAt: string;
}
interface Version {
    id: string;
    name: string;
    description?: string;
}
/**
 * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
 */
interface User {
    /**
     * Id of the [User](#schema_user)
     */
    id: string;
    /**
     * Creation date of the [User](#schema_user) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [User](#schema_user) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Name of the [User](#schema_user)
     */
    name?: string;
    /**
     * Picture URL of the [User](#schema_user)
     */
    pictureUrl?: string;
}
/**
 * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
 */
interface Conversation {
    /**
     * Id of the [Conversation](#schema_conversation)
     */
    id: string;
    /**
     * Id of the current [Task](#schema_task)
     */
    currentTaskId?: string;
    /**
     * Id of the current [Workflow](#schema_workflow)
     */
    currentWorkflowId?: string;
    /**
     * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Name of the channel where the [Conversation](#schema_conversation) is happening
     */
    channel: string;
    /**
     * Name of the integration that created the [Conversation](#schema_conversation)
     */
    integration: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
}
/**
 * The event object represents an action or an occurrence.
 */
interface Event {
    /**
     * Id of the [Event](#schema_event)
     */
    id: string;
    /**
     * Creation date of the [Event](#schema_event) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Type of the [Event](#schema_event).
     */
    type: string;
    /**
     * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [Conversation](#schema_conversation) to link the event to.
     */
    conversationId?: string;
    /**
     * ID of the [User](#schema_user) to link the event to.
     */
    userId?: string;
    /**
     * ID of the [Message](#schema_message) to link the event to.
     */
    messageId?: string;
    status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
    /**
     * Reason why the event failed to be processed
     */
    failureReason: string | null;
}
/**
 * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
 */
interface Message {
    /**
     * Id of the [Message](#schema_message)
     */
    id: string;
    /**
     * Creation date of the [Message](#schema_message) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Update date of the [Message](#schema_message) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Direction of the message (`incoming` or `outgoing`).
     */
    direction: "incoming" | "outgoing";
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Origin of the message (`synthetic`).
     */
    origin?: "synthetic";
}
/**
 * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
 */
interface State {
    /**
     * Id of the [State](#schema_state)
     */
    id: string;
    /**
     * Creation date of the [State](#schema_state) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [State](#schema_state) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Id of the [Bot](#schema_bot)
     */
    botId: string;
    /**
     * Id of the [Conversation](#schema_conversation)
     */
    conversationId?: string;
    /**
     * Id of the [User](#schema_user)
     */
    userId?: string;
    /**
     * Name of the [State](#schema_state) which is declared inside the bot definition
     */
    name: string;
    /**
     * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
     */
    type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
}
/**
 * Task definition
 */
interface Task {
    /**
     * Id of the [Task](#schema_task)
     */
    id: string;
    /**
     * Title describing the task
     */
    title: string;
    /**
     * All the notes related to the execution of the current task
     */
    description: string;
    /**
     * Type of the task
     */
    type: string;
    /**
     * Content related to the task
     */
    data: {
        [k: string]: any;
    };
    /**
     * Status of the task
     */
    status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
    /**
     * Parent task id is the parent task that created this task
     */
    parentTaskId?: string;
    /**
     * Conversation id related to this task
     */
    conversationId?: string;
    /**
     * Specific user related to this task
     */
    userId?: string;
    /**
     * The timeout date where the task should be failed in the ISO 8601 format
     */
    timeoutAt: string;
    /**
     * Creation date of the task in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the task in ISO 8601 format
     */
    updatedAt: string;
    /**
     * If the task fails this is the reason behind it
     */
    failureReason?: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
}
/**
 * Workflow definition
 */
interface Workflow {
    /**
     * Id of the [Workflow](#schema_workflow)
     */
    id: string;
    /**
     * Name of the workflow
     */
    name: string;
    /**
     * Status of the [Workflow](#schema_workflow)
     */
    status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
    /**
     * Input provided to the [Workflow](#schema_workflow)
     */
    input: {
        [k: string]: any;
    };
    /**
     * Data returned by the [Workflow](#schema_workflow) output
     */
    output: {
        [k: string]: any;
    };
    /**
     * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
     */
    parentWorkflowId?: string;
    /**
     * Conversation id related to this [Workflow](#schema_workflow)
     */
    conversationId?: string;
    /**
     * User id related to this [Workflow](#schema_workflow)
     */
    userId?: string;
    /**
     * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
     */
    completedAt?: string;
    /**
     * If the [Workflow](#schema_workflow) fails this is the reason behind it
     */
    failureReason?: string;
    /**
     * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
     */
    timeoutAt: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
}
interface Table {
    /**
     * Unique identifier for the table
     */
    id: string;
    /**
     * Required. This name is used to identify your table.
     */
    name: string;
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    schema: {
        $schema?: string;
        /**
         * List of keys/columns in the table.
         */
        properties: {
            [k: string]: {
                type: "string" | "number" | "boolean" | "object" | "array" | "null";
                format?: "date-time";
                description?: string;
                /**
                 * String properties must match this pattern
                 */
                pattern?: string;
                /**
                 * String properties must be one of these values
                 */
                enum?: string[];
                /**
                 * Defines the shape of items in an array
                 */
                items?: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    [k: string]: any;
                };
                nullable?: boolean;
                properties?: {
                    [k: string]: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                };
                "x-zui": {
                    index: number;
                    /**
                     * [deprecated] ID of the column.
                     */
                    id?: string;
                    /**
                     * Indicates if the column is vectorized and searchable.
                     */
                    searchable?: boolean;
                    /**
                     * Indicates if the field is hidden in the UI
                     */
                    hidden?: boolean;
                    /**
                     * Order of the column in the UI
                     */
                    order?: number;
                    /**
                     * Width of the column in the UI
                     */
                    width?: number;
                    /**
                     * ID of the schema
                     */
                    schemaId?: string;
                    computed?: {
                        action: "ai" | "code" | "workflow";
                        dependencies?: string[];
                        /**
                         * Prompt when action is "ai"
                         */
                        prompt?: string;
                        /**
                         * Code to execute when action is "code"
                         */
                        code?: string;
                        /**
                         * Model to use when action is "ai"
                         */
                        model?: string;
                        /**
                         * ID of Workflow to execute when action is "workflow"
                         */
                        workflowId?: string;
                        enabled?: boolean;
                    };
                    /**
                     * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                     */
                    typings?: string;
                };
            };
        };
        /**
         * Additional properties can be provided, but they will be ignored if no column matches.
         */
        additionalProperties: true;
        /**
         * Array of required properties.
         */
        required?: string[];
        type: "object";
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
    /**
     * Timestamp of table creation.
     */
    createdAt?: string;
    /**
     * Timestamp of the last table update.
     */
    updatedAt?: string;
}
interface Column {
    /**
     * Unique identifier for the column.
     */
    id?: string;
    /**
     * Name of the column, must be within length limits.
     */
    name: string;
    /**
     * Optional descriptive text about the column.
     */
    description?: string;
    /**
     * Indicates if the column is vectorized and searchable.
     */
    searchable?: boolean;
    /**
     * Specifies the data type of the column. Use "object" for complex data structures.
     */
    type: "string" | "number" | "boolean" | "date" | "object";
    /**
     * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
     */
    typings?: string;
    computed?: {
        action: "ai" | "code" | "workflow";
        dependencies?: string[];
        /**
         * Prompt when action is "ai"
         */
        prompt?: string;
        /**
         * Code to execute when action is "code"
         */
        code?: string;
        /**
         * Model to use when action is "ai"
         */
        model?: string;
        /**
         * ID of Workflow to execute when action is "workflow"
         */
        workflowId?: string;
        enabled?: boolean;
    };
    schema?: {
        [k: string]: any;
    };
}
interface Row {
    /**
     * Unique identifier for the row.
     */
    id: number;
    /**
     * Timestamp of row creation.
     */
    createdAt?: string;
    /**
     * Timestamp of the last row update.
     */
    updatedAt?: string;
    computed: {
        [k: string]: {
            status: string;
            error?: string;
            updatedBy?: string;
            updatedAt?: string;
        };
    };
    /**
     * [Read-only] List of stale values that are waiting to be recomputed.
     */
    stale?: string[];
    /**
     * Optional numeric value indicating similarity, when using findTableRows.
     */
    similarity?: number;
    [k: string]: any;
}
interface File {
    /**
     * File ID
     */
    id: string;
    /**
     * The ID of the bot the file belongs to
     */
    botId: string;
    /**
     * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
     */
    key: string;
    /**
     * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
     *
     * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
     */
    url: string;
    /**
     * File size in bytes. Non-null if file upload status is "COMPLETE".
     */
    size: number | null;
    /**
     * MIME type of the file's content
     */
    contentType: string;
    /**
     * The tags of the file as an object of key/value pairs
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Metadata of the file as an object of key/value pairs. The values can be of any type.
     */
    metadata: {
        [k: string]: any;
    };
    /**
     * File creation timestamp in ISO 8601 format
     */
    createdAt: string;
    /**
     * File last update timestamp in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Access policies configured for the file.
     */
    accessPolicies: ("integrations" | "public_content")[];
    /**
     * Whether the file was requested to be indexed for search or not.
     */
    index: boolean;
    /**
     * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
     *
     * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
     *
     * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
     *
     * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
     */
    status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
    /**
     * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
     */
    failedStatusReason?: string;
    /**
     * File expiry timestamp in ISO 8601 format
     */
    expiresAt?: string;
    owner: {
        type: "bot" | "integration" | "user";
        /**
         * This field is present if `type` is "user" or "bot". If `type` is "user", this is the user ID. If `type` is "bot", this is the bot ID.
         */
        id?: string;
        /**
         * This field is present if the `type` is "integration". If `type` is "integration", this is the integration name.
         */
        name?: string;
    };
    /**
     * Indicates the indexing stack used to index this file. Present only when file has been successfully indexed. A value of "v2" denotes the latest stack, "v1" denotes the legacy stack.
     */
    indexingStack?: "v1" | "v2";
}

type ClientProps$1 = {
    toAxiosRequest: typeof toAxiosRequest;
    toApiError: typeof toApiError;
};
declare class Client$1 {
    private axiosInstance;
    private props;
    constructor(axiosInstance: AxiosInstance, props?: Partial<ClientProps$1>);
    readonly createConversation: (input: CreateConversationInput) => Promise<CreateConversationResponse>;
    readonly getConversation: (input: GetConversationInput) => Promise<GetConversationResponse>;
    readonly listConversations: (input: ListConversationsInput) => Promise<ListConversationsResponse>;
    readonly getOrCreateConversation: (input: GetOrCreateConversationInput) => Promise<GetOrCreateConversationResponse>;
    readonly updateConversation: (input: UpdateConversationInput) => Promise<UpdateConversationResponse>;
    readonly deleteConversation: (input: DeleteConversationInput) => Promise<DeleteConversationResponse>;
    readonly listParticipants: (input: ListParticipantsInput) => Promise<ListParticipantsResponse>;
    readonly addParticipant: (input: AddParticipantInput) => Promise<AddParticipantResponse>;
    readonly getParticipant: (input: GetParticipantInput) => Promise<GetParticipantResponse>;
    readonly removeParticipant: (input: RemoveParticipantInput) => Promise<RemoveParticipantResponse>;
    readonly createEvent: (input: CreateEventInput) => Promise<CreateEventResponse>;
    readonly getEvent: (input: GetEventInput) => Promise<GetEventResponse>;
    readonly listEvents: (input: ListEventsInput) => Promise<ListEventsResponse>;
    readonly createMessage: (input: CreateMessageInput) => Promise<CreateMessageResponse>;
    readonly getOrCreateMessage: (input: GetOrCreateMessageInput) => Promise<GetOrCreateMessageResponse>;
    readonly getMessage: (input: GetMessageInput) => Promise<GetMessageResponse>;
    readonly updateMessage: (input: UpdateMessageInput) => Promise<UpdateMessageResponse>;
    readonly listMessages: (input: ListMessagesInput) => Promise<ListMessagesResponse>;
    readonly deleteMessage: (input: DeleteMessageInput) => Promise<DeleteMessageResponse>;
    readonly createUser: (input: CreateUserInput) => Promise<CreateUserResponse>;
    readonly getUser: (input: GetUserInput) => Promise<GetUserResponse>;
    readonly listUsers: (input: ListUsersInput) => Promise<ListUsersResponse>;
    readonly getOrCreateUser: (input: GetOrCreateUserInput) => Promise<GetOrCreateUserResponse>;
    readonly updateUser: (input: UpdateUserInput) => Promise<UpdateUserResponse>;
    readonly deleteUser: (input: DeleteUserInput) => Promise<DeleteUserResponse>;
    readonly setStateExpiry: (input: SetStateExpiryInput) => Promise<SetStateExpiryResponse>;
    readonly getState: (input: GetStateInput) => Promise<GetStateResponse>;
    readonly setState: (input: SetStateInput) => Promise<SetStateResponse>;
    readonly getOrSetState: (input: GetOrSetStateInput) => Promise<GetOrSetStateResponse>;
    readonly patchState: (input: PatchStateInput) => Promise<PatchStateResponse>;
    readonly callAction: (input: CallActionInput) => Promise<CallActionResponse>;
    readonly configureIntegration: (input: ConfigureIntegrationInput) => Promise<ConfigureIntegrationResponse>;
    readonly getTask: (input: GetTaskInput) => Promise<GetTaskResponse>;
    readonly createTask: (input: CreateTaskInput) => Promise<CreateTaskResponse>;
    readonly updateTask: (input: UpdateTaskInput) => Promise<UpdateTaskResponse>;
    readonly deleteTask: (input: DeleteTaskInput) => Promise<DeleteTaskResponse>;
    readonly listTasks: (input: ListTasksInput) => Promise<ListTasksResponse>;
    readonly createWorkflow: (input: CreateWorkflowInput) => Promise<CreateWorkflowResponse>;
    readonly getWorkflow: (input: GetWorkflowInput) => Promise<GetWorkflowResponse>;
    readonly updateWorkflow: (input: UpdateWorkflowInput) => Promise<UpdateWorkflowResponse>;
    readonly deleteWorkflow: (input: DeleteWorkflowInput) => Promise<DeleteWorkflowResponse>;
    readonly listWorkflows: (input: ListWorkflowsInput) => Promise<ListWorkflowsResponse>;
    readonly getOrCreateWorkflow: (input: GetOrCreateWorkflowInput) => Promise<GetOrCreateWorkflowResponse>;
    readonly listTagValues: (input: ListTagValuesInput) => Promise<ListTagValuesResponse>;
    readonly trackAnalytics: (input: TrackAnalyticsInput) => Promise<TrackAnalyticsResponse>;
    readonly runVrl: (input: RunVrlInput) => Promise<RunVrlResponse>;
    readonly getAccount: (input: GetAccountInput) => Promise<GetAccountResponse>;
    readonly updateAccount: (input: UpdateAccountInput) => Promise<UpdateAccountResponse>;
    readonly deleteAccount: (input: DeleteAccountInput) => Promise<DeleteAccountResponse>;
    readonly listPersonalAccessTokens: (input: ListPersonalAccessTokensInput) => Promise<ListPersonalAccessTokensResponse>;
    readonly createPersonalAccessToken: (input: CreatePersonalAccessTokenInput) => Promise<CreatePersonalAccessTokenResponse>;
    readonly deletePersonalAccessToken: (input: DeletePersonalAccessTokenInput) => Promise<DeletePersonalAccessTokenResponse>;
    readonly setAccountPreference: (input: SetAccountPreferenceInput) => Promise<SetAccountPreferenceResponse>;
    readonly getAccountPreference: (input: GetAccountPreferenceInput) => Promise<GetAccountPreferenceResponse>;
    readonly listPublicIntegrations: (input: ListPublicIntegrationsInput) => Promise<ListPublicIntegrationsResponse>;
    readonly getPublicIntegrationById: (input: GetPublicIntegrationByIdInput) => Promise<GetPublicIntegrationByIdResponse>;
    readonly getPublicIntegration: (input: GetPublicIntegrationInput) => Promise<GetPublicIntegrationResponse>;
    readonly listPublicPlugins: (input: ListPublicPluginsInput) => Promise<ListPublicPluginsResponse>;
    readonly getPublicPluginById: (input: GetPublicPluginByIdInput) => Promise<GetPublicPluginByIdResponse>;
    readonly getDereferencedPublicPluginById: (input: GetDereferencedPublicPluginByIdInput) => Promise<GetDereferencedPublicPluginByIdResponse>;
    readonly getPublicPlugin: (input: GetPublicPluginInput) => Promise<GetPublicPluginResponse>;
    readonly getPublicPluginCode: (input: GetPublicPluginCodeInput) => Promise<GetPublicPluginCodeResponse>;
    readonly listPublicInterfaces: (input: ListPublicInterfacesInput) => Promise<ListPublicInterfacesResponse>;
    readonly getPublicInterfaceById: (input: GetPublicInterfaceByIdInput) => Promise<GetPublicInterfaceByIdResponse>;
    readonly getPublicInterface: (input: GetPublicInterfaceInput) => Promise<GetPublicInterfaceResponse>;
    readonly createBot: (input: CreateBotInput) => Promise<CreateBotResponse>;
    readonly updateBot: (input: UpdateBotInput) => Promise<UpdateBotResponse>;
    readonly transferBot: (input: TransferBotInput) => Promise<TransferBotResponse>;
    readonly listBots: (input: ListBotsInput) => Promise<ListBotsResponse>;
    readonly getBot: (input: GetBotInput) => Promise<GetBotResponse>;
    readonly deleteBot: (input: DeleteBotInput) => Promise<DeleteBotResponse>;
    readonly getBotLogs: (input: GetBotLogsInput) => Promise<GetBotLogsResponse>;
    readonly getBotWebchat: (input: GetBotWebchatInput) => Promise<GetBotWebchatResponse>;
    readonly getBotAnalytics: (input: GetBotAnalyticsInput) => Promise<GetBotAnalyticsResponse>;
    readonly listActionRuns: (input: ListActionRunsInput) => Promise<ListActionRunsResponse>;
    readonly getBotIssue: (input: GetBotIssueInput) => Promise<GetBotIssueResponse>;
    readonly listBotIssues: (input: ListBotIssuesInput) => Promise<ListBotIssuesResponse>;
    readonly deleteBotIssue: (input: DeleteBotIssueInput) => Promise<DeleteBotIssueResponse>;
    readonly listBotIssueEvents: (input: ListBotIssueEventsInput) => Promise<ListBotIssueEventsResponse>;
    readonly listBotVersions: (input: ListBotVersionsInput) => Promise<ListBotVersionsResponse>;
    readonly getBotVersion: (input: GetBotVersionInput) => Promise<GetBotVersionResponse>;
    readonly getBotJson: (input: GetBotJsonInput) => Promise<GetBotJsonResponse>;
    readonly publishFromBotJson: (input: PublishFromBotJsonInput) => Promise<PublishFromBotJsonResponse>;
    readonly createBotVersion: (input: CreateBotVersionInput) => Promise<CreateBotVersionResponse>;
    readonly deployBotVersion: (input: DeployBotVersionInput) => Promise<DeployBotVersionResponse>;
    readonly createIntegrationShareableId: (input: CreateIntegrationShareableIdInput) => Promise<CreateIntegrationShareableIdResponse>;
    readonly deleteIntegrationShareableId: (input: DeleteIntegrationShareableIdInput) => Promise<DeleteIntegrationShareableIdResponse>;
    readonly getIntegrationShareableId: (input: GetIntegrationShareableIdInput) => Promise<GetIntegrationShareableIdResponse>;
    readonly unlinkSandboxedConversations: (input: UnlinkSandboxedConversationsInput) => Promise<UnlinkSandboxedConversationsResponse>;
    readonly listBotApiKeys: (input: ListBotApiKeysInput) => Promise<ListBotApiKeysResponse>;
    readonly createBotApiKey: (input: CreateBotApiKeyInput) => Promise<CreateBotApiKeyResponse>;
    readonly deleteBotApiKey: (input: DeleteBotApiKeyInput) => Promise<DeleteBotApiKeyResponse>;
    readonly getBotAllowlist: (input: GetBotAllowlistInput) => Promise<GetBotAllowlistResponse>;
    readonly updateBotAllowlist: (input: UpdateBotAllowlistInput) => Promise<UpdateBotAllowlistResponse>;
    readonly listWorkspaceInvoices: (input: ListWorkspaceInvoicesInput) => Promise<ListWorkspaceInvoicesResponse>;
    readonly getUpcomingInvoice: (input: GetUpcomingInvoiceInput) => Promise<GetUpcomingInvoiceResponse>;
    readonly chargeWorkspaceUnpaidInvoices: (input: ChargeWorkspaceUnpaidInvoicesInput) => Promise<ChargeWorkspaceUnpaidInvoicesResponse>;
    readonly createWorkspace: (input: CreateWorkspaceInput) => Promise<CreateWorkspaceResponse>;
    readonly getPublicWorkspace: (input: GetPublicWorkspaceInput) => Promise<GetPublicWorkspaceResponse$1>;
    readonly getWorkspace: (input: GetWorkspaceInput) => Promise<GetWorkspaceResponse>;
    readonly listWorkspaceUsages: (input: ListWorkspaceUsagesInput) => Promise<ListWorkspaceUsagesResponse>;
    readonly breakDownWorkspaceUsageByBot: (input: BreakDownWorkspaceUsageByBotInput) => Promise<BreakDownWorkspaceUsageByBotResponse>;
    readonly getAllWorkspaceQuotaCompletion: (input: GetAllWorkspaceQuotaCompletionInput) => Promise<GetAllWorkspaceQuotaCompletionResponse>;
    readonly getWorkspaceQuota: (input: GetWorkspaceQuotaInput) => Promise<GetWorkspaceQuotaResponse>;
    readonly listWorkspaceQuotas: (input: ListWorkspaceQuotasInput) => Promise<ListWorkspaceQuotasResponse>;
    readonly updateWorkspace: (input: UpdateWorkspaceInput) => Promise<UpdateWorkspaceResponse$1>;
    readonly checkHandleAvailability: (input: CheckHandleAvailabilityInput) => Promise<CheckHandleAvailabilityResponse>;
    readonly listWorkspaces: (input: ListWorkspacesInput) => Promise<ListWorkspacesResponse>;
    readonly listPublicWorkspaces: (input: ListPublicWorkspacesInput) => Promise<ListPublicWorkspacesResponse>;
    readonly deleteWorkspace: (input: DeleteWorkspaceInput) => Promise<DeleteWorkspaceResponse>;
    readonly getAuditRecords: (input: GetAuditRecordsInput) => Promise<GetAuditRecordsResponse>;
    readonly setWorkspacePreference: (input: SetWorkspacePreferenceInput) => Promise<SetWorkspacePreferenceResponse>;
    readonly getWorkspacePreference: (input: GetWorkspacePreferenceInput) => Promise<GetWorkspacePreferenceResponse>;
    readonly listWorkspaceMembers: (input: ListWorkspaceMembersInput) => Promise<ListWorkspaceMembersResponse>;
    readonly getWorkspaceMember: (input: GetWorkspaceMemberInput) => Promise<GetWorkspaceMemberResponse>;
    readonly deleteWorkspaceMember: (input: DeleteWorkspaceMemberInput) => Promise<DeleteWorkspaceMemberResponse>;
    readonly createWorkspaceMember: (input: CreateWorkspaceMemberInput) => Promise<CreateWorkspaceMemberResponse>;
    readonly updateWorkspaceMember: (input: UpdateWorkspaceMemberInput) => Promise<UpdateWorkspaceMemberResponse>;
    readonly listIntegrationApiKeys: (input: ListIntegrationApiKeysInput) => Promise<ListIntegrationApiKeysResponse>;
    readonly createIntegrationApiKey: (input: CreateIntegrationApiKeyInput) => Promise<CreateIntegrationApiKeyResponse>;
    readonly deleteIntegrationApiKey: (input: DeleteIntegrationApiKeyInput) => Promise<DeleteIntegrationApiKeyResponse>;
    readonly createIntegration: (input: CreateIntegrationInput) => Promise<CreateIntegrationResponse>;
    readonly validateIntegrationCreation: (input: ValidateIntegrationCreationInput) => Promise<ValidateIntegrationCreationResponse>;
    readonly updateIntegration: (input: UpdateIntegrationInput) => Promise<UpdateIntegrationResponse>;
    readonly validateIntegrationUpdate: (input: ValidateIntegrationUpdateInput) => Promise<ValidateIntegrationUpdateResponse>;
    readonly listIntegrations: (input: ListIntegrationsInput) => Promise<ListIntegrationsResponse>;
    readonly getIntegration: (input: GetIntegrationInput) => Promise<GetIntegrationResponse>;
    readonly getIntegrationLogs: (input: GetIntegrationLogsInput) => Promise<GetIntegrationLogsResponse>;
    readonly getIntegrationByName: (input: GetIntegrationByNameInput) => Promise<GetIntegrationByNameResponse>;
    readonly deleteIntegration: (input: DeleteIntegrationInput) => Promise<DeleteIntegrationResponse>;
    readonly requestIntegrationVerification: (input: RequestIntegrationVerificationInput) => Promise<RequestIntegrationVerificationResponse>;
    readonly createInterface: (input: CreateInterfaceInput) => Promise<CreateInterfaceResponse>;
    readonly getInterface: (input: GetInterfaceInput) => Promise<GetInterfaceResponse>;
    readonly getInterfaceByName: (input: GetInterfaceByNameInput) => Promise<GetInterfaceByNameResponse>;
    readonly updateInterface: (input: UpdateInterfaceInput) => Promise<UpdateInterfaceResponse>;
    readonly deleteInterface: (input: DeleteInterfaceInput) => Promise<DeleteInterfaceResponse>;
    readonly listInterfaces: (input: ListInterfacesInput) => Promise<ListInterfacesResponse>;
    readonly createPlugin: (input: CreatePluginInput) => Promise<CreatePluginResponse>;
    readonly getPlugin: (input: GetPluginInput) => Promise<GetPluginResponse>;
    readonly getDereferencedPlugin: (input: GetDereferencedPluginInput) => Promise<GetDereferencedPluginResponse>;
    readonly getPluginByName: (input: GetPluginByNameInput) => Promise<GetPluginByNameResponse>;
    readonly updatePlugin: (input: UpdatePluginInput) => Promise<UpdatePluginResponse>;
    readonly deletePlugin: (input: DeletePluginInput) => Promise<DeletePluginResponse>;
    readonly listPlugins: (input: ListPluginsInput) => Promise<ListPluginsResponse>;
    readonly getPluginCode: (input: GetPluginCodeInput) => Promise<GetPluginCodeResponse>;
    readonly getUsage: (input: GetUsageInput) => Promise<GetUsageResponse>;
    readonly getMultipleUsages: (input: GetMultipleUsagesInput) => Promise<GetMultipleUsagesResponse>;
    readonly listUsageHistory: (input: ListUsageHistoryInput) => Promise<ListUsageHistoryResponse>;
    readonly listUsageActivity: (input: ListUsageActivityInput) => Promise<ListUsageActivityResponse>;
    readonly listUsageActivityDaily: (input: ListUsageActivityDailyInput) => Promise<ListUsageActivityDailyResponse>;
    readonly changeAISpendQuota: (input: ChangeAispendQuotaInput) => Promise<ChangeAispendQuotaResponse>;
    readonly listActivities: (input: ListActivitiesInput) => Promise<ListActivitiesResponse>;
    readonly introspect: (input: IntrospectInput) => Promise<IntrospectResponse>;
    readonly upsertFile: (input: UpsertFileInput) => Promise<UpsertFileResponse>;
    readonly deleteFile: (input: DeleteFileInput) => Promise<DeleteFileResponse>;
    readonly listFiles: (input: ListFilesInput) => Promise<ListFilesResponse>;
    readonly getFile: (input: GetFileInput) => Promise<GetFileResponse>;
    readonly updateFileMetadata: (input: UpdateFileMetadataInput) => Promise<UpdateFileMetadataResponse>;
    readonly copyFile: (input: CopyFileInput) => Promise<CopyFileResponse>;
    readonly searchFiles: (input: SearchFilesInput) => Promise<SearchFilesResponse>;
    readonly listFilePassages: (input: ListFilePassagesInput) => Promise<ListFilePassagesResponse>;
    readonly setFilePassages: (input: SetFilePassagesInput) => Promise<SetFilePassagesResponse>;
    readonly listFileTags: (input: ListFileTagsInput) => Promise<ListFileTagsResponse>;
    readonly listFileTagValues: (input: ListFileTagValuesInput) => Promise<ListFileTagValuesResponse>;
    readonly createKnowledgeBase: (input: CreateKnowledgeBaseInput) => Promise<CreateKnowledgeBaseResponse>;
    readonly deleteKnowledgeBase: (input: DeleteKnowledgeBaseInput) => Promise<DeleteKnowledgeBaseResponse>;
    readonly updateKnowledgeBase: (input: UpdateKnowledgeBaseInput) => Promise<UpdateKnowledgeBaseResponse>;
    readonly listKnowledgeBases: (input: ListKnowledgeBasesInput) => Promise<ListKnowledgeBasesResponse>;
    readonly listTables: (input: ListTablesInput) => Promise<ListTablesResponse>;
    readonly getTable: (input: GetTableInput) => Promise<GetTableResponse>;
    readonly getOrCreateTable: (input: GetOrCreateTableInput) => Promise<GetOrCreateTableResponse>;
    readonly createTable: (input: CreateTableInput) => Promise<CreateTableResponse>;
    readonly duplicateTable: (input: DuplicateTableInput) => Promise<DuplicateTableResponse>;
    readonly exportTable: (input: ExportTableInput) => Promise<ExportTableResponse>;
    readonly getTableJobs: (input: GetTableJobsInput) => Promise<GetTableJobsResponse>;
    readonly importTable: (input: ImportTableInput) => Promise<ImportTableResponse>;
    readonly updateTable: (input: UpdateTableInput) => Promise<UpdateTableResponse>;
    readonly renameTableColumn: (input: RenameTableColumnInput) => Promise<RenameTableColumnResponse>;
    readonly deleteTable: (input: DeleteTableInput) => Promise<DeleteTableResponse>;
    readonly getTableRow: (input: GetTableRowInput) => Promise<GetTableRowResponse>;
    readonly findTableRows: (input: FindTableRowsInput) => Promise<FindTableRowsResponse>;
    readonly createTableRows: (input: CreateTableRowsInput) => Promise<CreateTableRowsResponse>;
    readonly deleteTableRows: (input: DeleteTableRowsInput) => Promise<DeleteTableRowsResponse>;
    readonly updateTableRows: (input: UpdateTableRowsInput) => Promise<UpdateTableRowsResponse>;
    readonly upsertTableRows: (input: UpsertTableRowsInput) => Promise<UpsertTableRowsResponse>;
}
declare function toApiError(err: unknown): Error;

type IClient = Simplify<Client$1 & {
    uploadFile: (input: UploadFileInput) => Promise<UploadFileOutput>;
}>;
type Operation = Operation$5<IClient>;
type ClientInputs = Inputs<IClient>;
type ClientOutputs = Outputs<IClient>;
type ClientProps = CommonClientProps & {
    integrationId?: string;
    integrationAlias?: string;
    workspaceId?: string;
    botId?: string;
    token?: string;
};
declare class Client extends Client$1 implements IClient {
    readonly config: Readonly<ClientConfig>;
    constructor(clientProps?: ClientProps);
    get list(): {
        conversations: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            channel?: string | undefined;
            integrationName?: string | undefined;
            sortField?: "createdAt" | "updatedAt" | undefined;
            sortDirection?: "asc" | "desc" | undefined;
            participantIds?: string[] | undefined;
        }) => AsyncCollection<{
            id: string;
            currentTaskId?: string;
            currentWorkflowId?: string;
            createdAt: string;
            updatedAt: string;
            channel: string;
            integration: string;
            tags: {
                [k: string]: string;
            };
        }>;
        participants: (props: {
            id: string;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            tags: {
                [k: string]: string;
            };
            name?: string;
            pictureUrl?: string;
        }>;
        events: (props: {
            status?: "pending" | "ignored" | "processed" | "failed" | "scheduled" | undefined;
            type?: string | undefined;
            userId?: string | undefined;
            conversationId?: string | undefined;
            workflowId?: string | undefined;
            messageId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            type: string;
            payload: {
                [k: string]: any;
            };
            conversationId?: string;
            userId?: string;
            messageId?: string;
            status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
            failureReason: string | null;
        }>;
        messages: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            conversationId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            type: string;
            payload: {
                [k: string]: any;
            };
            direction: "incoming" | "outgoing";
            userId: string;
            conversationId: string;
            tags: {
                [k: string]: string;
            };
            origin?: "synthetic";
        }>;
        users: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            conversationId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            tags: {
                [k: string]: string;
            };
            name?: string;
            pictureUrl?: string;
        }>;
        tasks: (props: {
            status?: ("timeout" | "pending" | "failed" | "in_progress" | "completed" | "blocked" | "paused" | "cancelled")[] | undefined;
            tags?: {
                [x: string]: string;
            } | undefined;
            type?: string | undefined;
            userId?: string | undefined;
            conversationId?: string | undefined;
            parentTaskId?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            title: string;
            description: string;
            type: string;
            data: {
                [k: string]: any;
            };
            status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
            parentTaskId?: string;
            conversationId?: string;
            userId?: string;
            timeoutAt: string;
            createdAt: string;
            updatedAt: string;
            failureReason?: string;
            tags: {
                [k: string]: string;
            };
        }>;
        publicIntegrations: (props: {
            search?: string | undefined;
            name?: string | undefined;
            limit?: number | undefined;
            version?: string | undefined;
            interfaceId?: string | undefined;
            interfaceName?: string | undefined;
            installedByBotId?: string | undefined;
            verificationStatus?: "unapproved" | "pending" | "approved" | "rejected" | undefined;
            sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount" | undefined;
            direction?: "asc" | "desc" | undefined;
        }) => AsyncCollection<{
            id: string;
            name: string;
            version: string;
            createdAt: string;
            updatedAt: string;
            title: string;
            description: string;
            iconUrl: string;
            public: boolean;
            visibility: "public" | "private" | "unlisted";
            verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            ownerWorkspace: {
                id: string;
                handle: string | null;
                name: string;
            };
            meta: {
                installs: number;
                views: number;
            };
            matchedOn?: {
                name?: boolean;
                title?: boolean;
                description?: boolean;
                actions?: string[];
                interfaces?: string[];
            };
        }>;
        bots: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            sortField?: "createdAt" | "updatedAt" | undefined;
            sortDirection?: "asc" | "desc" | undefined;
            dev?: boolean | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            name: string;
            deployedAt?: string;
            tags: {
                [k: string]: string;
            };
        }>;
        botIssues: (props: {
            id: string;
        }) => AsyncCollection<{
            id: string;
            code: string;
            createdAt: string;
            lastSeenAt: string;
            title: string;
            description: string;
            groupedData: {
                [k: string]: {
                    raw: string;
                    pretty?: string;
                };
            };
            eventsCount: number;
            category: "user_code" | "limits" | "configuration" | "other";
            resolutionLink: string | null;
        }>;
        workspaces: (props: {
            handle?: string | undefined;
        }) => AsyncCollection<UpdateWorkspaceResponse>;
        publicWorkspaces: (props: {
            search?: string | undefined;
            workspaceIds?: string[] | undefined;
        }) => AsyncCollection<GetPublicWorkspaceResponse>;
        workspaceMembers: (props: {}) => AsyncCollection<UpdateWorkspaceMemberResponse$1>;
        integrations: (props: {
            search?: string | undefined;
            name?: string | undefined;
            limit?: number | undefined;
            version?: string | undefined;
            interfaceId?: string | undefined;
            interfaceName?: string | undefined;
            installedByBotId?: string | undefined;
            verificationStatus?: "unapproved" | "pending" | "approved" | "rejected" | undefined;
            sortBy?: "popularity" | "name" | "createdAt" | "updatedAt" | "installCount" | undefined;
            direction?: "asc" | "desc" | undefined;
            dev?: boolean | undefined;
            visibility?: "public" | "private" | undefined;
        }) => AsyncCollection<{
            id: string;
            name: string;
            version: string;
            createdAt: string;
            updatedAt: string;
            title: string;
            description: string;
            iconUrl: string;
            public: boolean;
            visibility: "public" | "private" | "unlisted";
            verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            matchedOn?: {
                name?: boolean;
                title?: boolean;
                description?: boolean;
                actions?: string[];
                interfaces?: string[];
            };
            ownerWorkspace?: {
                id: string;
                handle: string | null;
                name: string;
            };
        }>;
        interfaces: (props: {
            name?: string | undefined;
            version?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            name: string;
            version: string;
            title: string;
            description: string;
            iconUrl: string;
            readmeUrl: string;
            public: boolean;
        }>;
        publicInterfaces: (props: {
            name?: string | undefined;
            version?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            name: string;
            version: string;
            title: string;
            description: string;
            iconUrl: string;
            readmeUrl: string;
            public: boolean;
        }>;
        plugins: (props: {
            name?: string | undefined;
            version?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            name: string;
            version: string;
            title: string;
            description: string;
            iconUrl: string;
            readmeUrl: string;
            public: boolean;
        }>;
        publicPlugins: (props: {
            name?: string | undefined;
            version?: string | undefined;
        }) => AsyncCollection<{
            id: string;
            createdAt: string;
            updatedAt: string;
            name: string;
            version: string;
            title: string;
            description: string;
            iconUrl: string;
            readmeUrl: string;
            public: boolean;
        }>;
        activities: (props: {
            botId: string;
            taskId: string;
        }) => AsyncCollection<{
            id: string;
            description: string;
            taskId: string;
            category: "unknown" | "capture" | "bot_message" | "user_message" | "agent_message" | "event" | "action" | "task_status" | "subtask_status" | "exception";
            data: {
                [k: string]: any;
            };
            createdAt: string;
        }>;
        files: (props: {
            tags?: any;
            sortField?: "key" | "size" | "createdAt" | "updatedAt" | "status" | undefined;
            sortDirection?: "asc" | "desc" | undefined;
            ids?: string[] | undefined;
        }) => AsyncCollection<{
            id: string;
            botId: string;
            key: string;
            url: string;
            size: number | null;
            contentType: string;
            tags: {
                [k: string]: string;
            };
            metadata: {
                [k: string]: any | null;
            };
            createdAt: string;
            updatedAt: string;
            accessPolicies: ("integrations" | "public_content")[];
            index: boolean;
            status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
            failedStatusReason?: string;
            expiresAt?: string;
            owner: {
                type: "bot" | "integration" | "user";
                id?: string;
                name?: string;
            };
            indexingStack?: "v1" | "v2";
        }>;
        filePassages: (props: {
            id: string;
            limit?: number | undefined;
        }) => AsyncCollection<{
            id: string;
            content: string;
            meta: {
                type?: "chunk" | "summary" | "consolidated" | "image";
                subtype?: "title" | "subtitle" | "paragraph" | "blockquote" | "list" | "table" | "code" | "image" | "page";
                pageNumber?: number;
                position?: number;
                sourceUrl?: string;
            };
        }>;
        fileTags: (props: {}) => AsyncCollection<string>;
        fileTagValues: (props: {
            tag: string;
        }) => AsyncCollection<string>;
        knowledgeBases: (props: {
            tags?: any;
        }) => AsyncCollection<{
            id: string;
            name: string;
            createdAt: string;
            tags: {
                [k: string]: string;
            };
        }>;
        usageActivity: (props: {
            type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
            id: string;
            timestampFrom?: string | undefined;
            timestampUntil?: string | undefined;
        }) => AsyncCollection<{
            timestamp: string;
            value: number;
            period: string;
            metadata: {
                [k: string]: any | null;
            };
        }>;
        usageActivityDaily: (props: {
            type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
            id: string;
            dateFrom?: string | undefined;
            dateUntil?: string | undefined;
        }) => AsyncCollection<{
            key: string;
            date: string;
            value: number;
            metadata?: {
                botId: string;
                type: "IntegrationAction" | "FileIndexing" | "BingSearch" | "WebSearch";
                subtype?: string;
                source?: string;
            };
        }>;
        workflows: (props: {
            tags?: {
                [x: string]: string;
            } | undefined;
            userId?: string | undefined;
            conversationId?: string | undefined;
            name?: string | undefined;
            parentWorkflowId?: string | undefined;
            statuses?: ("pending" | "failed" | "in_progress" | "completed" | "paused" | "cancelled" | "listening" | "timedout")[] | undefined;
        }) => AsyncCollection<{
            id: string;
            name: string;
            status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
            input: {
                [k: string]: any;
            };
            output: {
                [k: string]: any;
            };
            parentWorkflowId?: string;
            conversationId?: string;
            userId?: string;
            createdAt: string;
            updatedAt: string;
            completedAt?: string;
            failureReason?: string;
            timeoutAt: string;
            tags: {
                [k: string]: string;
            };
        }>;
    };
    /**
     * Create/update and upload a file in a single step. Returns an object containing the file metadata and the URL to retrieve the file.
     */
    readonly uploadFile: (input: UploadFileInput) => Promise<UploadFileOutput>;
}

declare const codes: {
    readonly HTTP_STATUS_BAD_REQUEST: 400;
    readonly HTTP_STATUS_UNAUTHORIZED: 401;
    readonly HTTP_STATUS_PAYMENT_REQUIRED: 402;
    readonly HTTP_STATUS_FORBIDDEN: 403;
    readonly HTTP_STATUS_NOT_FOUND: 404;
    readonly HTTP_STATUS_METHOD_NOT_ALLOWED: 405;
    readonly HTTP_STATUS_REQUEST_TIMEOUT: 408;
    readonly HTTP_STATUS_CONFLICT: 409;
    readonly HTTP_STATUS_PAYLOAD_TOO_LARGE: 413;
    readonly HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: 415;
    readonly HTTP_STATUS_DEPENDENCY_FAILED: 424;
    readonly HTTP_STATUS_TOO_MANY_REQUESTS: 429;
    readonly HTTP_STATUS_INTERNAL_SERVER_ERROR: 500;
    readonly HTTP_STATUS_NOT_IMPLEMENTED: 501;
    readonly HTTP_STATUS_BAD_GATEWAY: 502;
    readonly HTTP_STATUS_SERVICE_UNAVAILABLE: 503;
    readonly HTTP_STATUS_GATEWAY_TIMEOUT: 504;
};
type ErrorCode = typeof codes[keyof typeof codes];
declare abstract class BaseApiError<Code extends ErrorCode, Type extends string, Description extends string> extends Error {
    readonly code: Code;
    readonly description: Description;
    readonly type: Type;
    readonly message: string;
    readonly error?: Error | undefined;
    readonly id?: string | undefined;
    readonly metadata?: Record<string, unknown> | undefined;
    readonly isApiError = true;
    constructor(code: Code, description: Description, type: Type, message: string, error?: Error | undefined, id?: string | undefined, metadata?: Record<string, unknown> | undefined);
    format(): string;
    toJSON(): {
        id: string | undefined;
        code: Code;
        type: Type;
        message: string;
        metadata: Record<string, unknown> | undefined;
    };
    static generateId(): string;
    private static getPrefix;
}
declare const isApiError: (thrown: unknown) => thrown is ApiError;
type UnknownType = 'Unknown';
/**
 *  An unknown error occurred
 */
declare class UnknownError extends BaseApiError<500, UnknownType, 'An unknown error occurred'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type InternalType = 'Internal';
/**
 *  An internal error occurred
 */
declare class InternalError extends BaseApiError<500, InternalType, 'An internal error occurred'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type UnauthorizedType = 'Unauthorized';
/**
 *  The request requires to be authenticated.
 */
declare class UnauthorizedError extends BaseApiError<401, UnauthorizedType, 'The request requires to be authenticated.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type ForbiddenType = 'Forbidden';
/**
 *  The requested action can\'t be peform by this resource.
 */
declare class ForbiddenError extends BaseApiError<403, ForbiddenType, 'The requested action can\'t be peform by this resource.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type PayloadTooLargeType = 'PayloadTooLarge';
/**
 *  The request payload is too large.
 */
declare class PayloadTooLargeError extends BaseApiError<413, PayloadTooLargeType, 'The request payload is too large.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type InvalidPayloadType = 'InvalidPayload';
/**
 *  The request payload is invalid.
 */
declare class InvalidPayloadError extends BaseApiError<400, InvalidPayloadType, 'The request payload is invalid.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type UnsupportedMediaTypeType = 'UnsupportedMediaType';
/**
 *  The request is invalid because the content-type is not supported.
 */
declare class UnsupportedMediaTypeError extends BaseApiError<415, UnsupportedMediaTypeType, 'The request is invalid because the content-type is not supported.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type MethodNotFoundType = 'MethodNotFound';
/**
 *  The requested method does not exist.
 */
declare class MethodNotFoundError extends BaseApiError<405, MethodNotFoundType, 'The requested method does not exist.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type ResourceNotFoundType = 'ResourceNotFound';
/**
 *  The requested resource does not exist.
 */
declare class ResourceNotFoundError extends BaseApiError<404, ResourceNotFoundType, 'The requested resource does not exist.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type InvalidJsonSchemaType = 'InvalidJsonSchema';
/**
 *  The provided JSON schema is invalid.
 */
declare class InvalidJsonSchemaError extends BaseApiError<400, InvalidJsonSchemaType, 'The provided JSON schema is invalid.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type InvalidDataFormatType = 'InvalidDataFormat';
/**
 *  The provided data doesn\'t respect the provided JSON schema.
 */
declare class InvalidDataFormatError extends BaseApiError<400, InvalidDataFormatType, 'The provided data doesn\'t respect the provided JSON schema.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type InvalidIdentifierType = 'InvalidIdentifier';
/**
 *  The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.
 */
declare class InvalidIdentifierError extends BaseApiError<400, InvalidIdentifierType, 'The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type RelationConflictType = 'RelationConflict';
/**
 *  The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren\'t linked together.
 */
declare class RelationConflictError extends BaseApiError<409, RelationConflictType, 'The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren\'t linked together.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type ReferenceConstraintType = 'ReferenceConstraint';
/**
 *  The resource cannot be deleted because it\'s referenced by another resource
 */
declare class ReferenceConstraintError extends BaseApiError<409, ReferenceConstraintType, 'The resource cannot be deleted because it\'s referenced by another resource'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type ResourceLockedConflictType = 'ResourceLockedConflict';
/**
 *  The resource is current locked and cannot be operated on until the lock is released.
 */
declare class ResourceLockedConflictError extends BaseApiError<409, ResourceLockedConflictType, 'The resource is current locked and cannot be operated on until the lock is released.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type ReferenceNotFoundType = 'ReferenceNotFound';
/**
 *  The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.
 */
declare class ReferenceNotFoundError extends BaseApiError<400, ReferenceNotFoundType, 'The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type InvalidQueryType = 'InvalidQuery';
/**
 *  The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.
 */
declare class InvalidQueryError extends BaseApiError<400, InvalidQueryType, 'The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type RuntimeType = 'Runtime';
/**
 *  An error happened during the execution of a runtime (bot or integration).
 */
declare class RuntimeError extends BaseApiError<400, RuntimeType, 'An error happened during the execution of a runtime (bot or integration).'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type AlreadyExistsType = 'AlreadyExists';
/**
 *  The record attempted to be created already exists.
 */
declare class AlreadyExistsError extends BaseApiError<409, AlreadyExistsType, 'The record attempted to be created already exists.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type RateLimitedType = 'RateLimited';
/**
 *  The request has been rate limited.
 */
declare class RateLimitedError extends BaseApiError<429, RateLimitedType, 'The request has been rate limited.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type PaymentRequiredType = 'PaymentRequired';
/**
 *  A payment is required to perform this request.
 */
declare class PaymentRequiredError extends BaseApiError<402, PaymentRequiredType, 'A payment is required to perform this request.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type QuotaExceededType = 'QuotaExceeded';
/**
 *  The request exceeds the allowed quota. Quotas are a soft limit that can be increased.
 */
declare class QuotaExceededError extends BaseApiError<403, QuotaExceededType, 'The request exceeds the allowed quota. Quotas are a soft limit that can be increased.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type LimitExceededType = 'LimitExceeded';
/**
 *  The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.
 */
declare class LimitExceededError extends BaseApiError<413, LimitExceededType, 'The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type BreakingChangesType = 'BreakingChanges';
/**
 *  Request payload contains breaking changes which is not allowed for this resource without a version increment.
 */
declare class BreakingChangesError extends BaseApiError<400, BreakingChangesType, 'Request payload contains breaking changes which is not allowed for this resource without a version increment.'> {
    constructor(message: string, error?: Error, id?: string, metadata?: Record<string, unknown>);
}
type ErrorType = 'Unknown' | 'Internal' | 'Unauthorized' | 'Forbidden' | 'PayloadTooLarge' | 'InvalidPayload' | 'UnsupportedMediaType' | 'MethodNotFound' | 'ResourceNotFound' | 'InvalidJsonSchema' | 'InvalidDataFormat' | 'InvalidIdentifier' | 'RelationConflict' | 'ReferenceConstraint' | 'ResourceLockedConflict' | 'ReferenceNotFound' | 'InvalidQuery' | 'Runtime' | 'AlreadyExists' | 'RateLimited' | 'PaymentRequired' | 'QuotaExceeded' | 'LimitExceeded' | 'BreakingChanges';
type ApiError = UnknownError | InternalError | UnauthorizedError | ForbiddenError | PayloadTooLargeError | InvalidPayloadError | UnsupportedMediaTypeError | MethodNotFoundError | ResourceNotFoundError | InvalidJsonSchemaError | InvalidDataFormatError | InvalidIdentifierError | RelationConflictError | ReferenceConstraintError | ResourceLockedConflictError | ReferenceNotFoundError | InvalidQueryError | RuntimeError | AlreadyExistsError | RateLimitedError | PaymentRequiredError | QuotaExceededError | LimitExceededError | BreakingChangesError;
declare const errorFrom: (err: unknown) => ApiError;

declare class UploadFileError extends Error {
    readonly innerError?: AxiosError | undefined;
    readonly file?: UpsertFileResponse["file"] | undefined;
    constructor(message: string, innerError?: AxiosError | undefined, file?: UpsertFileResponse["file"] | undefined);
}

export { type Account, type Activity, AlreadyExistsError, type ApiError, type Bot, BreakingChangesError, Client, type ClientConfig, type ClientInputs, type ClientOutputs, type ClientProps, type Column, type Conversation, type ErrorType, type Event, type File, ForbiddenError, type Headers, type Integration, type Interface, InternalError, InvalidDataFormatError, InvalidIdentifierError, InvalidJsonSchemaError, InvalidPayloadError, InvalidQueryError, type Issue, type IssueEvent, LimitExceededError, type Message, MethodNotFoundError, type Operation, PayloadTooLargeError, PaymentRequiredError, type Plugin, QuotaExceededError, RateLimitedError, ReferenceConstraintError, ReferenceNotFoundError, RelationConflictError, ResourceLockedConflictError, ResourceNotFoundError, type RetryConfig, type Row, RuntimeError, type State, type Table, type Task, UnauthorizedError, UnknownError, UnsupportedMediaTypeError, UploadFileError, type Usage, type User, type Version, type Workflow, type Workspace, type WorkspaceMember, index$2 as admin, errorFrom, index$1 as files, isApiError, index$3 as runtime, index as tables };
