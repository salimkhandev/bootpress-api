"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseInputLazyPath: () => ParseInputLazyPath,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodRef: () => ZodRef,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  agent: () => agent,
  aimodel: () => aimodel,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  conversation: () => conversation,
  createZodEnum: () => createZodEnum,
  cuid2Regex: () => cuid2Regex,
  cuidRegex: () => cuidRegex,
  custom: () => custom,
  datasource: () => datasource,
  date: () => dateType,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  emailRegex: () => emailRegex,
  enum: () => enumType,
  errorUtil: () => errorUtil,
  event: () => event,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intent: () => intent,
  intersection: () => intersectionType,
  ipv4Regex: () => ipv4Regex,
  ipv6Regex: () => ipv6Regex,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isEmojiRegex: () => isEmojiRegex,
  isValid: () => isValid,
  json: () => json_schema_exports,
  knowledgebase: () => knowledgebase,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  message: () => message,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  processCreateParams: () => processCreateParams,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  readonly: () => readonlyType,
  record: () => recordType,
  ref: () => refType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  table: () => table,
  tablerow: () => tablerow,
  transformer: () => effectsType,
  transforms: () => transforms_exports,
  tuple: () => tupleType,
  ulidRegex: () => ulidRegex,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  user: () => user,
  util: () => util,
  uuidRegex: () => uuidRegex,
  variable: () => variable,
  void: () => voidType,
  z: () => z_exports
});
module.exports = __toCommonJS(index_exports);

// src/transforms/common/json-schema.ts
var json_schema_exports = {};

// src/transforms/index.ts
var transforms_exports = {};
__export(transforms_exports, {
  errors: () => errors_exports,
  fromJSONSchema: () => fromJSONSchema,
  fromJSONSchemaLegacy: () => fromJSONSchemaLegacy,
  fromObject: () => fromObject,
  toJSONSchema: () => toJSONSchema,
  toJSONSchemaLegacy: () => toJSONSchemaLegacy,
  toTypescriptSchema: () => toTypescriptSchema,
  toTypescriptType: () => toTypescriptType
});

// src/z/z.ts
var z_exports = {};
__export(z_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseInputLazyPath: () => ParseInputLazyPath,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodRef: () => ZodRef,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  agent: () => agent,
  aimodel: () => aimodel,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  conversation: () => conversation,
  createZodEnum: () => createZodEnum,
  cuid2Regex: () => cuid2Regex,
  cuidRegex: () => cuidRegex,
  custom: () => custom,
  datasource: () => datasource,
  date: () => dateType,
  default: () => defaultType,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  emailRegex: () => emailRegex,
  enum: () => enumType,
  errorUtil: () => errorUtil,
  event: () => event,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intent: () => intent,
  intersection: () => intersectionType,
  ipv4Regex: () => ipv4Regex,
  ipv6Regex: () => ipv6Regex,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isEmojiRegex: () => isEmojiRegex,
  isValid: () => isValid,
  knowledgebase: () => knowledgebase,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  message: () => message,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  processCreateParams: () => processCreateParams,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  readonly: () => readonlyType,
  record: () => recordType,
  ref: () => refType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  table: () => table,
  tablerow: () => tablerow,
  transformer: () => effectsType,
  tuple: () => tupleType,
  ulidRegex: () => ulidRegex,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  user: () => user,
  util: () => util,
  uuidRegex: () => uuidRegex,
  variable: () => variable,
  void: () => voidType
});

// src/ui/constants.ts
var zuiKey = "x-zui";

// src/transforms/common/utils.ts
function primitiveToTypscriptLiteralType(x) {
  if (typeof x === "symbol") {
    return "symbol";
  }
  if (typeof x === "bigint") {
    const str = x.toString();
    return `${str}n`;
  }
  return primitiveToTypescriptValue(x);
}
__name(primitiveToTypscriptLiteralType, "primitiveToTypscriptLiteralType");
function primitiveToTypescriptValue(x) {
  if (typeof x === "undefined") {
    return "undefined";
  }
  if (typeof x === "symbol") {
    if (x.description) {
      return `Symbol(${primitiveToTypescriptValue(x.description)})`;
    }
    return "Symbol()";
  }
  if (typeof x === "bigint") {
    const str = x.toString();
    return `BigInt(${str})`;
  }
  if (typeof x === "string") {
    return escapeString(x);
  }
  return JSON.stringify(x);
}
__name(primitiveToTypescriptValue, "primitiveToTypescriptValue");
function unknownToTypescriptValue(x) {
  if (typeof x === "undefined") {
    return "undefined";
  }
  return JSON.stringify(x);
}
__name(unknownToTypescriptValue, "unknownToTypescriptValue");
var recordOfUnknownToTypescriptRecord = /* @__PURE__ */ __name((record, asConst) => {
  const entries = Object.entries(record);
  const maybeAsConst = asConst ? " as const" : "";
  return `{ ${entries.map(([key, value]) => `${toPropertyKey(key)}: ${unknownToTypescriptValue(value)}`).join(", ")} }${maybeAsConst}`;
}, "recordOfUnknownToTypescriptRecord");
var toPropertyKey = /* @__PURE__ */ __name((key) => {
  if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)) {
    return key;
  }
  return primitiveToTypescriptValue(key);
}, "toPropertyKey");
var capitalize = /* @__PURE__ */ __name((s) => s.charAt(0).toUpperCase() + s.slice(1), "capitalize");
var toTypeArgumentName = /* @__PURE__ */ __name((name) => {
  const nonAlphaNumeric = /[^a-zA-Z0-9_]/g;
  const tokens = name.split(nonAlphaNumeric).map(capitalize).filter((t) => !!t);
  return tokens.join("");
}, "toTypeArgumentName");
var trimEmptyLinesInPlace = /* @__PURE__ */ __name((lines) => {
  var _a;
  while (lines.length && !((_a = lines[0]) == null ? void 0 : _a.trim())) {
    lines.shift();
  }
  while (lines.length && !lines[lines.length - 1].trim()) {
    lines.pop();
  }
}, "trimEmptyLinesInPlace");
var getMultilineComment = /* @__PURE__ */ __name((description) => {
  description = description == null ? void 0 : description.replace(/(\n(\s*)?){3,}/g, "\n\n");
  const ensureLineStartsWithAsterisk = /* @__PURE__ */ __name((line) => line.startsWith("* ") ? ` ${line}` : ` * ${line}`, "ensureLineStartsWithAsterisk");
  const escapeCommentEnd = /* @__PURE__ */ __name((line) => line.replace(/\*\//g, "*\\/"), "escapeCommentEnd");
  const descLines = (description != null ? description : "").split("\n").map((line) => line.trim());
  trimEmptyLinesInPlace(descLines);
  if (descLines.length) {
    descLines[0] = descLines[0].replace(/^\/\*\*?/, "");
    descLines[descLines.length - 1] = descLines[descLines.length - 1].replace(/\*\/$/, "");
  }
  trimEmptyLinesInPlace(descLines);
  return descLines.length === 0 ? "" : descLines.length === 1 ? `/** ${escapeCommentEnd(descLines[0])} */` : `/**
${descLines.map(ensureLineStartsWithAsterisk).map(escapeCommentEnd).join("\n")}
 */`;
}, "getMultilineComment");
function escapeString(str) {
  if (typeof str !== "string") {
    return "";
  }
  const rawStr = String.raw`${str}`;
  const escapedStr = rawStr.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/"/g, '\\"').replace(/'/g, "\\'");
  if (escapedStr.includes("`")) {
    return `"${escapedStr}"`;
  } else if (escapedStr.includes("'")) {
    return `"${escapedStr}"`;
  } else {
    return `'${escapedStr}'`;
  }
}
__name(escapeString, "escapeString");

// src/transforms/common/errors.ts
var errors_exports = {};
__export(errors_exports, {
  JSONSchemaToZuiError: () => JSONSchemaToZuiError,
  ObjectToZuiError: () => ObjectToZuiError,
  UnrepresentableGenericError: () => UnrepresentableGenericError,
  UnsupportedJSONSchemaToZuiError: () => UnsupportedJSONSchemaToZuiError,
  UnsupportedZuiCheckToJSONSchemaError: () => UnsupportedZuiCheckToJSONSchemaError,
  UnsupportedZuiToJSONSchemaError: () => UnsupportedZuiToJSONSchemaError,
  UnsupportedZuiToTypescriptSchemaError: () => UnsupportedZuiToTypescriptSchemaError,
  UnsupportedZuiToTypescriptTypeError: () => UnsupportedZuiToTypescriptTypeError,
  UntitledDeclarationError: () => UntitledDeclarationError,
  ZuiToJSONSchemaError: () => ZuiToJSONSchemaError,
  ZuiToTypescriptSchemaError: () => ZuiToTypescriptSchemaError,
  ZuiToTypescriptTypeError: () => ZuiToTypescriptTypeError,
  ZuiTransformError: () => ZuiTransformError
});
var _ZuiTransformError = class _ZuiTransformError extends Error {
  constructor(transform, message2) {
    super(message2);
    this.transform = transform;
  }
};
__name(_ZuiTransformError, "ZuiTransformError");
var ZuiTransformError = _ZuiTransformError;
var _JSONSchemaToZuiError = class _JSONSchemaToZuiError extends ZuiTransformError {
  constructor(message2) {
    super("json-schema-to-zui", message2);
  }
};
__name(_JSONSchemaToZuiError, "JSONSchemaToZuiError");
var JSONSchemaToZuiError = _JSONSchemaToZuiError;
var _ObjectToZuiError = class _ObjectToZuiError extends ZuiTransformError {
  constructor(message2) {
    super("object-to-zui", message2);
  }
};
__name(_ObjectToZuiError, "ObjectToZuiError");
var ObjectToZuiError = _ObjectToZuiError;
var _ZuiToJSONSchemaError = class _ZuiToJSONSchemaError extends ZuiTransformError {
  constructor(message2) {
    super("zui-to-json-schema", message2);
  }
};
__name(_ZuiToJSONSchemaError, "ZuiToJSONSchemaError");
var ZuiToJSONSchemaError = _ZuiToJSONSchemaError;
var _UnsupportedZuiToJSONSchemaError = class _UnsupportedZuiToJSONSchemaError extends ZuiToJSONSchemaError {
  constructor(type, { suggestedAlternative } = {}) {
    super(
      `Zod type ${type} cannot be transformed to JSON Schema.` + (suggestedAlternative ? ` Suggested alternative: ${suggestedAlternative}` : "")
    );
  }
};
__name(_UnsupportedZuiToJSONSchemaError, "UnsupportedZuiToJSONSchemaError");
var UnsupportedZuiToJSONSchemaError = _UnsupportedZuiToJSONSchemaError;
var _UnsupportedZuiCheckToJSONSchemaError = class _UnsupportedZuiCheckToJSONSchemaError extends ZuiToJSONSchemaError {
  constructor({ zodType, checkKind }) {
    super(`Zod check .${checkKind}() of type ${zodType} cannot be transformed to JSON Schema.`);
  }
};
__name(_UnsupportedZuiCheckToJSONSchemaError, "UnsupportedZuiCheckToJSONSchemaError");
var UnsupportedZuiCheckToJSONSchemaError = _UnsupportedZuiCheckToJSONSchemaError;
var _UnsupportedJSONSchemaToZuiError = class _UnsupportedJSONSchemaToZuiError extends JSONSchemaToZuiError {
  constructor(schema) {
    super(`JSON Schema ${JSON.stringify(schema)} cannot be transformed to ZUI type.`);
  }
};
__name(_UnsupportedJSONSchemaToZuiError, "UnsupportedJSONSchemaToZuiError");
var UnsupportedJSONSchemaToZuiError = _UnsupportedJSONSchemaToZuiError;
var _ZuiToTypescriptSchemaError = class _ZuiToTypescriptSchemaError extends ZuiTransformError {
  constructor(message2) {
    super("zui-to-typescript-schema", message2);
  }
};
__name(_ZuiToTypescriptSchemaError, "ZuiToTypescriptSchemaError");
var ZuiToTypescriptSchemaError = _ZuiToTypescriptSchemaError;
var _UnsupportedZuiToTypescriptSchemaError = class _UnsupportedZuiToTypescriptSchemaError extends ZuiToTypescriptSchemaError {
  constructor(type) {
    super(`Zod type ${type} cannot be transformed to TypeScript schema.`);
  }
};
__name(_UnsupportedZuiToTypescriptSchemaError, "UnsupportedZuiToTypescriptSchemaError");
var UnsupportedZuiToTypescriptSchemaError = _UnsupportedZuiToTypescriptSchemaError;
var _ZuiToTypescriptTypeError = class _ZuiToTypescriptTypeError extends ZuiTransformError {
  constructor(message2) {
    super("zui-to-typescript-type", message2);
  }
};
__name(_ZuiToTypescriptTypeError, "ZuiToTypescriptTypeError");
var ZuiToTypescriptTypeError = _ZuiToTypescriptTypeError;
var _UnsupportedZuiToTypescriptTypeError = class _UnsupportedZuiToTypescriptTypeError extends ZuiToTypescriptTypeError {
  constructor(type) {
    super(`Zod type ${type} cannot be transformed to TypeScript type.`);
  }
};
__name(_UnsupportedZuiToTypescriptTypeError, "UnsupportedZuiToTypescriptTypeError");
var UnsupportedZuiToTypescriptTypeError = _UnsupportedZuiToTypescriptTypeError;
var _UntitledDeclarationError = class _UntitledDeclarationError extends ZuiToTypescriptTypeError {
  constructor() {
    super("Schema must have a title to be transformed to a TypeScript type with a declaration.");
  }
};
__name(_UntitledDeclarationError, "UntitledDeclarationError");
var UntitledDeclarationError = _UntitledDeclarationError;
var _UnrepresentableGenericError = class _UnrepresentableGenericError extends ZuiToTypescriptTypeError {
  constructor() {
    super(`${"ZodRef" /* ZodRef */} can only be transformed to a TypeScript type with a "type" declaration.`);
  }
};
__name(_UnrepresentableGenericError, "UnrepresentableGenericError");
var UnrepresentableGenericError = _UnrepresentableGenericError;

// src/transforms/zui-to-typescript-type/index.ts
var Primitives = [
  "string",
  "number",
  "boolean",
  "unknown",
  "void",
  "any",
  "null",
  "undefined",
  "never",
  "bigint",
  "symbol",
  "object"
];
var LARGE_DECLARATION_LINES = 5;
var isPrimitive = /* @__PURE__ */ __name((type) => Primitives.includes(type), "isPrimitive");
var isArrayOfPrimitives = /* @__PURE__ */ __name((type) => Primitives.map((p) => `${p}[]`).includes(type), "isArrayOfPrimitives");
var stripSpaces = /* @__PURE__ */ __name((typings) => typings.replace(/ +/g, " ").trim(), "stripSpaces");
var _KeyValue = class _KeyValue {
  constructor(key, value, optional = false) {
    this.key = key;
    this.value = value;
    this.optional = optional;
  }
};
__name(_KeyValue, "KeyValue");
var KeyValue = _KeyValue;
var _FnParameters = class _FnParameters {
  constructor(schema) {
    this.schema = schema;
  }
};
__name(_FnParameters, "FnParameters");
var FnParameters = _FnParameters;
var _FnReturn = class _FnReturn {
  constructor(schema) {
    this.schema = schema;
  }
};
__name(_FnReturn, "FnReturn");
var FnReturn = _FnReturn;
var _Declaration = class _Declaration {
  constructor(props) {
    this.props = props;
  }
};
__name(_Declaration, "Declaration");
var Declaration = _Declaration;
function toTypescriptType(schema, options = {}) {
  const wrappedSchema = getDeclarationProps(schema, options);
  let dts = sUnwrapZod(wrappedSchema, options);
  if (options.formatter) {
    dts = options.formatter(dts);
  }
  return dts;
}
__name(toTypescriptType, "toTypescriptType");
function sUnwrapZod(schema, config) {
  var _a, _b, _c;
  const newConfig = __spreadProps(__spreadValues({}, config), {
    declaration: false,
    parent: schema
  });
  if (schema === null) {
    return "";
  }
  if (schema instanceof Declaration) {
    return unwrapDeclaration(schema, newConfig);
  }
  if (schema instanceof KeyValue) {
    if (schema.value instanceof z_default.ZodOptional) {
      let innerType = schema.value._def.innerType;
      if (innerType instanceof z_default.Schema && !innerType.description && schema.value.description) {
        innerType = innerType == null ? void 0 : innerType.describe(schema.value.description);
      }
      const optionalToken = schema.key.endsWith("?") ? "" : "?";
      return sUnwrapZod(new KeyValue(schema.key + optionalToken, innerType), newConfig);
    }
    const description = getMultilineComment(schema.value._def.description || schema.value.description);
    const delimiter = (description == null ? void 0 : description.trim().length) > 0 ? "\n" : "";
    const withoutDesc = schema.value.describe("");
    return `${delimiter}${description}${delimiter}${schema.key}: ${sUnwrapZod(withoutDesc, newConfig)}${delimiter}`;
  }
  if (schema instanceof FnParameters) {
    if (schema.schema instanceof z_default.ZodTuple) {
      let args = "";
      for (let i = 0; i < schema.schema.items.length; i++) {
        const argName = (_c = (_b = (_a = schema.schema.items[i]) == null ? void 0 : _a.ui) == null ? void 0 : _b.title) != null ? _c : `arg${i}`;
        const item = schema.schema.items[i];
        args += `${sUnwrapZod(new KeyValue(toPropertyKey(argName), item), newConfig)}${i < schema.schema.items.length - 1 ? ", " : ""} `;
      }
      return args;
    }
    const isLiteral = schema.schema.naked() instanceof z_default.ZodLiteral;
    const typings = sUnwrapZod(schema.schema, newConfig).trim();
    const startsWithPairs = typings.startsWith("{") && typings.endsWith("}") || typings.startsWith("[") && typings.endsWith("]") || typings.startsWith("(") && typings.endsWith(")") || typings.startsWith("Array<") && typings.endsWith(">") || typings.startsWith("Record<") && typings.endsWith(">") || isArrayOfPrimitives(typings);
    if (startsWithPairs || isLiteral) {
      return `args: ${typings}`;
    } else {
      return typings;
    }
  }
  if (schema instanceof FnReturn) {
    if (schema.schema instanceof z_default.ZodOptional) {
      return `${sUnwrapZod(schema.schema.unwrap(), newConfig)} | undefined`;
    }
    return sUnwrapZod(schema.schema, newConfig);
  }
  const schemaTyped = schema;
  const def = schemaTyped._def;
  switch (def.typeName) {
    case z_default.ZodFirstPartyTypeKind.ZodString:
      return `${getMultilineComment(schemaTyped.description)} string`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNumber:
    case z_default.ZodFirstPartyTypeKind.ZodNaN:
    case z_default.ZodFirstPartyTypeKind.ZodBigInt:
      return `${getMultilineComment(schemaTyped.description)} number`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBoolean:
      return `${getMultilineComment(schemaTyped.description)} boolean`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDate:
      return `${getMultilineComment(schemaTyped.description)} Date`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUndefined:
      return `${getMultilineComment(schemaTyped.description)} undefined`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNull:
      return `${getMultilineComment(schemaTyped.description)} null`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodAny:
      return `${getMultilineComment(schemaTyped.description)} any`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnknown:
      return `${getMultilineComment(schemaTyped.description)} unknown`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNever:
      return `${getMultilineComment(schemaTyped.description)} never`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodVoid:
      return `${getMultilineComment(schemaTyped.description)} void`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodArray:
      const item = sUnwrapZod(def.type, newConfig);
      if (isPrimitive(item)) {
        return `${item}[]`;
      }
      return `Array<${item}>`;
    case z_default.ZodFirstPartyTypeKind.ZodObject:
      const props = Object.entries(def.shape()).map(([key, value2]) => {
        if (value2 instanceof z_default.Schema) {
          return sUnwrapZod(new KeyValue(toPropertyKey(key), value2), newConfig);
        }
        return `${key}: unknown`;
      });
      return `{ ${props.join("; ")} }`;
    case z_default.ZodFirstPartyTypeKind.ZodUnion:
      const options = def.options.map((option) => {
        return sUnwrapZod(option, newConfig);
      });
      return `${getMultilineComment(schemaTyped.description)}
${options.join(" | ")}`;
    case z_default.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      const opts = def.options.map((option) => {
        return sUnwrapZod(option, newConfig);
      });
      return `${getMultilineComment(schemaTyped.description)}
${opts.join(" | ")}`;
    case z_default.ZodFirstPartyTypeKind.ZodIntersection:
      return `${sUnwrapZod(def.left, newConfig)} & ${sUnwrapZod(def.right, newConfig)}`;
    case z_default.ZodFirstPartyTypeKind.ZodTuple:
      if (def.items.length === 0) {
        return "[]";
      }
      const items = def.items.map((i) => sUnwrapZod(i, newConfig));
      return `[${items.join(", ")}]`;
    case z_default.ZodFirstPartyTypeKind.ZodRecord:
      const keyType = sUnwrapZod(def.keyType, newConfig);
      const valueType = sUnwrapZod(def.valueType, newConfig);
      return `${getMultilineComment(schemaTyped.description)} { [key: ${keyType}]: ${valueType} }`;
    case z_default.ZodFirstPartyTypeKind.ZodMap:
      return `Map<${sUnwrapZod(def.keyType, newConfig)}, ${sUnwrapZod(def.valueType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodSet:
      return `Set<${sUnwrapZod(def.valueType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodFunction:
      const input4 = sUnwrapZod(new FnParameters(def.args), newConfig);
      const output4 = sUnwrapZod(new FnReturn(def.returns), newConfig);
      const parentIsType = (config == null ? void 0 : config.parent) instanceof Declaration && (config == null ? void 0 : config.parent.props.type) === "type";
      if ((config == null ? void 0 : config.declaration) && !parentIsType) {
        return `${getMultilineComment(schemaTyped.description)}
(${input4}): ${output4}`;
      }
      return `${getMultilineComment(schemaTyped.description)}
(${input4}) => ${output4}`;
    case z_default.ZodFirstPartyTypeKind.ZodLazy:
      return sUnwrapZod(def.getter(), newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodLiteral:
      const value = primitiveToTypscriptLiteralType(def.value);
      return `${getMultilineComment(schemaTyped.description)}
${value}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEnum:
      const values = def.values.map(primitiveToTypescriptValue);
      return values.join(" | ");
    case z_default.ZodFirstPartyTypeKind.ZodEffects:
      return sUnwrapZod(def.schema, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodNativeEnum:
      throw new UnsupportedZuiToTypescriptTypeError(z_default.ZodFirstPartyTypeKind.ZodNativeEnum);
    case z_default.ZodFirstPartyTypeKind.ZodOptional:
      return `${sUnwrapZod(def.innerType, newConfig)} | undefined`;
    case z_default.ZodFirstPartyTypeKind.ZodNullable:
      return `${sUnwrapZod(def.innerType, newConfig)} | null`;
    case z_default.ZodFirstPartyTypeKind.ZodDefault:
      return sUnwrapZod(def.innerType, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodCatch:
      return sUnwrapZod(def.innerType, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodPromise:
      return `Promise<${sUnwrapZod(def.type, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodBranded:
      return sUnwrapZod(def.type, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodPipeline:
      return sUnwrapZod(def.in, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodSymbol:
      return `${getMultilineComment(schemaTyped.description)} symbol`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodReadonly:
      return `Readonly<${sUnwrapZod(def.innerType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodRef:
      return toTypeArgumentName(def.uri);
    default:
      util.assertNever(def);
  }
}
__name(sUnwrapZod, "sUnwrapZod");
var unwrapDeclaration = /* @__PURE__ */ __name((declaration, options) => {
  if (declaration.props.type === "none") {
    return sUnwrapZod(declaration.props.schema, options);
  }
  const { schema, identifier } = declaration.props;
  const description = getMultilineComment(schema.description);
  const withoutDesc = schema.describe("");
  const typings = sUnwrapZod(withoutDesc, __spreadProps(__spreadValues({}, options), { declaration: true }));
  const isLargeDeclaration = typings.split("\n").length >= LARGE_DECLARATION_LINES;
  const closingTag = isLargeDeclaration && options.includeClosingTags ? `// end of ${identifier}` : "";
  if (declaration.props.type !== "type" && schema instanceof z_default.ZodFunction) {
    return stripSpaces(`${description}
declare function ${identifier}${typings};${closingTag}`);
  }
  if (declaration.props.type === "variable") {
    return stripSpaces(`${description}declare const ${identifier}: ${typings};${closingTag}`);
  }
  const generics = declaration.props.args.length > 0 ? `<${declaration.props.args.map(toTypeArgumentName).join(", ")}>` : "";
  return stripSpaces(`${description}type ${declaration.props.identifier}${generics} = ${typings};${closingTag}`);
}, "unwrapDeclaration");
var getDeclarationType = /* @__PURE__ */ __name((options) => {
  if (!options.declaration) {
    return "none";
  }
  if (options.declaration === true) {
    return "variable";
  }
  return options.declaration;
}, "getDeclarationType");
var getDeclarationProps = /* @__PURE__ */ __name((schema, options) => {
  const declarationType = getDeclarationType(options);
  const args = schema.getReferences();
  if (declarationType === "none") {
    if (args.length > 0) {
      throw new UnrepresentableGenericError();
    }
    return new Declaration({ type: "none", schema });
  }
  const title = "title" in schema.ui ? schema.ui.title : null;
  if (!title) {
    throw new UntitledDeclarationError();
  }
  if (declarationType === "variable") {
    if (args.length > 0) {
      throw new UnrepresentableGenericError();
    }
    return new Declaration({ type: "variable", identifier: title, schema });
  }
  return new Declaration({ type: "type", identifier: title, schema, args });
}, "getDeclarationProps");

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
__name(getRawTag, "getRawTag");
var getRawTag_default = getRawTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
__name(objectToString, "objectToString");
var objectToString_default = objectToString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
__name(baseGetTag, "baseGetTag");
var baseGetTag_default = baseGetTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
__name(isObjectLike, "isObjectLike");
var isObjectLike_default = isObjectLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
__name(isSymbol, "isSymbol");
var isSymbol_default = isSymbol;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
__name(arrayMap, "arrayMap");
var arrayMap_default = arrayMap;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
var baseToString_default = baseToString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
__name(isObject, "isObject");
var isObject_default = isObject;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
__name(identity, "identity");
var identity_default = identity;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
__name(isFunction, "isFunction");
var isFunction_default = isFunction;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
__name(isMasked, "isMasked");
var isMasked_default = isMasked;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
__name(toSource, "toSource");
var toSource_default = toSource;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
__name(baseIsNative, "baseIsNative");
var baseIsNative_default = baseIsNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
__name(getValue, "getValue");
var getValue_default = getValue;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
__name(getNative, "getNative");
var getNative_default = getNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js
var WeakMap = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
__name(isIndex, "isIndex");
var isIndex_default = isIndex;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
__name(baseAssignValue, "baseAssignValue");
var baseAssignValue_default = baseAssignValue;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
__name(eq, "eq");
var eq_default = eq;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
__name(assignValue, "assignValue");
var assignValue_default = assignValue;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
__name(isLength, "isLength");
var isLength_default = isLength;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
__name(isArrayLike, "isArrayLike");
var isArrayLike_default = isArrayLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
__name(isPrototype, "isPrototype");
var isPrototype_default = isPrototype;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
__name(baseTimes, "baseTimes");
var baseTimes_default = baseTimes;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
__name(baseIsArguments, "baseIsArguments");
var baseIsArguments_default = baseIsArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
__name(stubFalse, "stubFalse");
var stubFalse_default = stubFalse;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
__name(baseIsTypedArray, "baseIsTypedArray");
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
__name(baseUnary, "baseUnary");
var baseUnary_default = baseUnary;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
__name(arrayLikeKeys, "arrayLikeKeys");
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
__name(overArg, "overArg");
var overArg_default = overArg;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
__name(baseKeys, "baseKeys");
var baseKeys_default = baseKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
__name(keys, "keys");
var keys_default = keys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
__name(nativeKeysIn, "nativeKeysIn");
var nativeKeysIn_default = nativeKeysIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
__name(baseKeysIn, "baseKeysIn");
var baseKeysIn_default = baseKeysIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
__name(keysIn, "keysIn");
var keysIn_default = keysIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
__name(isKey, "isKey");
var isKey_default = isKey;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
__name(hashClear, "hashClear");
var hashClear_default = hashClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
__name(hashDelete, "hashDelete");
var hashDelete_default = hashDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
__name(hashGet, "hashGet");
var hashGet_default = hashGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
__name(hashHas, "hashHas");
var hashHas_default = hashHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
__name(hashSet, "hashSet");
var hashSet_default = hashSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(Hash, "Hash");
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
__name(listCacheClear, "listCacheClear");
var listCacheClear_default = listCacheClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
__name(assocIndexOf, "assocIndexOf");
var assocIndexOf_default = assocIndexOf;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
__name(listCacheDelete, "listCacheDelete");
var listCacheDelete_default = listCacheDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
__name(listCacheGet, "listCacheGet");
var listCacheGet_default = listCacheGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
__name(listCacheHas, "listCacheHas");
var listCacheHas_default = listCacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
__name(listCacheSet, "listCacheSet");
var listCacheSet_default = listCacheSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(ListCache, "ListCache");
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
__name(mapCacheClear, "mapCacheClear");
var mapCacheClear_default = mapCacheClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
__name(isKeyable, "isKeyable");
var isKeyable_default = isKeyable;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
__name(getMapData, "getMapData");
var getMapData_default = getMapData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
__name(mapCacheDelete, "mapCacheDelete");
var mapCacheDelete_default = mapCacheDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
__name(mapCacheGet, "mapCacheGet");
var mapCacheGet_default = mapCacheGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
__name(mapCacheHas, "mapCacheHas");
var mapCacheHas_default = mapCacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
__name(mapCacheSet, "mapCacheSet");
var mapCacheSet_default = mapCacheSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(MapCache, "MapCache");
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = /* @__PURE__ */ __name(function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  }, "memoized");
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
__name(memoize, "memoize");
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
__name(memoizeCapped, "memoizeCapped");
var memoizeCapped_default = memoizeCapped;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
__name(toString, "toString");
var toString_default = toString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
__name(castPath, "castPath");
var castPath_default = castPath;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
__name(toKey, "toKey");
var toKey_default = toKey;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
__name(baseGet, "baseGet");
var baseGet_default = baseGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
__name(get, "get");
var get_default = get;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
__name(arrayPush, "arrayPush");
var arrayPush_default = arrayPush;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
__name(isPlainObject, "isPlainObject");
var isPlainObject_default = isPlainObject;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
__name(stackClear, "stackClear");
var stackClear_default = stackClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
__name(stackDelete, "stackDelete");
var stackDelete_default = stackDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
__name(stackGet, "stackGet");
var stackGet_default = stackGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
__name(stackHas, "stackHas");
var stackHas_default = stackHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
__name(stackSet, "stackSet");
var stackSet_default = stackSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
__name(Stack, "Stack");
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
__name(arrayFilter, "arrayFilter");
var arrayFilter_default = arrayFilter;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
__name(stubArray, "stubArray");
var stubArray_default = stubArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result = [];
  while (object) {
    arrayPush_default(result, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
__name(baseGetAllKeys, "baseGetAllKeys");
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
__name(getAllKeys, "getAllKeys");
var getAllKeys_default = getAllKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
__name(getAllKeysIn, "getAllKeysIn");
var getAllKeysIn_default = getAllKeysIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = /* @__PURE__ */ __name(function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  }, "getTag");
}
var getTag_default = getTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
__name(setCacheAdd, "setCacheAdd");
var setCacheAdd_default = setCacheAdd;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
__name(setCacheHas, "setCacheHas");
var setCacheHas_default = setCacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values[index]);
  }
}
__name(SetCache, "SetCache");
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
__name(arraySome, "arraySome");
var arraySome_default = arraySome;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
__name(cacheHas, "cacheHas");
var cacheHas_default = cacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
__name(equalArrays, "equalArrays");
var equalArrays_default = equalArrays;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
__name(mapToArray, "mapToArray");
var mapToArray_default = mapToArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToArray.js
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
__name(setToArray, "setToArray");
var setToArray_default = setToArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
__name(equalByTag, "equalByTag");
var equalByTag_default = equalByTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty11.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
__name(equalObjects, "equalObjects");
var equalObjects_default = equalObjects;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag4 = "[object Object]";
var objectProto15 = Object.prototype;
var hasOwnProperty12 = objectProto15.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag4 : objTag;
  othTag = othTag == argsTag3 ? objectTag4 : othTag;
  var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty12.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty12.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
__name(baseIsEqualDeep, "baseIsEqualDeep");
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
__name(baseIsEqual, "baseIsEqual");
var baseIsEqual_default = baseIsEqual;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
__name(baseIsMatch, "baseIsMatch");
var baseIsMatch_default = baseIsMatch;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
__name(isStrictComparable, "isStrictComparable");
var isStrictComparable_default = isStrictComparable;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
__name(getMatchData, "getMatchData");
var getMatchData_default = getMatchData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
__name(matchesStrictComparable, "matchesStrictComparable");
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
__name(baseMatches, "baseMatches");
var baseMatches_default = baseMatches;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
__name(baseHasIn, "baseHasIn");
var baseHasIn_default = baseHasIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
__name(hasPath, "hasPath");
var hasPath_default = hasPath;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
__name(hasIn, "hasIn");
var hasIn_default = hasIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
__name(baseMatchesProperty, "baseMatchesProperty");
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
__name(baseProperty, "baseProperty");
var baseProperty_default = baseProperty;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
__name(basePropertyDeep, "basePropertyDeep");
var basePropertyDeep_default = basePropertyDeep;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
__name(property, "property");
var property_default = property;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
__name(baseIteratee, "baseIteratee");
var baseIteratee_default = baseIteratee;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
__name(createBaseFor, "createBaseFor");
var createBaseFor_default = createBaseFor;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
__name(baseForOwn, "baseForOwn");
var baseForOwn_default = baseForOwn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
__name(isEqual, "isEqual");
var isEqual_default = isEqual;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result = customizer ? customizer(value, other) : void 0;
  return result === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result;
}
__name(isEqualWith, "isEqualWith");
var isEqualWith_default = isEqualWith;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
__name(isUndefined, "isUndefined");
var isUndefined_default = isUndefined;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee_default(iteratee, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result, key, iteratee(value, key, object2));
  });
  return result;
}
__name(mapValues, "mapValues");
var mapValues_default = mapValues;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT2 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
__name(negate, "negate");
var negate_default = negate;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
__name(baseSet, "baseSet");
var baseSet_default = baseSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet_default(object, path);
    if (predicate(value, path)) {
      baseSet_default(result, castPath_default(path, object), value);
    }
  }
  return result;
}
__name(basePickBy, "basePickBy");
var basePickBy_default = basePickBy;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
__name(pickBy, "pickBy");
var pickBy_default = pickBy;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
__name(omitBy, "omitBy");
var omitBy_default = omitBy;

// src/transforms/zui-to-typescript-schema/string-checks.ts
var generateStringChecks = /* @__PURE__ */ __name((def) => {
  const checks = def.checks;
  if (checks.length === 0) {
    return "";
  }
  return checks.map(_generateStringCheck).join("");
}, "generateStringChecks");
var _generateStringCheck = /* @__PURE__ */ __name((check) => {
  switch (check.kind) {
    case "min":
      return `.min(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "max":
      return `.max(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "length":
      return `.length(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "email":
      return `.email(${primitiveToTypescriptValue(check.message)})`;
    case "url":
      return `.url(${primitiveToTypescriptValue(check.message)})`;
    case "emoji":
      return `.emoji(${primitiveToTypescriptValue(check.message)})`;
    case "uuid":
      return `.uuid(${primitiveToTypescriptValue(check.message)})`;
    case "cuid":
      return `.cuid(${primitiveToTypescriptValue(check.message)})`;
    case "cuid2":
      return `.cuid2(${primitiveToTypescriptValue(check.message)})`;
    case "ulid":
      return `.ulid(${primitiveToTypescriptValue(check.message)})`;
    case "includes":
      const includesOptions = unknownToTypescriptValue({ message: check.message, position: check.position });
      return `.includes(${primitiveToTypescriptValue(check.value)}, ${includesOptions})`;
    case "startsWith":
      return `.startsWith(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "endsWith":
      return `.endsWith(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "regex":
      const tsRegex = String(check.regex);
      return `.regex(${tsRegex}, ${primitiveToTypescriptValue(check.message)})`;
    case "trim":
      return `.trim()`;
    case "toLowerCase":
      return `.toLowerCase()`;
    case "toUpperCase":
      return `.toUpperCase()`;
    case "datetime":
      const datetimePrecision = check.precision === null ? void 0 : check.precision;
      const dateTimeOptions = unknownToTypescriptValue({
        message: check.message,
        precision: datetimePrecision,
        offset: check.offset
      });
      return `.datetime(${dateTimeOptions})`;
    case "ip":
      const ipOptions = unknownToTypescriptValue({ message: check.message, version: check.version });
      return `.ip(${ipOptions})`;
    default:
      return "";
  }
}, "_generateStringCheck");

// src/transforms/zui-to-typescript-schema/number-checks.ts
var generateNumberChecks = /* @__PURE__ */ __name((def) => {
  const checks = def.checks;
  if (checks.length === 0) {
    return "";
  }
  return checks.map(_generateNumberCheck).join("");
}, "generateNumberChecks");
var _generateNumberCheck = /* @__PURE__ */ __name((check) => {
  switch (check.kind) {
    case "min":
      return `.min(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "max":
      return `.max(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "int":
      return `.int(${primitiveToTypescriptValue(check.message)})`;
    case "multipleOf":
      return `.multipleOf(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "finite":
      return `.finite(${primitiveToTypescriptValue(check.message)})`;
    default:
      return "";
  }
}, "_generateNumberCheck");

// src/transforms/zui-to-typescript-schema/bigint-checks.ts
var generateBigIntChecks = /* @__PURE__ */ __name((def) => {
  const checks = def.checks;
  if (checks.length === 0) {
    return "";
  }
  return checks.map(_generateBigIntCheck).join("");
}, "generateBigIntChecks");
var _generateBigIntCheck = /* @__PURE__ */ __name((check) => {
  switch (check.kind) {
    case "min":
      return `.min(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "max":
      return `.max(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    case "multipleOf":
      return `.multipleOf(${primitiveToTypescriptValue(check.value)}, ${primitiveToTypescriptValue(check.message)})`;
    default:
      return "";
  }
}, "_generateBigIntCheck");

// src/transforms/zui-to-typescript-schema/date-checks.ts
var generateDateChecks = /* @__PURE__ */ __name((def) => {
  const checks = def.checks;
  if (checks.length === 0) {
    return "";
  }
  return checks.map(_generateDateCheck).join("");
}, "generateDateChecks");
var _generateDateCheck = /* @__PURE__ */ __name((check) => {
  switch (check.kind) {
    case "min":
      const minDate = dateTs(check.value);
      return `.min(${minDate}, ${primitiveToTypescriptValue(check.message)})`;
    case "max":
      const maxDate = dateTs(check.value);
      return `.max(${maxDate}, ${primitiveToTypescriptValue(check.message)})`;
    default:
      return "";
  }
}, "_generateDateCheck");
var dateTs = /* @__PURE__ */ __name((d) => {
  return `new Date(${d})`;
}, "dateTs");

// src/transforms/zui-to-typescript-schema/array-checks.ts
var generateArrayChecks = /* @__PURE__ */ __name((def) => {
  const checks = [];
  if (def.exactLength) {
    const { value, message: message2 } = def.exactLength;
    checks.push(`.length(${primitiveToTypescriptValue(value)}, ${primitiveToTypescriptValue(message2)})`);
  }
  if (def.minLength) {
    const { value, message: message2 } = def.minLength;
    checks.push(`.min(${primitiveToTypescriptValue(value)}, ${primitiveToTypescriptValue(message2)})`);
  }
  if (def.maxLength) {
    const { value, message: message2 } = def.maxLength;
    checks.push(`.max(${primitiveToTypescriptValue(value)}, ${primitiveToTypescriptValue(message2)})`);
  }
  return checks.join("");
}, "generateArrayChecks");

// src/transforms/zui-to-typescript-schema/set-checks.ts
var generateSetChecks = /* @__PURE__ */ __name((def) => {
  const checks = [];
  if (def.minSize) {
    const { value, message: message2 } = def.minSize;
    checks.push(`.min(${primitiveToTypescriptValue(value)}, ${primitiveToTypescriptValue(message2)})`);
  }
  if (def.maxSize) {
    const { value, message: message2 } = def.maxSize;
    checks.push(`.max(${primitiveToTypescriptValue(value)}, ${primitiveToTypescriptValue(message2)})`);
  }
  return checks.join("");
}, "generateSetChecks");

// src/transforms/zui-to-typescript-schema/index.ts
function toTypescriptSchema(schema) {
  let wrappedSchema = schema;
  let dts = sUnwrapZod2(wrappedSchema);
  return dts;
}
__name(toTypescriptSchema, "toTypescriptSchema");
function sUnwrapZod2(schema) {
  const schemaTyped = schema;
  const def = schemaTyped._def;
  switch (def.typeName) {
    case z_default.ZodFirstPartyTypeKind.ZodString:
      return `z.string()${generateStringChecks(def)}${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNumber:
      return `z.number()${generateNumberChecks(def)}${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNaN:
      return `z.nan()${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBigInt:
      return `z.bigint()${generateBigIntChecks(def)}${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBoolean:
      return `z.boolean()${_addZuiExtensions(def)}${_maybeDescribe(schema._def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDate:
      return `z.date()${generateDateChecks(def)}${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUndefined:
      return `z.undefined()${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNull:
      return `z.null()${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodAny:
      return `z.any()${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnknown:
      return `z.unknown()${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNever:
      return `z.never()${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodVoid:
      return `z.void()${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodArray:
      return `z.array(${sUnwrapZod2(def.type)})${generateArrayChecks(def)}${_addZuiExtensions(def)}${_maybeDescribe(def)}`;
    case z_default.ZodFirstPartyTypeKind.ZodObject:
      const props = mapValues_default(def.shape(), sUnwrapZod2);
      const catchall = schema.additionalProperties();
      const catchallString = catchall ? `.catchall(${sUnwrapZod2(catchall)})` : "";
      return [
        //
        `z.object({`,
        ...Object.entries(props).map(([key, value2]) => `  ${key}: ${value2},`),
        `})${catchallString}${_addZuiExtensions(def)}${_maybeDescribe(def)}`
      ].join("\n").trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnion:
      const options = def.options.map(sUnwrapZod2);
      return `z.union([${options.join(", ")}])${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      const opts = def.options.map(sUnwrapZod2);
      const discriminator = primitiveToTypescriptValue(def.discriminator);
      return `z.discriminatedUnion(${discriminator}, [${opts.join(", ")}])${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodIntersection:
      const left = sUnwrapZod2(def.left);
      const right = sUnwrapZod2(def.right);
      return `z.intersection(${left}, ${right})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodTuple:
      const items = def.items.map(sUnwrapZod2);
      return `z.tuple([${items.join(", ")}])${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodRecord:
      const keyType = sUnwrapZod2(def.keyType);
      const valueType = sUnwrapZod2(def.valueType);
      return `z.record(${keyType}, ${valueType})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodMap:
      const mapKeyType = sUnwrapZod2(def.keyType);
      const mapValueType = sUnwrapZod2(def.valueType);
      return `z.map(${mapKeyType}, ${mapValueType})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodSet:
      return `z.set(${sUnwrapZod2(def.valueType)})${generateSetChecks(def)}${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodFunction:
      const args = def.args.items.map(sUnwrapZod2);
      const argsString = args.length ? `.args(${args.join(", ")})` : "";
      const returns = sUnwrapZod2(def.returns);
      return `z.function()${argsString}.returns(${returns})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodLazy:
      return `z.lazy(() => ${sUnwrapZod2(def.getter())})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodLiteral:
      const value = primitiveToTypescriptValue(def.value);
      return `z.literal(${value})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEnum:
      const values = def.values.map(primitiveToTypescriptValue);
      return `z.enum([${values.join(", ")}])${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEffects:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodEffects);
    case z_default.ZodFirstPartyTypeKind.ZodNativeEnum:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodNativeEnum);
    case z_default.ZodFirstPartyTypeKind.ZodOptional:
      return `z.optional(${sUnwrapZod2(def.innerType)})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNullable:
      return `z.nullable(${sUnwrapZod2(def.innerType)})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDefault:
      const defaultValue = unknownToTypescriptValue(def.defaultValue());
      return `z.default(${sUnwrapZod2(def.innerType)}, ${defaultValue})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodCatch:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodCatch);
    case z_default.ZodFirstPartyTypeKind.ZodPromise:
      return `z.promise(${sUnwrapZod2(def.type)})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBranded:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodBranded);
    case z_default.ZodFirstPartyTypeKind.ZodPipeline:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodPipeline);
    case z_default.ZodFirstPartyTypeKind.ZodSymbol:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodSymbol);
    case z_default.ZodFirstPartyTypeKind.ZodReadonly:
      return `z.readonly(${sUnwrapZod2(def.innerType)})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodRef:
      const uri = primitiveToTypescriptValue(def.uri);
      return `z.ref(${uri})${_addZuiExtensions(def)}${_maybeDescribe(def)}`.trim();
    default:
      util.assertNever(def);
  }
}
__name(sUnwrapZod2, "sUnwrapZod");
var _maybeDescribe = /* @__PURE__ */ __name((def) => def.description ? `.describe(${primitiveToTypescriptValue(def.description)})` : "", "_maybeDescribe");
var _addZuiExtensions = /* @__PURE__ */ __name((def) => `${_maybeTitle(def)}${_maybeDisplayAs(def)}${_maybeDisabled(def)}${_maybeHidden(def)}${_maybePlaceholder(def)}${_maybeSecret(def)}${_maybeSetMetadata(def)}`, "_addZuiExtensions");
var _maybeTitle = /* @__PURE__ */ __name((def) => {
  var _a;
  return ((_a = def[zuiKey]) == null ? void 0 : _a.title) ? `.title(${primitiveToTypescriptValue(def[zuiKey].title)})` : "";
}, "_maybeTitle");
var _maybeDisplayAs = /* @__PURE__ */ __name((def) => {
  var _a;
  return ((_a = def[zuiKey]) == null ? void 0 : _a.displayAs) ? `.displayAs(${recordOfUnknownToTypescriptRecord({ id: def[zuiKey].displayAs[0], params: def[zuiKey].displayAs[1] })})` : "";
}, "_maybeDisplayAs");
var _maybeDisabled = /* @__PURE__ */ __name((def) => {
  var _a;
  return ((_a = def[zuiKey]) == null ? void 0 : _a.disabled) ? `.disabled(${def[zuiKey].disabled})` : "";
}, "_maybeDisabled");
var _maybeHidden = /* @__PURE__ */ __name((def) => {
  var _a;
  return ((_a = def[zuiKey]) == null ? void 0 : _a.hidden) ? `.hidden(${def[zuiKey].hidden})` : "";
}, "_maybeHidden");
var _maybePlaceholder = /* @__PURE__ */ __name((def) => {
  var _a;
  return ((_a = def[zuiKey]) == null ? void 0 : _a.placeholder) ? `.placeholder(${primitiveToTypescriptValue(def[zuiKey].placeholder)})` : "";
}, "_maybePlaceholder");
var _maybeSecret = /* @__PURE__ */ __name((def) => {
  var _a;
  return ((_a = def[zuiKey]) == null ? void 0 : _a.secret) ? ".secret()" : "";
}, "_maybeSecret");
var _maybeSetMetadata = /* @__PURE__ */ __name((def) => {
  var _a;
  const reservedKeys = [
    "title",
    "tooltip",
    "displayAs",
    "disabled",
    "hidden",
    "placeholder",
    "secret",
    "coerce"
  ];
  const metadata = Object.entries((_a = def[zuiKey]) != null ? _a : {}).filter(
    ([key]) => !reservedKeys.includes(key)
  );
  return metadata.length > 0 ? `.metadata(${recordOfUnknownToTypescriptRecord(Object.fromEntries(metadata))})` : "";
}, "_maybeSetMetadata");

// src/transforms/zui-to-json-schema/type-processors/number.ts
var zodNumberToJsonNumber = /* @__PURE__ */ __name((zodNumber) => {
  const schema = {
    type: "number",
    description: zodNumber.description,
    "x-zui": zodNumber._def["x-zui"]
  };
  if (zodNumber._def[zuiKey]) {
    schema[zuiKey] = zodNumber._def[zuiKey];
  }
  for (const check of zodNumber._def.checks) {
    switch (check.kind) {
      case "min": {
        const key = check.inclusive ? "minimum" : "exclusiveMinimum";
        const oppositeKey = check.inclusive ? "exclusiveMinimum" : "minimum";
        schema[key] = check.value;
        delete schema[oppositeKey];
        break;
      }
      case "max": {
        const key = check.inclusive ? "maximum" : "exclusiveMaximum";
        const oppositeKey = check.inclusive ? "exclusiveMaximum" : "maximum";
        schema[key] = check.value;
        delete schema[oppositeKey];
        break;
      }
      case "int":
        schema.type = "integer";
        break;
      case "finite": {
        schema.format = "finite";
        break;
      }
      case "multipleOf":
        schema.multipleOf = check.value;
        break;
      default:
        check;
    }
  }
  return schema;
}, "zodNumberToJsonNumber");

// src/z/types/string/datetime.ts
var DATETIME_REGEX_BASE = `\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}`;
var DATETIME_REGEX_OFFSET = `(([+-]\\d{2}(:?\\d{2})?)|Z)`;
var DATETIME_REGEX_OFFSET_NONE = `Z`;
var DATETIME_REGEX_PRECISION_ARBITRARY = `(\\.\\d+)?`;
var DATETIME_REGEX_PRECISION_SPECIFIC_BEGIN = `\\.\\d{`;
var DATETIME_REGEX_PRECISION_SPECIFIC_END = `}`;
var generateDatetimeRegex = /* @__PURE__ */ __name((args) => {
  const precision = args.precision ? DATETIME_REGEX_PRECISION_SPECIFIC_BEGIN + args.precision + DATETIME_REGEX_PRECISION_SPECIFIC_END : args.precision === 0 ? "" : DATETIME_REGEX_PRECISION_ARBITRARY;
  const offset = args.offset ? DATETIME_REGEX_OFFSET : DATETIME_REGEX_OFFSET_NONE;
  return new RegExp(`^${DATETIME_REGEX_BASE}${precision}${offset}$`);
}, "generateDatetimeRegex");
var extractPrecisionAndOffset = /* @__PURE__ */ __name((regexSource) => ({
  precision: _extractPrecision(regexSource),
  offset: regexSource.endsWith(`${DATETIME_REGEX_OFFSET}$`)
}), "extractPrecisionAndOffset");
var _extractPrecision = /* @__PURE__ */ __name((regexSource) => {
  const slicedRegex = regexSource.slice(1 + DATETIME_REGEX_BASE.length);
  if (slicedRegex.startsWith(DATETIME_REGEX_PRECISION_ARBITRARY)) {
    return null;
  } else if (slicedRegex.startsWith(DATETIME_REGEX_PRECISION_SPECIFIC_BEGIN)) {
    return parseInt(slicedRegex.slice(DATETIME_REGEX_PRECISION_SPECIFIC_BEGIN.length));
  }
  return 0;
}, "_extractPrecision");

// src/transforms/common/regex-utils/index.ts
var regex_utils_exports = {};
__export(regex_utils_exports, {
  escapeSpecialChars: () => escapeSpecialChars
});

// src/transforms/common/regex-utils/escape-special-chars.ts
var escapeSpecialChars = /* @__PURE__ */ __name((unsafeString) => unsafeString.replaceAll(/[.*+?^${}()|[\]\\]/g, "\\$&"), "escapeSpecialChars");

// src/transforms/zui-to-json-schema-legacy/errorMessages.ts
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages)) return;
  if (errorMessage) {
    res.errorMessage = __spreadProps(__spreadValues({}, res.errorMessage), {
      [key]: errorMessage
    });
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");

// src/transforms/zui-to-json-schema-legacy/parsers/string.ts
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function parseStringDef(def, refs) {
  const res = __spreadValues({
    type: "string"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? regex_utils_exports.escapeSpecialChars(value) : value;
  }
  __name(processPattern, "processPattern");
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex.source, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, "^" + processPattern(check.value), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, processPattern(check.value) + "$", check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "includes": {
          addPattern(res, processPattern(check.value), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ;
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
var addFormat = /* @__PURE__ */ __name((schema, value, message2, refs) => {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push(__spreadValues({
        format: schema.format
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { format: schema.errorMessage.format }
      }));
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push(__spreadValues({
      format: value
    }, message2 && refs.errorMessages && { errorMessage: { format: message2 } }));
  } else {
    setResponseValueAndErrors(schema, "format", value, message2, refs);
  }
}, "addFormat");
var addPattern = /* @__PURE__ */ __name((schema, value, message2, refs) => {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push(__spreadValues({
        pattern: schema.pattern
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { pattern: schema.errorMessage.pattern }
      }));
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push(__spreadValues({
      pattern: value
    }, message2 && refs.errorMessages && { errorMessage: { pattern: message2 } }));
  } else {
    setResponseValueAndErrors(schema, "pattern", value, message2, refs);
  }
}, "addPattern");

// src/transforms/zui-to-json-schema/type-processors/string.ts
var zodStringToJsonString = /* @__PURE__ */ __name((zodString) => {
  const schema = {
    type: "string",
    description: zodString.description,
    "x-zui": zodString._def["x-zui"]
  };
  if (zodString._def[zuiKey]) {
    schema[zuiKey] = zodString._def[zuiKey];
  }
  for (const check of zodString._def.checks) {
    switch (check.kind) {
      case "cuid":
        schema.format = "cuid";
        schema.pattern = zodPatterns.cuid;
        break;
      case "cuid2":
        schema.format = "cuid2";
        schema.pattern = zodPatterns.cuid2;
        break;
      case "ulid":
        schema.format = "ulid";
        schema.pattern = zodPatterns.ulid;
        break;
      case "uuid":
        schema.format = "uuid";
        schema.pattern = zodPatterns.uuid;
        break;
      case "emoji":
        schema.format = "emoji";
        schema.pattern = zodPatterns.emoji;
        break;
      case "email":
        schema.format = "email";
        schema.pattern = zodPatterns.email;
        break;
      case "ip":
        schema.format = check.version === "v6" ? "ipv6" : "ipv4";
        schema.pattern = check.version === "v6" ? zodPatterns.ipv6 : zodPatterns.ipv4;
        break;
      case "datetime":
        schema.format = "date-time";
        schema.pattern = generateDatetimeRegex(check).source;
        schema[zuiKey] = __spreadProps(__spreadValues({}, schema[zuiKey]), { precision: check.precision, offset: check.offset });
        break;
      case "url":
        schema.format = "uri";
        break;
      case "endsWith":
        schema.pattern = `${regex_utils_exports.escapeSpecialChars(check.value)}$`;
        break;
      case "startsWith":
        schema.pattern = `^${regex_utils_exports.escapeSpecialChars(check.value)}`;
        break;
      case "includes":
        const positionPredicate = check.position && check.position >= 1 ? `^(?:.{${check.position}}).*` : "";
        schema.pattern = `${positionPredicate}${regex_utils_exports.escapeSpecialChars(check.value)}`;
        break;
      case "regex":
        schema.pattern = check.regex.source;
        break;
      case "length":
        schema.minLength = schema.maxLength = Math.max(0, check.value);
        break;
      case "min":
        schema.minLength = Math.max(0, check.value);
        break;
      case "max":
        schema.maxLength = Math.max(0, check.value);
        break;
      default:
        throw new UnsupportedZuiCheckToJSONSchemaError({
          zodType: z_default.ZodFirstPartyTypeKind.ZodString,
          checkKind: check.kind
        });
    }
  }
  return schema;
}, "zodStringToJsonString");

// src/transforms/zui-to-json-schema/type-processors/array.ts
var zodArrayToJsonArray = /* @__PURE__ */ __name((zodArray, toSchema) => {
  const schema = {
    type: "array",
    description: zodArray.description,
    items: toSchema(zodArray._def.type),
    "x-zui": zodArray._def["x-zui"]
  };
  if (zodArray._def[zuiKey]) {
    schema[zuiKey] = zodArray._def[zuiKey];
  }
  if (zodArray._def.minLength) {
    schema.minItems = zodArray._def.minLength.value;
  }
  if (zodArray._def.maxLength) {
    schema.maxItems = zodArray._def.maxLength.value;
  }
  if (zodArray._def.exactLength) {
    schema.minItems = zodArray._def.exactLength.value;
    schema.maxItems = zodArray._def.exactLength.value;
  }
  return schema;
}, "zodArrayToJsonArray");

// src/transforms/zui-to-json-schema/type-processors/set.ts
var zodSetToJsonSet = /* @__PURE__ */ __name((zodSet, toSchema) => {
  const schema = {
    type: "array",
    description: zodSet.description,
    uniqueItems: true,
    items: toSchema(zodSet._def.valueType),
    "x-zui": zodSet._def["x-zui"]
  };
  if (zodSet._def[zuiKey]) {
    schema[zuiKey] = zodSet._def[zuiKey];
  }
  if (zodSet._def.minSize) {
    schema.minItems = zodSet._def.minSize.value;
  }
  if (zodSet._def.maxSize) {
    schema.maxItems = zodSet._def.maxSize.value;
  }
  return schema;
}, "zodSetToJsonSet");

// src/transforms/zui-to-json-schema/type-processors/tuple.ts
var zodTupleToJsonTuple = /* @__PURE__ */ __name((zodTuple, toSchema) => {
  const schema = {
    type: "array",
    description: zodTuple.description,
    items: zodTuple._def.items.map((item) => toSchema(item))
  };
  if (zodTuple._def[zuiKey]) {
    schema[zuiKey] = zodTuple._def[zuiKey];
  }
  if (zodTuple._def.rest) {
    schema.additionalItems = toSchema(zodTuple._def.rest);
  }
  return schema;
}, "zodTupleToJsonTuple");

// src/transforms/zui-to-json-schema/index.ts
function toJSONSchema(schema) {
  const schemaTyped = schema;
  const def = schemaTyped._def;
  switch (def.typeName) {
    case z_default.ZodFirstPartyTypeKind.ZodString:
      return zodStringToJsonString(schemaTyped);
    case z_default.ZodFirstPartyTypeKind.ZodNumber:
      return zodNumberToJsonNumber(schemaTyped);
    case z_default.ZodFirstPartyTypeKind.ZodNaN:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodNaN);
    case z_default.ZodFirstPartyTypeKind.ZodBigInt:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodBigInt, {
        suggestedAlternative: "serialize bigint to string"
      });
    case z_default.ZodFirstPartyTypeKind.ZodBoolean:
      return {
        type: "boolean",
        description: def.description,
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodDate:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodDate, {
        suggestedAlternative: "use z.string().datetime() instead"
      });
    case z_default.ZodFirstPartyTypeKind.ZodUndefined:
      return undefinedSchema(def);
    case z_default.ZodFirstPartyTypeKind.ZodNull:
      return nullSchema(def);
    case z_default.ZodFirstPartyTypeKind.ZodAny:
      return {
        description: def.description,
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodUnknown:
      return {
        description: def.description,
        "x-zui": __spreadProps(__spreadValues({}, def["x-zui"]), { def: { typeName: z_default.ZodFirstPartyTypeKind.ZodUnknown } })
      };
    case z_default.ZodFirstPartyTypeKind.ZodNever:
      return {
        not: true,
        description: def.description,
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodVoid:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodVoid);
    case z_default.ZodFirstPartyTypeKind.ZodArray:
      return zodArrayToJsonArray(schemaTyped, toJSONSchema);
    case z_default.ZodFirstPartyTypeKind.ZodObject:
      const shape = Object.entries(def.shape());
      const requiredProperties = shape.filter(([_, value]) => !value.isOptional());
      const required = requiredProperties.length ? requiredProperties.map(([key]) => key) : void 0;
      const properties = shape.map(([key, value]) => [key, value.mandatory()]).map(([key, value]) => [key, toJSONSchema(value)]);
      let additionalProperties = false;
      if (def.unknownKeys instanceof z_default.ZodType) {
        additionalProperties = toJSONSchema(def.unknownKeys);
      } else if (def.unknownKeys === "passthrough") {
        additionalProperties = true;
      }
      return {
        type: "object",
        description: def.description,
        properties: Object.fromEntries(properties),
        required,
        additionalProperties,
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodUnion:
      return {
        description: def.description,
        anyOf: def.options.map((option) => toJSONSchema(option)),
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return {
        description: def.description,
        anyOf: def.options.map((option) => toJSONSchema(option)),
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodIntersection:
      const left = toJSONSchema(def.left);
      const right = toJSONSchema(def.right);
      if ("additionalProperties" in left) {
        delete left.additionalProperties;
      }
      if ("additionalProperties" in right) {
        delete right.additionalProperties;
      }
      return {
        description: def.description,
        allOf: [left, right],
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodTuple:
      return zodTupleToJsonTuple(schemaTyped, toJSONSchema);
    case z_default.ZodFirstPartyTypeKind.ZodRecord:
      return {
        type: "object",
        description: def.description,
        additionalProperties: toJSONSchema(def.valueType),
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodMap:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodMap);
    case z_default.ZodFirstPartyTypeKind.ZodSet:
      return zodSetToJsonSet(schemaTyped, toJSONSchema);
    case z_default.ZodFirstPartyTypeKind.ZodFunction:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodFunction);
    case z_default.ZodFirstPartyTypeKind.ZodLazy:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodLazy);
    case z_default.ZodFirstPartyTypeKind.ZodLiteral:
      if (typeof def.value === "string") {
        return {
          type: "string",
          description: def.description,
          const: def.value,
          "x-zui": def["x-zui"]
        };
      } else if (typeof def.value === "number") {
        return {
          type: "number",
          description: def.description,
          const: def.value,
          "x-zui": def["x-zui"]
        };
      } else if (typeof def.value === "boolean") {
        return {
          type: "boolean",
          description: def.description,
          const: def.value,
          "x-zui": def["x-zui"]
        };
      } else if (def.value === null) {
        return nullSchema(def);
      } else if (def.value === void 0) {
        return undefinedSchema(def);
      } else {
        z_default.util.assertEqual(true);
        const unsupportedLiteral = typeof def.value;
        throw new ZuiToJSONSchemaError(`Unsupported literal type: "${unsupportedLiteral}"`);
      }
    case z_default.ZodFirstPartyTypeKind.ZodEnum:
      return {
        type: "string",
        description: def.description,
        enum: def.values,
        "x-zui": def["x-zui"]
      };
    case z_default.ZodFirstPartyTypeKind.ZodEffects:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodEffects);
    case z_default.ZodFirstPartyTypeKind.ZodNativeEnum:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodNativeEnum);
    case z_default.ZodFirstPartyTypeKind.ZodOptional:
      return {
        description: def.description,
        anyOf: [toJSONSchema(def.innerType), undefinedSchema()],
        "x-zui": __spreadProps(__spreadValues({}, def["x-zui"]), {
          def: { typeName: z_default.ZodFirstPartyTypeKind.ZodOptional }
        })
      };
    case z_default.ZodFirstPartyTypeKind.ZodNullable:
      return {
        anyOf: [toJSONSchema(def.innerType), nullSchema()],
        "x-zui": __spreadProps(__spreadValues({}, def["x-zui"]), {
          def: { typeName: z_default.ZodFirstPartyTypeKind.ZodNullable }
        })
      };
    case z_default.ZodFirstPartyTypeKind.ZodDefault:
      return __spreadProps(__spreadValues({}, toJSONSchema(def.innerType)), {
        default: def.defaultValue()
      });
    case z_default.ZodFirstPartyTypeKind.ZodCatch:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodCatch);
    case z_default.ZodFirstPartyTypeKind.ZodPromise:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodPromise);
    case z_default.ZodFirstPartyTypeKind.ZodBranded:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodBranded);
    case z_default.ZodFirstPartyTypeKind.ZodPipeline:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodPipeline);
    case z_default.ZodFirstPartyTypeKind.ZodSymbol:
      throw new UnsupportedZuiToJSONSchemaError(z_default.ZodFirstPartyTypeKind.ZodPipeline);
    case z_default.ZodFirstPartyTypeKind.ZodReadonly:
      return __spreadProps(__spreadValues({}, toJSONSchema(def.innerType)), {
        readOnly: true
      });
    case z_default.ZodFirstPartyTypeKind.ZodRef:
      return {
        $ref: def.uri,
        description: def.description,
        "x-zui": def["x-zui"]
      };
    default:
      z_default.util.assertNever(def);
  }
}
__name(toJSONSchema, "toJSONSchema");
var undefinedSchema = /* @__PURE__ */ __name((def) => ({
  not: true,
  description: def == null ? void 0 : def.description,
  "x-zui": __spreadProps(__spreadValues({}, def == null ? void 0 : def["x-zui"]), { def: { typeName: z_default.ZodFirstPartyTypeKind.ZodUndefined } })
}), "undefinedSchema");
var nullSchema = /* @__PURE__ */ __name((def) => ({
  type: "null",
  description: def == null ? void 0 : def.description,
  "x-zui": def == null ? void 0 : def["x-zui"]
}), "nullSchema");

// src/z/types/basetype/index.ts
var _ParseInputLazyPath = class _ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
__name(_ParseInputLazyPath, "ParseInputLazyPath");
var ParseInputLazyPath = _ParseInputLazyPath;
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error) return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
var _ZodType = class _ZodType {
  constructor(def) {
    this.__type__ = "ZuiType";
    /** Alias of safeParseAsync */
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._metadataRoot._def.description;
  }
  /** deeply replace all references in the schema */
  dereference(_defs) {
    return this;
  }
  /** deeply scans the schema to check if it contains references */
  getReferences() {
    return [];
  }
  clone() {
    const This = this.constructor;
    return new This(__spreadValues({}, this._def));
  }
  _getType(input4) {
    return getParsedType(input4.data);
  }
  _getOrReturnCtx(input4, ctx) {
    return ctx || {
      common: input4.parent.common,
      data: input4.data,
      parsedType: getParsedType(input4.data),
      schemaErrorMap: this._def.errorMap,
      path: input4.path,
      parent: input4.parent
    };
  }
  _processInputParams(input4) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input4.parent.common,
        data: input4.data,
        parsedType: getParsedType(input4.data),
        schemaErrorMap: this._def.errorMap,
        path: input4.path,
        parent: input4.parent
      }
    };
  }
  _parseSync(input4) {
    const result = this._parse(input4);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input4) {
    const result = this._parse(input4);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params == null ? void 0 : params.async) != null ? _a : false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue(__spreadValues({
        code: ZodIssueCode.custom
      }, getIssueProperties(val))), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  /**
   * # \#\#\# Experimental \#\#\#
   *
   * @experimental This function is experimental and is subject to breaking changes in the future.
   *
   * Would have been named `required` but a method with that name already exists in ZodObject.
   * Makes the schema required; i.e. not optional or undefined. If the schema is already required than it returns itself.
   * Null is not considered optional and remains unchanged.
   *
   * @example z.string().optional().mandatory() // z.string()
   * @example z.string().nullable().mandatory() // z.string().nullable()
   * @example z.string().or(z.undefined()).mandatory() // z.string()
   * @example z.union([z.string(), z.number(), z.undefined()]).mandatory() // z.union([z.string(), z.number()])
   */
  mandatory() {
    return this;
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "transform", transform }
    }));
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: "ZodDefault" /* ZodDefault */
    }));
  }
  brand() {
    return new ZodBranded(__spreadValues({
      typeName: "ZodBranded" /* ZodBranded */,
      type: this
    }, processCreateParams(this._def)));
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      catchValue: catchValueFunc,
      typeName: "ZodCatch" /* ZodCatch */
    }));
  }
  describe(description) {
    const clone = this.clone();
    clone._metadataRoot._def.description = description;
    return clone;
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
  // BOTPRESS EXTENSIONS
  /** append metadata to the schema */
  metadata(data) {
    var _a, _b, _c;
    const clone = this.clone();
    const root2 = clone._metadataRoot;
    (_c = (_a = root2._def)[_b = zuiKey]) != null ? _c : _a[_b] = {};
    for (const [key, value] of Object.entries(data)) {
      root2._def[zuiKey] = __spreadProps(__spreadValues({}, root2._def[zuiKey]), {
        [key]: value
      });
    }
    return clone;
  }
  /** get metadata of the schema */
  getMetadata() {
    return __spreadValues({}, this._metadataRoot._def[zuiKey]);
  }
  /** set metadata of the schema */
  setMetadata(data) {
    this._metadataRoot._def[zuiKey] = __spreadValues({}, data);
  }
  /**
   * get metadata of the schema
   * @deprecated use `getMetadata()` instead
   */
  get ui() {
    return __spreadValues({}, this._metadataRoot._def[zuiKey]);
  }
  /**
   * Some Schemas aren't meant to contain metadata, like ZodDefault.
   * In a zui construction like `z.string().default('hello').title('Hello')`, the user's intention is usually to set a title on the string, not on the default value.
   * Also, in JSON-Schema, default is not a data-type like it is in Zui, but an annotation added on the schema itself. Therefore, only one metadata can apply to both the schema and the default value.
   * This property is used to get the root schema that should contain the metadata.
   */
  get _metadataRoot() {
    return this.naked();
  }
  /**
   * The type of component to use to display the field and its options
   */
  displayAs(options) {
    return this.metadata({ displayAs: [options.id, options.params] });
  }
  /**
   * The title of the field. Defaults to the field name.
   */
  title(title) {
    return this.metadata({ title });
  }
  /**
   * Whether the field is hidden in the UI. Useful for internal fields.
   * @default false
   */
  hidden(value) {
    let data;
    if (value === void 0) {
      data = true;
    } else if (typeof value === "function") {
      data = value.toString();
    } else {
      data = value;
    }
    return this.metadata({ hidden: data });
  }
  /**
   * Whether the field is disabled
   * @default false
   */
  disabled(value) {
    let data;
    if (value === void 0) {
      data = true;
    } else if (typeof value === "function") {
      data = value.toString();
    } else {
      data = value;
    }
    return this.metadata({ disabled: data });
  }
  /**
   * Placeholder text for the field
   */
  placeholder(placeholder) {
    return this.metadata({ placeholder });
  }
  /**
   *
   * @returns a JSON Schema equivalent to the Zui schema
   */
  toJSONSchema() {
    return toJSONSchema(this);
  }
  /**
   *
   * @param options generation options
   * @returns a string of the TypeScript type representing the schema
   */
  toTypescriptType(opts) {
    return toTypescriptType(this, opts);
  }
  /**
   *
   * @param options generation options
   * @returns a typescript program (a string) that would construct the given schema if executed
   */
  toTypescriptSchema() {
    return toTypescriptSchema(this);
  }
  /**
   * Allows removing all wrappers around the schema
   * @returns either this or the closest children schema that represents the actual data
   */
  naked() {
    return this;
  }
};
__name(_ZodType, "ZodType");
var ZodType = _ZodType;

// src/z/types/defs.ts
var ZodFirstPartyTypeKind = /* @__PURE__ */ ((ZodFirstPartyTypeKind3) => {
  ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind3["ZodRef"] = "ZodRef";
  ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
  return ZodFirstPartyTypeKind3;
})(ZodFirstPartyTypeKind || {});

// src/z/types/utils/index.ts
var util;
((util4) => {
  util4.assertEqual = /* @__PURE__ */ __name((val) => val, "assertEqual");
  function assertIs(_arg) {
  }
  util4.assertIs = assertIs;
  __name(assertIs, "assertIs");
  function assertNever(_x) {
    throw new Error("assertNever called");
  }
  util4.assertNever = assertNever;
  __name(assertNever, "assertNever");
  util4.arrayToEnum = /* @__PURE__ */ __name((items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  }, "arrayToEnum");
  util4.getValidEnumValues = /* @__PURE__ */ __name((obj) => {
    const validKeys = (0, util4.objectKeys)(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return (0, util4.objectValues)(filtered);
  }, "getValidEnumValues");
  util4.objectValues = /* @__PURE__ */ __name((obj) => {
    return (0, util4.objectKeys)(obj).map(function(e) {
      return obj[e];
    });
  }, "objectValues");
  util4.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util4.find = /* @__PURE__ */ __name((arr, checker) => {
    for (const item of arr) {
      if (checker(item)) return item;
    }
    return void 0;
  }, "find");
  util4.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util4.joinValues = joinValues;
  __name(joinValues, "joinValues");
  util4.jsonStringifyReplacer = /* @__PURE__ */ __name((_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  }, "jsonStringifyReplacer");
  util4.compareFunctions = /* @__PURE__ */ __name((a, b) => {
    return a.toString() === b.toString();
  }, "compareFunctions");
  util4.mock = /* @__PURE__ */ __name(() => ({}), "mock");
})(util || (util = {}));
var objectUtil;
((objectUtil3) => {
  objectUtil3.mergeShapes = /* @__PURE__ */ __name((first, second) => {
    return __spreadValues(__spreadValues({}, first), second);
  }, "mergeShapes");
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
function processCreateParams(params) {
  if (!params) return {};
  const {
    errorMap: errorMap2,
    invalid_type_error,
    required_error,
    description,
    supportsExtensions,
    [zuiKey]: zuiExtensions
  } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  const filteredZuiExtensions = zuiExtensions ? Object.fromEntries(
    Object.entries(zuiExtensions).filter(([key]) => key !== "secret" || (supportsExtensions == null ? void 0 : supportsExtensions.includes("secret")))
  ) : void 0;
  if (errorMap2) return { errorMap: errorMap2, description, [zuiKey]: filteredZuiExtensions };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error != null ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error != null ? invalid_type_error : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description, [zuiKey]: filteredZuiExtensions };
}
__name(processCreateParams, "processCreateParams");

// src/z/types/error/locales/en.ts
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    case ZodIssueCode.unresolved_reference:
      message2 = "Unresolved reference";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
}, "errorMap");
var en_default = errorMap;

// src/z/types/error/index.ts
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite",
  "unresolved_reference"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var _ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = /* @__PURE__ */ __name((sub) => {
      this.issues = [...this.issues, sub];
    }, "addIssue");
    this.addIssues = /* @__PURE__ */ __name((subs = []) => {
      this.issues = [...this.issues, ...subs];
    }, "addIssues");
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(_ZodError, "ZodError");
_ZodError.create = /* @__PURE__ */ __name((issues) => {
  const error = new _ZodError(issues);
  return error;
}, "create");
var ZodError = _ZodError;
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// src/z/types/utils/parseUtil.ts
var makeIssue = /* @__PURE__ */ __name((params) => {
  var _a;
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps(__spreadValues({}, issueData), {
    path: fullPath
  });
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return __spreadProps(__spreadValues({}, issueData), {
    path: fullPath,
    message: (_a = issueData.message) != null ? _a : errorMessage
  });
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      getErrorMap(),
      // then global override map
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var _ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted") return INVALID;
      if (s.status === "dirty") status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted") return INVALID;
      if (value.status === "aborted") return INVALID;
      if (key.status === "dirty") status.dirty();
      if (value.status === "dirty") status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
__name(_ParseStatus, "ParseStatus");
var ParseStatus = _ParseStatus;
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// src/z/types/utils/errorUtil.ts
var errorUtil;
((errorUtil2) => {
  errorUtil2.errToObj = /* @__PURE__ */ __name((message2) => typeof message2 === "string" ? { message: message2 } : message2 || {}, "errToObj");
  errorUtil2.toString = /* @__PURE__ */ __name((message2) => typeof message2 === "string" ? message2 : message2 == null ? void 0 : message2.message, "toString");
})(errorUtil || (errorUtil = {}));

// src/z/types/any/index.ts
var _ZodAny = class _ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
    this._any = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodAny;
  }
};
__name(_ZodAny, "ZodAny");
_ZodAny.create = /* @__PURE__ */ __name((params) => {
  return new _ZodAny(__spreadValues({
    typeName: "ZodAny" /* ZodAny */
  }, processCreateParams(params)));
}, "create");
var ZodAny = _ZodAny;

// src/z/types/array/index.ts
var _ZodArray = class _ZodArray extends ZodType {
  dereference(defs) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  clone() {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.clone()
    }));
  }
  isEqual(schema) {
    var _a, _b, _c, _d, _e, _f;
    if (!(schema instanceof _ZodArray)) {
      return false;
    }
    return (
      // message is not considered for equality
      isEqual_default((_a = this._def.exactLength) == null ? void 0 : _a.value, (_b = schema._def.exactLength) == null ? void 0 : _b.value) && isEqual_default((_c = this._def.maxLength) == null ? void 0 : _c.value, (_d = schema._def.maxLength) == null ? void 0 : _d.value) && isEqual_default((_e = this._def.minLength) == null ? void 0 : _e.value, (_f = schema._def.minLength) == null ? void 0 : _f.value) && this._def.type.isEqual(schema._def.type)
    );
  }
  _parse(input4) {
    const { ctx, status } = this._processInputParams(input4);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(
        [...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })
      ).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    }));
  }
  max(maxLength, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    }));
  }
  length(len, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      exactLength: { value: len, message: errorUtil.toString(message2) }
    }));
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
__name(_ZodArray, "ZodArray");
_ZodArray.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodArray(__spreadValues({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: "ZodArray" /* ZodArray */
  }, processCreateParams(params)));
}, "create");
var ZodArray = _ZodArray;

// src/z/types/utils/is-equal.ts
var isEqual2 = /* @__PURE__ */ __name((a, b) => {
  return _isEqualWithVisitedTracking(a, b, /* @__PURE__ */ new WeakSet());
}, "isEqual");
var _isEqualWithVisitedTracking = /* @__PURE__ */ __name((a, b, visited) => isEqualWith_default(a, b, _customizerWithVisitedTracking(visited)), "_isEqualWithVisitedTracking");
var _customizerWithVisitedTracking = /* @__PURE__ */ __name((visited) => (a, b) => {
  if (isPlainObject_default(a) && !visited.has(a) && isPlainObject_default(b) && !visited.has(b)) {
    const cleanedA = omitBy_default(a, isUndefined_default);
    const cleanedB = omitBy_default(b, isUndefined_default);
    visited.add(cleanedA).add(cleanedB).add(a).add(b);
    return _isEqualWithVisitedTracking(cleanedA, cleanedB, visited);
  }
  return void 0;
}, "_customizerWithVisitedTracking");

// src/z/types/utils/custom-set.ts
var DEFAULT_OPTIONS = {
  compare: isEqual2
};
var _CustomSet = class _CustomSet {
  constructor(items = [], opt = {}) {
    this._options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), opt);
    this._items = [];
    for (const i of items) {
      this.add(i);
    }
  }
  get items() {
    return [...this._items];
  }
  get size() {
    return this._items.length;
  }
  has(item) {
    return this._items.some((i) => this._options.compare(i, item));
  }
  add(item) {
    if (!this.has(item)) {
      this._items.push(item);
    }
  }
  isEqual(other) {
    if (this.size !== other.size) {
      return false;
    }
    return this.isSubsetOf(other) && other.isSubsetOf(this);
  }
  isSubsetOf(other) {
    if (this.size > other.size) {
      return false;
    }
    return this._items.every((i) => other.has(i));
  }
};
__name(_CustomSet, "CustomSet");
var CustomSet = _CustomSet;

// src/z/types/bigint/index.ts
var _ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = BigInt(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input4.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodBigInt)) {
      return false;
    }
    if (this._def.coerce !== schema._def.coerce) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks);
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodBigInt, "ZodBigInt");
_ZodBigInt.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodBigInt(__spreadValues({
    checks: [],
    typeName: "ZodBigInt" /* ZodBigInt */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(params)));
}, "create");
var ZodBigInt = _ZodBigInt;

// src/z/types/boolean/index.ts
var _ZodBoolean = class _ZodBoolean extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Boolean(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodBoolean)) return false;
    return this._def.coerce === schema._def.coerce;
  }
};
__name(_ZodBoolean, "ZodBoolean");
_ZodBoolean.create = /* @__PURE__ */ __name((params) => {
  return new _ZodBoolean(__spreadValues({
    typeName: "ZodBoolean" /* ZodBoolean */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodBoolean = _ZodBoolean;

// src/z/types/branded/index.ts
var BRAND = Symbol("zod_brand");
var _ZodBranded = class _ZodBranded extends ZodType {
  dereference(defs) {
    return new _ZodBranded(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  clone() {
    return new _ZodBranded(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.clone()
    }));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodBranded)) return false;
    return this._def.type.isEqual(schema._def.type);
  }
  naked() {
    return this._def.type.naked();
  }
  mandatory() {
    return new _ZodBranded(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.mandatory()
    }));
  }
};
__name(_ZodBranded, "ZodBranded");
var ZodBranded = _ZodBranded;

// src/z/types/catch/index.ts
var _ZodCatch = class _ZodCatch extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const newCtx = __spreadProps(__spreadValues({}, ctx), {
      common: __spreadProps(__spreadValues({}, ctx.common), {
        issues: []
      })
    });
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: __spreadValues({}, newCtx)
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodCatch)) return false;
    return this._def.innerType.isEqual(schema._def.innerType) && util.compareFunctions(this._def.catchValue, schema._def.catchValue);
  }
  dereference(defs) {
    return new _ZodCatch(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  clone() {
    return new _ZodCatch(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.clone()
    }));
  }
  naked() {
    return this._def.innerType.naked();
  }
  mandatory() {
    return new _ZodCatch(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.mandatory()
    }));
  }
};
__name(_ZodCatch, "ZodCatch");
_ZodCatch.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodCatch(__spreadValues({
    innerType: type,
    typeName: "ZodCatch" /* ZodCatch */,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
  }, processCreateParams(params)));
}, "create");
var ZodCatch = _ZodCatch;

// src/z/types/custom/index.ts
var custom = /* @__PURE__ */ __name((check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) != null ? _a : fatal) != null ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
      }
    });
  return ZodAny.create();
}, "custom");

// src/z/types/date/index.ts
var _ZodDate = class _ZodDate extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = new Date(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input4.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input4.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodDate)) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks) && this._def.coerce === schema._def.coerce;
  }
};
__name(_ZodDate, "ZodDate");
_ZodDate.create = /* @__PURE__ */ __name((params) => {
  return new _ZodDate(__spreadValues({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: "ZodDate" /* ZodDate */
  }, processCreateParams(params)));
}, "create");
var ZodDate = _ZodDate;

// src/z/types/default/index.ts
var _ZodDefault = class _ZodDefault extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
  dereference(defs) {
    return new _ZodDefault(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  clone() {
    return new _ZodDefault(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.clone()
    }));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodDefault)) return false;
    return this._def.innerType.isEqual(schema._def.innerType) && isEqual_default(this._def.defaultValue(), schema._def.defaultValue());
  }
  unwrap() {
    return this._def.innerType;
  }
  naked() {
    return this._def.innerType.naked();
  }
  mandatory() {
    return new _ZodDefault(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.mandatory()
    }));
  }
};
__name(_ZodDefault, "ZodDefault");
_ZodDefault.create = /* @__PURE__ */ __name((type, value, params) => {
  return new _ZodDefault(__spreadValues({
    innerType: type,
    typeName: "ZodDefault" /* ZodDefault */,
    defaultValue: typeof value === "function" ? value : () => value
  }, processCreateParams(params)));
}, "create");
var ZodDefault = _ZodDefault;

// src/z/utils.ts
var unique = /* @__PURE__ */ __name((arr) => {
  return Array.from(new Set(arr));
}, "unique");

// src/z/types/discriminatedUnion/index.ts
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var _ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  dereference(defs) {
    const options = this.options.map((option) => option.dereference(defs));
    const optionsMap = _ZodDiscriminatedUnion._getOptionsMap(this.discriminator, options);
    return new _ZodDiscriminatedUnion(__spreadProps(__spreadValues({}, this._def), {
      options,
      optionsMap
    }));
  }
  getReferences() {
    return unique(this.options.flatMap((option) => option.getReferences()));
  }
  clone() {
    const options = this.options.map(
      (option) => option.clone()
    );
    return new _ZodDiscriminatedUnion(__spreadProps(__spreadValues({}, this._def), {
      options
    }));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = _ZodDiscriminatedUnion._getOptionsMap(discriminator, options);
    return new _ZodDiscriminatedUnion(__spreadValues({
      typeName: "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */,
      discriminator,
      options,
      optionsMap
    }, processCreateParams(params)));
  }
  static _getOptionsMap(discriminator, options) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(
          `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`
        );
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return optionsMap;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodDiscriminatedUnion)) return false;
    if (this._def.discriminator !== schema._def.discriminator) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisOptions = new CustomSet(this._def.options, { compare });
    const thatOptions = new CustomSet(schema._def.options, { compare });
    return thisOptions.isEqual(thatOptions);
  }
};
__name(_ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
var ZodDiscriminatedUnion = _ZodDiscriminatedUnion;

// src/z/types/enum/index.ts
function createZodEnum(values, params) {
  return new ZodEnum(__spreadValues({
    values,
    typeName: "ZodEnum" /* ZodEnum */
  }, processCreateParams(params)));
}
__name(createZodEnum, "createZodEnum");
var _ZodEnum = class _ZodEnum extends ZodType {
  _parse(input4) {
    if (typeof input4.data !== "string") {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input4.data) === -1) {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, __spreadValues(__spreadValues({}, this._def), newDef));
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), __spreadValues(__spreadValues({}, this._def), newDef));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodEnum)) return false;
    const thisValues = new CustomSet(this._def.values);
    const thatValues = new CustomSet(schema._def.values);
    return thisValues.isEqual(thatValues);
  }
};
__name(_ZodEnum, "ZodEnum");
_ZodEnum.create = createZodEnum;
var ZodEnum = _ZodEnum;

// src/z/types/function/index.ts
var _ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  dereference(defs) {
    const args = this._def.args.dereference(defs);
    const returns = this._def.returns.dereference(defs);
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args,
      returns
    }));
  }
  getReferences() {
    return unique([...this._def.args.getReferences(), ...this._def.returns.getReferences()]);
  }
  clone() {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: this._def.args.clone(),
      returns: this._def.returns.clone()
    }));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction(__spreadValues({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: "ZodFunction" /* ZodFunction */
    }, processCreateParams(params)));
  }
  isEqual(schema) {
    return schema instanceof _ZodFunction && this._def.args.isEqual(schema._def.args) && this._def.returns.isEqual(schema._def.returns);
  }
};
__name(_ZodFunction, "ZodFunction");
var ZodFunction = _ZodFunction;

// src/z/types/intersection/index.ts
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = __spreadValues(__spreadValues({}, a), b);
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var _ZodIntersection = class _ZodIntersection extends ZodType {
  dereference(defs) {
    return new _ZodIntersection(__spreadProps(__spreadValues({}, this._def), {
      left: this._def.left.dereference(defs),
      right: this._def.right.dereference(defs)
    }));
  }
  getReferences() {
    return unique([...this._def.left.getReferences(), ...this._def.right.getReferences()]);
  }
  clone() {
    return new _ZodIntersection(__spreadProps(__spreadValues({}, this._def), {
      left: this._def.left.clone(),
      right: this._def.right.clone()
    }));
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      );
    }
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodIntersection)) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisItems = new CustomSet([this._def.left, this._def.right], { compare });
    const thatItems = new CustomSet([schema._def.left, schema._def.right], { compare });
    return thisItems.isEqual(thatItems);
  }
};
__name(_ZodIntersection, "ZodIntersection");
_ZodIntersection.create = /* @__PURE__ */ __name((left, right, params) => {
  return new _ZodIntersection(__spreadValues({
    left,
    right,
    typeName: "ZodIntersection" /* ZodIntersection */
  }, processCreateParams(params)));
}, "create");
var ZodIntersection = _ZodIntersection;

// src/z/types/lazy/index.ts
var _ZodLazy = class _ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  dereference(defs) {
    return new _ZodLazy(__spreadProps(__spreadValues({}, this._def), {
      getter: /* @__PURE__ */ __name(() => this._def.getter().dereference(defs), "getter")
    }));
  }
  getReferences() {
    return this._def.getter().getReferences();
  }
  clone() {
    return new _ZodLazy(__spreadProps(__spreadValues({}, this._def), {
      getter: /* @__PURE__ */ __name(() => this._def.getter().clone(), "getter")
    }));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodLazy)) return false;
    return this._def.getter().isEqual(schema._def.getter());
  }
  naked() {
    return this._def.getter().naked();
  }
  mandatory() {
    return new _ZodLazy(__spreadProps(__spreadValues({}, this._def), {
      getter: /* @__PURE__ */ __name(() => this._def.getter().mandatory(), "getter")
    }));
  }
};
__name(_ZodLazy, "ZodLazy");
_ZodLazy.create = /* @__PURE__ */ __name((getter, params) => {
  return new _ZodLazy(__spreadValues({
    getter,
    typeName: "ZodLazy" /* ZodLazy */
  }, processCreateParams(params)));
}, "create");
var ZodLazy = _ZodLazy;

// src/z/types/literal/index.ts
var _ZodLiteral = class _ZodLiteral extends ZodType {
  _parse(input4) {
    if (input4.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  get value() {
    return this._def.value;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodLiteral)) return false;
    return isEqual_default(this._def.value, schema._def.value);
  }
};
__name(_ZodLiteral, "ZodLiteral");
_ZodLiteral.create = /* @__PURE__ */ __name((value, params) => {
  return new _ZodLiteral(__spreadValues({
    value,
    typeName: "ZodLiteral" /* ZodLiteral */
  }, processCreateParams(params)));
}, "create");
var ZodLiteral = _ZodLiteral;

// src/z/types/map/index.ts
var _ZodMap = class _ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(defs) {
    const keyType = this._def.keyType.dereference(defs);
    const valueType = this._def.valueType.dereference(defs);
    return new _ZodMap(__spreadProps(__spreadValues({}, this._def), {
      keyType,
      valueType
    }));
  }
  getReferences() {
    return unique([...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()]);
  }
  clone() {
    return new _ZodMap(__spreadProps(__spreadValues({}, this._def), {
      keyType: this._def.keyType.clone(),
      valueType: this._def.valueType.clone()
    }));
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodMap)) return false;
    if (!this._def.keyType.isEqual(schema._def.keyType)) return false;
    if (!this._def.valueType.isEqual(schema._def.valueType)) return false;
    return true;
  }
};
__name(_ZodMap, "ZodMap");
_ZodMap.create = /* @__PURE__ */ __name((keyType, valueType, params) => {
  return new _ZodMap(__spreadValues({
    valueType,
    keyType,
    typeName: "ZodMap" /* ZodMap */
  }, processCreateParams(params)));
}, "create");
var ZodMap = _ZodMap;

// src/z/types/nan/index.ts
var _ZodNaN = class _ZodNaN extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  isEqual(schema) {
    return schema instanceof _ZodNaN;
  }
};
__name(_ZodNaN, "ZodNaN");
_ZodNaN.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNaN(__spreadValues({
    typeName: "ZodNaN" /* ZodNaN */
  }, processCreateParams(params)));
}, "create");
var ZodNaN = _ZodNaN;

// src/z/types/nativeEnum/index.ts
var _ZodNativeEnum = class _ZodNativeEnum extends ZodType {
  _parse(input4) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input4);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input4.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get enum() {
    return this._def.values;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodNativeEnum)) return false;
    return isEqual_default(this._def.values, schema._def.values);
  }
};
__name(_ZodNativeEnum, "ZodNativeEnum");
_ZodNativeEnum.create = /* @__PURE__ */ __name((values, params) => {
  return new _ZodNativeEnum(__spreadValues({
    values,
    typeName: "ZodNativeEnum" /* ZodNativeEnum */
  }, processCreateParams(params)));
}, "create");
var ZodNativeEnum = _ZodNativeEnum;

// src/z/types/never/index.ts
var _ZodNever = class _ZodNever extends ZodType {
  _parse(input4) {
    const ctx = this._getOrReturnCtx(input4);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
  isEqual(schema) {
    return schema instanceof _ZodNever;
  }
};
__name(_ZodNever, "ZodNever");
_ZodNever.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNever(__spreadValues({
    typeName: "ZodNever" /* ZodNever */
  }, processCreateParams(params)));
}, "create");
var ZodNever = _ZodNever;

// src/z/types/null/index.ts
var _ZodNull = class _ZodNull extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodNull;
  }
};
__name(_ZodNull, "ZodNull");
_ZodNull.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNull(__spreadValues({
    typeName: "ZodNull" /* ZodNull */
  }, processCreateParams(params)));
}, "create");
var ZodNull = _ZodNull;

// src/z/types/nullable/index.ts
var _ZodNullable = class _ZodNullable extends ZodType {
  dereference(defs) {
    return new _ZodNullable(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  clone() {
    return new _ZodNullable(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.clone()
    }));
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodNullable)) return false;
    return this._def.innerType.isEqual(schema._def.innerType);
  }
  naked() {
    return this._def.innerType.naked();
  }
  mandatory() {
    return new _ZodNullable(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.mandatory()
    }));
  }
};
__name(_ZodNullable, "ZodNullable");
_ZodNullable.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodNullable(__spreadValues({
    innerType: type,
    typeName: "ZodNullable" /* ZodNullable */
  }, processCreateParams(params)));
}, "create");
var ZodNullable = _ZodNullable;

// src/z/types/number/index.ts
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var _ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Number(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input4.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodNumber)) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks);
  }
};
__name(_ZodNumber, "ZodNumber");
_ZodNumber.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNumber(__spreadValues({
    checks: [],
    typeName: "ZodNumber" /* ZodNumber */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodNumber = _ZodNumber;

// src/z/types/object/index.ts
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2(__spreadProps(__spreadValues({}, schema._def), {
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    }));
  } else if (schema instanceof ZodArray) {
    return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
      type: deepPartialify(schema.element)
    }));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var _ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    this.nonstrict = this.passthrough;
    // extend<
    //   Augmentation extends ZodRawShape,
    //   NewOutput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   }>,
    //   NewInput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }>
    // >(
    //   augmentation: Augmentation
    // ): ZodObject<
    //   extendShape<T, Augmentation>,
    //   UnknownKeys,
    //   Catchall,
    //   NewOutput,
    //   NewInput
    // > {
    //   return new ZodObject({
    //     ...this._def,
    //     shape: () => ({
    //       ...this._def.shape(),
    //       ...augmentation,
    //     }),
    //   })
    // }
    /**
     * @deprecated Use `.extend` instead
     *  */
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  dereference(defs) {
    const currentShape = this._def.shape();
    const shape = {};
    for (const key in currentShape) {
      shape[key] = currentShape[key].dereference(defs);
    }
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    }));
  }
  getReferences() {
    const shape = this._def.shape();
    const refs = [];
    for (const key in shape) {
      refs.push(...shape[key].getReferences());
    }
    return unique(refs);
  }
  clone() {
    const newShape = {};
    const currentShape = this._def.shape();
    for (const [key, value] of Object.entries(currentShape)) {
      newShape[key] = value.clone();
    }
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    }));
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input4);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (this._def.unknownKeys !== "strip") {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    const unknownKeys = this._def.unknownKeys;
    if (unknownKeys === "passthrough") {
      for (const key of extraKeys) {
        pairs.push({
          key: { status: "valid", value: key },
          value: { status: "valid", value: ctx.data[key] }
        });
      }
    } else if (unknownKeys === "strict") {
      if (extraKeys.length > 0) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.unrecognized_keys,
          keys: extraKeys
        });
        status.dirty();
      }
    } else if (unknownKeys === "strip") {
    } else {
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: unknownKeys._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strict"
    }), message2 !== void 0 ? {
      errorMap: /* @__PURE__ */ __name((issue, ctx) => {
        var _a, _b, _c, _d;
        const defaultError = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) != null ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message2).message) != null ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }, "errorMap")
    } : {}));
  }
  strip() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  /**
   * @returns The ZodType that is used to validate additional properties or undefined if extra keys are stripped.
   */
  additionalProperties() {
    if (this._def.unknownKeys instanceof ZodType) {
      return this._def.unknownKeys;
    }
    if (this._def.unknownKeys === "passthrough") {
      return ZodAny.create();
    }
    if (this._def.unknownKeys === "strict") {
      return ZodNever.create();
    }
    return void 0;
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     })
  //   };
  extend(augmentation) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => __spreadValues(__spreadValues({}, this._def.shape()), augmentation), "shape")
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      shape: /* @__PURE__ */ __name(() => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()), "shape"),
      typeName: "ZodObject" /* ZodObject */
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   });
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   });
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: index
    }));
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    }));
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema == null ? void 0 : fieldSchema.optional();
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    }));
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    }));
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodObject)) return false;
    if (!this._unknownKeysEqual(schema)) return false;
    const thisShape = this._def.shape();
    const thatShape = schema._def.shape();
    const compare = /* @__PURE__ */ __name((a, b) => a[0] === b[0] && a[1].isEqual(b[1]), "compare");
    const thisProps = new CustomSet(Object.entries(thisShape), { compare });
    const thatProps = new CustomSet(Object.entries(thatShape), { compare });
    return thisProps.isEqual(thatProps);
  }
  _unknownKeysEqual(that) {
    const thisAdditionalProperties = this.additionalProperties();
    const thatAdditionalProperties = that.additionalProperties();
    if (thisAdditionalProperties === void 0 || thatAdditionalProperties === void 0) {
      return thisAdditionalProperties === thatAdditionalProperties;
    }
    return thisAdditionalProperties.isEqual(thatAdditionalProperties);
  }
};
__name(_ZodObject, "ZodObject");
_ZodObject.create = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "create");
_ZodObject.strictCreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "strictCreate");
_ZodObject.lazycreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape,
    unknownKeys: "strip",
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "lazycreate");
var ZodObject2 = _ZodObject;

// src/z/types/optional/index.ts
var _ZodOptional = class _ZodOptional extends ZodType {
  dereference(defs) {
    return new _ZodOptional(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  clone() {
    return new _ZodOptional(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.clone()
    }));
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodOptional)) return false;
    return this._def.innerType.isEqual(schema._def.innerType);
  }
  naked() {
    return this._def.innerType.naked();
  }
  mandatory() {
    return this._def.innerType.mandatory();
  }
};
__name(_ZodOptional, "ZodOptional");
_ZodOptional.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodOptional(__spreadValues({
    innerType: type,
    typeName: "ZodOptional" /* ZodOptional */
  }, processCreateParams(params)));
}, "create");
var ZodOptional = _ZodOptional;

// src/z/types/pipeline/index.ts
var _ZodPipeline = class _ZodPipeline extends ZodType {
  dereference(defs) {
    return new _ZodPipeline(__spreadProps(__spreadValues({}, this._def), {
      in: this._def.in.dereference(defs),
      out: this._def.out.dereference(defs)
    }));
  }
  getReferences() {
    return unique([...this._def.in.getReferences(), ...this._def.out.getReferences()]);
  }
  clone() {
    return new _ZodPipeline(__spreadProps(__spreadValues({}, this._def), {
      in: this._def.in.clone(),
      out: this._def.out.clone()
    }));
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted") return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted") return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: "ZodPipeline" /* ZodPipeline */
    });
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodPipeline)) return false;
    if (!this._def.in.isEqual(schema._def.in)) return false;
    if (!this._def.out.isEqual(schema._def.out)) return false;
    return true;
  }
};
__name(_ZodPipeline, "ZodPipeline");
var ZodPipeline = _ZodPipeline;

// src/z/types/promise/index.ts
var _ZodPromise = class _ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  dereference(defs) {
    return new _ZodPromise(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  clone() {
    return new _ZodPromise(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.clone()
    }));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(
      promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      })
    );
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodPromise)) return false;
    return this._def.type.isEqual(schema._def.type);
  }
  naked() {
    return this._def.type.naked();
  }
};
__name(_ZodPromise, "ZodPromise");
_ZodPromise.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodPromise(__spreadValues({
    type: schema,
    typeName: "ZodPromise" /* ZodPromise */
  }, processCreateParams(params)));
}, "create");
var ZodPromise = _ZodPromise;

// src/z/types/readonly/index.ts
var _ZodReadonly = class _ZodReadonly extends ZodType {
  dereference(defs) {
    return new _ZodReadonly(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  clone() {
    return new _ZodReadonly(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.clone()
    }));
  }
  _parse(input4) {
    const result = this._def.innerType._parse(input4);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
  unwrap() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodReadonly)) return false;
    return this._def.innerType.isEqual(schema._def.innerType);
  }
  naked() {
    return this._def.innerType.naked();
  }
  mandatory() {
    return new _ZodReadonly(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.mandatory()
    }));
  }
};
__name(_ZodReadonly, "ZodReadonly");
_ZodReadonly.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodReadonly(__spreadValues({
    innerType: type,
    typeName: "ZodReadonly" /* ZodReadonly */
  }, processCreateParams(params)));
}, "create");
var ZodReadonly = _ZodReadonly;

// src/z/types/record/index.ts
var _ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(defs) {
    const keyType = this._def.keyType.dereference(defs);
    const valueType = this._def.valueType.dereference(defs);
    return new _ZodRecord(__spreadProps(__spreadValues({}, this._def), {
      keyType,
      valueType
    }));
  }
  getReferences() {
    return unique([...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()]);
  }
  clone() {
    return new _ZodRecord(__spreadProps(__spreadValues({}, this._def), {
      keyType: this._def.keyType.clone(),
      valueType: this._def.valueType.clone()
    }));
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord(__spreadValues({
        keyType: first,
        valueType: second,
        typeName: "ZodRecord" /* ZodRecord */
      }, processCreateParams(third)));
    }
    return new _ZodRecord(__spreadValues({
      keyType: ZodString.create(),
      valueType: first,
      typeName: "ZodRecord" /* ZodRecord */
    }, processCreateParams(second)));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodRecord)) return false;
    if (!this._def.keyType.isEqual(schema._def.keyType)) return false;
    if (!this._def.valueType.isEqual(schema._def.valueType)) return false;
    return true;
  }
};
__name(_ZodRecord, "ZodRecord");
var ZodRecord = _ZodRecord;

// src/z/types/ref/index.ts
var _ZodRef = class _ZodRef extends ZodType {
  dereference(defs) {
    const def = defs[this._def.uri];
    if (!def) {
      return this;
    }
    return def;
  }
  getReferences() {
    return [this._def.uri];
  }
  _parse(input4) {
    const ctx = this._getOrReturnCtx(input4);
    addIssueToContext(ctx, {
      code: ZodIssueCode.unresolved_reference
    });
    return INVALID;
  }
  isOptional() {
    return false;
  }
  isNullable() {
    return false;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodRef)) return false;
    return this._def.uri === schema._def.uri;
  }
};
__name(_ZodRef, "ZodRef");
_ZodRef.create = /* @__PURE__ */ __name((uri) => {
  return new _ZodRef({
    typeName: "ZodRef" /* ZodRef */,
    uri
  });
}, "create");
var ZodRef = _ZodRef;

// src/z/types/set/index.ts
var _ZodSet = class _ZodSet extends ZodType {
  dereference(defs) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      valueType: this._def.valueType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.valueType.getReferences();
  }
  clone() {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      valueType: this._def.valueType.clone()
    }));
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted") return INVALID;
        if (element.status === "dirty") status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map(
      (item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))
    );
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    }));
  }
  max(maxSize, message2) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    }));
  }
  size(size, message2) {
    return this.min(size, message2).max(size, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
  isEqual(schema) {
    var _a, _b, _c, _d;
    if (!(schema instanceof _ZodSet)) return false;
    const thisMin = (_a = this._def.minSize) == null ? void 0 : _a.value;
    const thatMin = (_b = schema._def.minSize) == null ? void 0 : _b.value;
    if (thisMin !== thatMin) return false;
    const thisMax = (_c = this._def.maxSize) == null ? void 0 : _c.value;
    const thatMax = (_d = schema._def.maxSize) == null ? void 0 : _d.value;
    if (thisMax !== thatMax) return false;
    return this._def.valueType.isEqual(schema._def.valueType);
  }
};
__name(_ZodSet, "ZodSet");
_ZodSet.create = /* @__PURE__ */ __name((valueType, params) => {
  return new _ZodSet(__spreadValues({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: "ZodSet" /* ZodSet */
  }, processCreateParams(params)));
}, "create");
var ZodSet = _ZodSet;

// src/z/types/string/index.ts
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var isEmojiRegex = /* @__PURE__ */ __name((value) => value === _emojiRegex, "isEmojiRegex");
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
var _ZodString = class _ZodString extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = String(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.length < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.length > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input4.data.length > check.value;
        const tooSmall = input4.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input4.data);
        } catch (e) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input4.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input4.data = input4.data.trim();
      } else if (check.kind === "includes") {
        if (!input4.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input4.data = input4.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input4.data = input4.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input4.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input4.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = generateDatetimeRegex(check);
        if (!regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input4.data, check.version)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), __spreadValues({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message2)));
  }
  _addCheck(check) {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message2) {
    return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message2)));
  }
  url(message2) {
    return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message2)));
  }
  emoji(message2) {
    return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message2)));
  }
  uuid(message2) {
    return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message2)));
  }
  cuid(message2) {
    return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message2)));
  }
  cuid2(message2) {
    return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message2)));
  }
  ulid(message2) {
    return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message2)));
  }
  ip(options) {
    return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (_a = options == null ? void 0 : options.offset) != null ? _a : false
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  regex(regex, message2) {
    return this._addCheck(__spreadValues({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message2)));
  }
  includes(value, options) {
    return this._addCheck(__spreadValues({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  startsWith(value, message2) {
    return this._addCheck(__spreadValues({
      kind: "startsWith",
      value
    }, errorUtil.errToObj(message2)));
  }
  endsWith(value, message2) {
    return this._addCheck(__spreadValues({
      kind: "endsWith",
      value
    }, errorUtil.errToObj(message2)));
  }
  min(minLength, message2) {
    return this._addCheck(__spreadValues({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message2)));
  }
  max(maxLength, message2) {
    return this._addCheck(__spreadValues({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message2)));
  }
  length(len, message2) {
    return this._addCheck(__spreadValues({
      kind: "length",
      value: len
    }, errorUtil.errToObj(message2)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  secret() {
    this._def[zuiKey] = __spreadProps(__spreadValues({}, this._def[zuiKey]), { secret: true });
    return this;
  }
  toLowerCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodString)) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks);
  }
};
__name(_ZodString, "ZodString");
_ZodString.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodString(__spreadValues({
    checks: [],
    typeName: "ZodString" /* ZodString */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(__spreadProps(__spreadValues({}, params), { supportsExtensions: ["secret"] }))));
}, "create");
var ZodString = _ZodString;

// src/z/types/symbol/index.ts
var _ZodSymbol = class _ZodSymbol extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodSymbol;
  }
};
__name(_ZodSymbol, "ZodSymbol");
_ZodSymbol.create = /* @__PURE__ */ __name((params) => {
  return new _ZodSymbol(__spreadValues({
    typeName: "ZodSymbol" /* ZodSymbol */
  }, processCreateParams(params)));
}, "create");
var ZodSymbol = _ZodSymbol;

// src/z/types/transformer/index.ts
var _ZodEffects = class _ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  /**
   * @deprecated use naked() instead
   */
  sourceType() {
    return this._def.schema._def.typeName === "ZodEffects" /* ZodEffects */ ? this._def.schema.sourceType() : this._def.schema;
  }
  dereference(defs) {
    return new _ZodEffects(__spreadProps(__spreadValues({}, this._def), {
      schema: this._def.schema.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.schema.getReferences();
  }
  clone() {
    return new _ZodEffects(__spreadProps(__spreadValues({}, this._def), {
      schema: this._def.schema.clone()
    }));
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted") return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted") return INVALID;
          if (result.status === "dirty") return DIRTY(result.value);
          if (status.value === "dirty") return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted") return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted") return INVALID;
        if (result.status === "dirty") return DIRTY(result.value);
        if (status.value === "dirty") return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted") return INVALID;
        if (inner.status === "dirty") status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted") return INVALID;
          if (inner.status === "dirty") status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base)) return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
          );
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base)) return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodEffects)) return false;
    if (!this._def.schema.isEqual(schema._def.schema)) return false;
    if (this._def.effect.type === "refinement") {
      if (schema._def.effect.type !== "refinement") return false;
      return util.compareFunctions(this._def.effect.refinement, schema._def.effect.refinement);
    }
    if (this._def.effect.type === "transform") {
      if (schema._def.effect.type !== "transform") return false;
      return util.compareFunctions(this._def.effect.transform, schema._def.effect.transform);
    }
    if (this._def.effect.type === "preprocess") {
      if (schema._def.effect.type !== "preprocess") return false;
      return util.compareFunctions(this._def.effect.transform, schema._def.effect.transform);
    }
    return false;
  }
  naked() {
    return this._def.schema.naked();
  }
  mandatory() {
    return new _ZodEffects(__spreadProps(__spreadValues({}, this._def), {
      schema: this._def.schema.mandatory()
    }));
  }
};
__name(_ZodEffects, "ZodEffects");
_ZodEffects.create = /* @__PURE__ */ __name((schema, effect, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    typeName: "ZodEffects" /* ZodEffects */,
    effect
  }, processCreateParams(params)));
}, "create");
_ZodEffects.createWithPreprocess = /* @__PURE__ */ __name((preprocess, schema, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: "ZodEffects" /* ZodEffects */
  }, processCreateParams(params)));
}, "createWithPreprocess");
var ZodEffects = _ZodEffects;

// src/z/types/tuple/index.ts
var _ZodTuple = class _ZodTuple extends ZodType {
  dereference(defs) {
    const items = this._def.items.map((item) => item.dereference(defs));
    const rest = this._def.rest ? this._def.rest.dereference(defs) : null;
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      items,
      rest
    }));
  }
  getReferences() {
    return unique([
      ...this._def.items.flatMap((item) => item.getReferences()),
      ...this._def.rest ? this._def.rest.getReferences() : []
    ]);
  }
  clone() {
    const items = this._def.items.map((item) => item.clone());
    const rest = this._def.rest ? this._def.rest.clone() : null;
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      items,
      rest
    }));
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema) return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      rest
    }));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodTuple)) return false;
    if (!this._restEquals(schema)) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisItems = new CustomSet(this._def.items, { compare });
    const schemaItems = new CustomSet(schema._def.items, { compare });
    return thisItems.isEqual(schemaItems);
  }
  _restEquals(schema) {
    if (this._def.rest === null) {
      return schema._def.rest === null;
    }
    return schema._def.rest !== null && this._def.rest.isEqual(schema._def.rest);
  }
};
__name(_ZodTuple, "ZodTuple");
_ZodTuple.create = /* @__PURE__ */ __name((schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new _ZodTuple(__spreadValues({
    items: schemas,
    typeName: "ZodTuple" /* ZodTuple */,
    rest: null
  }, processCreateParams(params)));
}, "create");
var ZodTuple = _ZodTuple;

// src/z/types/undefined/index.ts
var _ZodUndefined = class _ZodUndefined extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodUndefined;
  }
  mandatory() {
    return ZodNever.create(__spreadValues({}, this._def));
  }
};
__name(_ZodUndefined, "ZodUndefined");
_ZodUndefined.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUndefined(__spreadValues({
    typeName: "ZodUndefined" /* ZodUndefined */
  }, processCreateParams(params)));
}, "create");
var ZodUndefined = _ZodUndefined;

// src/z/types/union/index.ts
var _ZodUnion = class _ZodUnion extends ZodType {
  dereference(defs) {
    const options = this._def.options.map((option) => option.dereference(defs));
    return new _ZodUnion(__spreadProps(__spreadValues({}, this._def), {
      options
    }));
  }
  getReferences() {
    return unique(
      this._def.options.reduce((acc, option) => {
        return [...acc, ...option.getReferences()];
      }, [])
    );
  }
  clone() {
    const options = this._def.options.map((option) => option.clone());
    return new _ZodUnion(__spreadProps(__spreadValues({}, this._def), {
      options
    }));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            }),
            parent: null
          });
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })
      ).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodUnion)) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisOptions = new CustomSet([...this._def.options], { compare });
    const thatOptions = new CustomSet([...schema._def.options], { compare });
    return thisOptions.isEqual(thatOptions);
  }
  mandatory() {
    const options = this._def.options.filter((o) => !(o instanceof ZodUndefined)).map((option) => option.mandatory());
    const [first, second, ...others] = options;
    if (!first) {
      return ZodNever.create(__spreadValues({}, this._def));
    }
    if (!second) {
      return first;
    }
    return new _ZodUnion(__spreadProps(__spreadValues({}, this._def), {
      options: [first, second, ...others]
    }));
  }
};
__name(_ZodUnion, "ZodUnion");
_ZodUnion.create = /* @__PURE__ */ __name((types, params) => {
  return new _ZodUnion(__spreadValues({
    options: types,
    typeName: "ZodUnion" /* ZodUnion */
  }, processCreateParams(params)));
}, "create");
var ZodUnion = _ZodUnion;

// src/z/types/unknown/index.ts
var _ZodUnknown = class _ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    // required
    this._unknown = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodUnknown;
  }
};
__name(_ZodUnknown, "ZodUnknown");
_ZodUnknown.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUnknown(__spreadValues({
    typeName: "ZodUnknown" /* ZodUnknown */
  }, processCreateParams(params)));
}, "create");
var ZodUnknown = _ZodUnknown;

// src/z/types/void/index.ts
var _ZodVoid = class _ZodVoid extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodVoid;
  }
};
__name(_ZodVoid, "ZodVoid");
_ZodVoid.create = /* @__PURE__ */ __name((params) => {
  return new _ZodVoid(__spreadValues({
    typeName: "ZodVoid" /* ZodVoid */
  }, processCreateParams(params)));
}, "create");
var ZodVoid = _ZodVoid;

// src/z/extensions.ts
var AI_MODELS = [
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-16k",
  "gpt-4",
  "gpt-4-1106-preview",
  "gpt-4-vision-preview",
  "gpt-4-0125-preview",
  "gpt-4-turbo-preview",
  "gpt-4-turbo",
  "gpt-4o",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo-1106"
];
var variableType = ZodEnum.create([
  "any",
  "string",
  "number",
  "boolean",
  "object",
  "pattern",
  "date",
  "array",
  "target",
  "time",
  "enum"
]);
var variable = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "variable", params: __spreadValues({ type: (opts == null ? void 0 : opts.type) || "any" }, opts == null ? void 0 : opts.params) }), "variable");
var conversation = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "conversation", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "conversation");
var user = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "user", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "user");
var message = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "message", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "message");
var agent = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "agent", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "agent");
var event = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "event", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "event");
var table = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "table", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "table");
var tablerow = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "tablerow", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "tablerow");
var intent = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "intent", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "intent");
var aimodel = /* @__PURE__ */ __name(() => ZodEnum.create(AI_MODELS).displayAs({ id: "dropdown", params: {} }), "aimodel");
var datasource = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "datasource", params: __spreadValues({}, opts) }), "datasource");
var knowledgebase = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "knowledgebase", params: __spreadValues({}, opts) }), "knowledgebase");

// src/z/z.ts
var late = {
  object: ZodObject2.lazycreate
};
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject2.create;
var strictObjectType = ZodObject2.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var refType = ZodRef.create;
var readonlyType = ZodReadonly.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var defaultType = ZodDefault.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  })), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "date")
};
var NEVER = INVALID;

// src/z/index.ts
var z_default = z_exports;

// src/transforms/zui-from-json-schema-legacy/parsers/parseAnyOf.ts
var parseAnyOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.anyOf.length ? schema.anyOf.length === 1 ? parseSchema(schema.anyOf[0], __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "anyOf", 0]
  })) : `z.union([${schema.anyOf.map((schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "anyOf", i] }))).join(", ")}])` : `z.any()`;
}, "parseAnyOf");

// src/transforms/zui-from-json-schema-legacy/parsers/parseBoolean.ts
var parseBoolean = /* @__PURE__ */ __name((_schema) => {
  var _a;
  if ((_a = _schema[zuiKey]) == null ? void 0 : _a.coerce) {
    return "z.coerce.boolean()";
  }
  return "z.boolean()";
}, "parseBoolean");

// src/transforms/zui-from-json-schema-legacy/parsers/parseDefault.ts
var parseDefault = /* @__PURE__ */ __name((_schema) => {
  return "z.any()";
}, "parseDefault");

// src/transforms/zui-from-json-schema-legacy/parsers/parseMultipleType.ts
var parseMultipleType = /* @__PURE__ */ __name((schema, refs) => {
  return `z.union([${schema.type.map((type) => parseSchema(__spreadProps(__spreadValues({}, schema), { type }), refs)).join(", ")}])`;
}, "parseMultipleType");

// src/transforms/zui-from-json-schema-legacy/parsers/parseNot.ts
var parseNot = /* @__PURE__ */ __name((schema, refs) => {
  return `z.any().refine((value) => !${parseSchema(schema.not, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "not"]
  }))}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`;
}, "parseNot");

// src/transforms/zui-from-json-schema-legacy/parsers/parseNull.ts
var parseNull = /* @__PURE__ */ __name((_schema) => {
  return "z.null()";
}, "parseNull");

// src/transforms/zui-from-json-schema-legacy/utils.ts
var half = /* @__PURE__ */ __name((arr) => {
  return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];
}, "half");
var omit = /* @__PURE__ */ __name((obj, ...keys2) => Object.keys(obj).reduce((acc, key) => {
  if (!keys2.includes(key)) {
    acc[key] = obj[key];
  }
  return acc;
}, {}), "omit");
function withMessage(schema, key, get2) {
  var _a;
  const value = schema[key];
  let r = "";
  if (value !== void 0) {
    const got = get2({ value, json: JSON.stringify(value) });
    if (got) {
      const opener = got[0];
      const prefix = got.length === 3 ? got[1] : "";
      const closer = got.length === 3 ? got[2] : got[1];
      r += opener;
      if (((_a = schema.errorMessage) == null ? void 0 : _a[key]) !== void 0) {
        r += prefix + JSON.stringify(schema.errorMessage[key]);
      }
      r;
      r += closer;
    }
  }
  return r;
}
__name(withMessage, "withMessage");

// src/transforms/zui-from-json-schema-legacy/parsers/parseAllOf.ts
var originalIndex = Symbol("Original index");
var ensureOriginalIndex = /* @__PURE__ */ __name((arr) => {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (typeof item === "boolean") {
      newArr.push(item ? { [originalIndex]: i } : { [originalIndex]: i, not: {} });
    } else if (originalIndex in item) {
      return arr;
    } else {
      newArr.push(__spreadProps(__spreadValues({}, item), { [originalIndex]: i }));
    }
  }
  return newArr;
}, "ensureOriginalIndex");
function parseAllOf(schema, refs) {
  if (schema.allOf.length === 0) {
    return "z.never()";
  } else if (schema.allOf.length === 1) {
    const item = schema.allOf[0];
    return parseSchema(item, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "allOf", item[originalIndex]]
    }));
  } else {
    const [left, right] = half(ensureOriginalIndex(schema.allOf));
    return `z.intersection(${parseAllOf({ allOf: left }, refs)}, ${parseAllOf(
      {
        allOf: right
      },
      refs
    )})`;
  }
}
__name(parseAllOf, "parseAllOf");

// src/transforms/zui-from-json-schema-legacy/parsers/parseArray.ts
var parseArray = /* @__PURE__ */ __name((schema, refs) => {
  if (Array.isArray(schema.items)) {
    return `z.tuple([${schema.items.map((v, i) => parseSchema(v, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "items", i] })))}])`;
  }
  let r = !schema.items ? "z.array(z.any())" : `z.array(${parseSchema(schema.items, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "items"]
  }))})`;
  r += withMessage(schema, "minItems", ({ json }) => [`.min(${json}`, ", ", ")"]);
  r += withMessage(schema, "maxItems", ({ json }) => [`.max(${json}`, ", ", ")"]);
  return r;
}, "parseArray");

// src/transforms/zui-from-json-schema-legacy/parsers/parseConst.ts
var parseConst = /* @__PURE__ */ __name((schema) => {
  return `z.literal(${JSON.stringify(schema.const)})`;
}, "parseConst");

// src/transforms/zui-from-json-schema-legacy/parsers/parseEnum.ts
var parseEnum = /* @__PURE__ */ __name((schema) => {
  if (schema.enum.length === 0) {
    return "z.never()";
  } else if (schema.enum.length === 1) {
    return `z.literal(${JSON.stringify(schema.enum[0])})`;
  } else if (schema.enum.every((x) => typeof x === "string")) {
    return `z.enum([${schema.enum.map((x) => JSON.stringify(x))}])`;
  } else {
    return `z.union([${schema.enum.map((x) => `z.literal(${JSON.stringify(x)})`).join(", ")}])`;
  }
}, "parseEnum");

// src/transforms/zui-from-json-schema-legacy/parsers/parseIfThenElse.ts
var parseIfThenElse = /* @__PURE__ */ __name((schema, refs) => {
  const $if = parseSchema(schema.if, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "if"] }));
  const $then = parseSchema(schema.then, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "then"]
  }));
  const $else = parseSchema(schema.else, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "else"]
  }));
  return `z.union([${$then}, ${$else}]).superRefine((value,ctx) => {
  const result = ${$if}.safeParse(value).success
    ? ${$then}.safeParse(value)
    : ${$else}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
}, "parseIfThenElse");

// src/transforms/zui-from-json-schema-legacy/parsers/parseNumber.ts
var parseNumber = /* @__PURE__ */ __name((schema) => {
  var _a;
  let r = "z.number()";
  if ((_a = schema[zuiKey]) == null ? void 0 : _a.coerce) {
    r = "z.coerce.number()";
  }
  if (schema.type === "integer") {
    r += withMessage(schema, "type", () => [".int(", ")"]);
  } else {
    r += withMessage(schema, "format", ({ value }) => {
      if (value === "int64") {
        return [".int(", ")"];
      }
    });
  }
  r += withMessage(schema, "multipleOf", ({ value, json }) => {
    if (value === 1) {
      if (r.startsWith("z.number().int(")) {
        return;
      }
      return [".int(", ")"];
    }
    return [`.multipleOf(${json}`, ", ", ")"];
  });
  if (typeof schema.minimum === "number") {
    if (schema.exclusiveMinimum === true) {
      r += withMessage(schema, "minimum", ({ json }) => [`.gt(${json}`, ", ", ")"]);
    } else {
      r += withMessage(schema, "minimum", ({ json }) => [`.gte(${json}`, ", ", ")"]);
    }
  } else if (typeof schema.exclusiveMinimum === "number") {
    r += withMessage(schema, "exclusiveMinimum", ({ json }) => [`.gt(${json}`, ", ", ")"]);
  }
  if (typeof schema.maximum === "number") {
    if (schema.exclusiveMaximum === true) {
      r += withMessage(schema, "maximum", ({ json }) => [`.lt(${json}`, ", ", ")"]);
    } else {
      r += withMessage(schema, "maximum", ({ json }) => [`.lte(${json}`, ", ", ")"]);
    }
  } else if (typeof schema.exclusiveMaximum === "number") {
    r += withMessage(schema, "exclusiveMaximum", ({ json }) => [`.lt(${json}`, ", ", ")"]);
  }
  return r;
}, "parseNumber");

// src/transforms/zui-from-json-schema-legacy/parsers/parseOneOf.ts
var parseOneOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.oneOf.length ? schema.oneOf.length === 1 ? parseSchema(schema.oneOf[0], __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "oneOf", 0]
  })) : `z.any().superRefine((x, ctx) => {
    const schemas = [${schema.oneOf.map(
    (schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "oneOf", i]
    }))
  ).join(", ")}];
    const errors = schemas.reduce(
      (errors: z.ZodError[], schema) =>
        ((result) => ("error" in result ? [...errors, result.error] : errors))(
          schema.safeParse(x)
        ),
      []
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })` : "z.any()";
}, "parseOneOf");

// src/transforms/zui-from-json-schema-legacy/parsers/parseObject.ts
function parseObject(objectSchema, refs) {
  let properties = void 0;
  if (objectSchema.properties) {
    if (!Object.keys(objectSchema.properties).length) {
      properties = "z.object({})";
    } else {
      properties = "z.object({ ";
      properties += Object.keys(objectSchema.properties).map((key) => {
        const propSchema = objectSchema.properties[key];
        const result = `${JSON.stringify(key)}: ${parseSchema(propSchema, __spreadProps(__spreadValues({}, refs), {
          path: [...refs.path, "properties", key]
        }))}`;
        const hasDefault = typeof propSchema === "object" && propSchema.default !== void 0 || typeof objectSchema.default === "object" && objectSchema.default !== null && key in objectSchema.default;
        const required = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : typeof propSchema === "object" && propSchema.required === true;
        const optional = !hasDefault && !required;
        return optional ? `${result}.optional()` : result;
      }).join(", ");
      properties += " })";
    }
  }
  const additionalProperties = objectSchema.additionalProperties !== void 0 ? parseSchema(objectSchema.additionalProperties, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "additionalProperties"]
  })) : void 0;
  let patternProperties = void 0;
  if (objectSchema.patternProperties) {
    const parsedPatternProperties = Object.fromEntries(
      Object.entries(objectSchema.patternProperties).map(([key, value]) => {
        return [
          key,
          parseSchema(value, __spreadProps(__spreadValues({}, refs), {
            path: [...refs.path, "patternProperties", key]
          }))
        ];
      }, {})
    );
    patternProperties = "";
    if (properties) {
      if (additionalProperties) {
        patternProperties += `.catchall(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;
      }
    } else {
      if (additionalProperties) {
        patternProperties += `z.record(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;
      }
    }
    patternProperties += ".superRefine((value, ctx) => {\n";
    patternProperties += "for (const key in value) {\n";
    if (additionalProperties) {
      if (objectSchema.properties) {
        patternProperties += `let evaluated = [${Object.keys(objectSchema.properties).map((key) => JSON.stringify(key)).join(", ")}].includes(key)
`;
      } else {
        patternProperties += `let evaluated = false
`;
      }
    }
    for (const key in objectSchema.patternProperties) {
      patternProperties += "if (key.match(new RegExp(" + JSON.stringify(key) + "))) {\n";
      if (additionalProperties) {
        patternProperties += "evaluated = true\n";
      }
      patternProperties += "const result = " + parsedPatternProperties[key] + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    if (additionalProperties) {
      patternProperties += "if (!evaluated) {\n";
      patternProperties += "const result = " + additionalProperties + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    patternProperties += "}\n";
    patternProperties += "})";
  }
  let output4 = properties ? patternProperties ? properties + patternProperties : additionalProperties ? additionalProperties === "z.never()" ? properties + ".strict()" : properties + `.catchall(${additionalProperties})` : properties : patternProperties ? patternProperties : additionalProperties ? `z.record(${additionalProperties})` : "z.record(z.any())";
  if (its.an.anyOf(objectSchema)) {
    output4 += `.and(${parseAnyOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        anyOf: objectSchema.anyOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  if (its.a.oneOf(objectSchema)) {
    output4 += `.and(${parseOneOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        oneOf: objectSchema.oneOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  if (its.an.allOf(objectSchema)) {
    output4 += `.and(${parseAllOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        allOf: objectSchema.allOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  return output4;
}
__name(parseObject, "parseObject");

// src/transforms/zui-from-json-schema-legacy/parsers/parseString.ts
var parseString = /* @__PURE__ */ __name((schema) => {
  var _a;
  let r = "z.string()";
  if ((_a = schema[zuiKey]) == null ? void 0 : _a.coerce) {
    if (schema.format === "date-time") {
      return "z.coerce.date()";
    }
    r = "z.coerce.string()";
  }
  r += withMessage(schema, "format", ({ value }) => {
    switch (value) {
      case "email":
        return [".email(", ")"];
      case "ip":
        return [".ip(", ")"];
      case "ipv4":
        return ['.ip({ version: "v4"', ", message: ", " })"];
      case "ipv6":
        return ['.ip({ version: "v6"', ", message: ", " })"];
      case "uri":
        return [".url(", ")"];
      case "uuid":
        return [".uuid(", ")"];
      case "date-time":
        return [".datetime(", ")"];
    }
  });
  r += withMessage(schema, "pattern", ({ json }) => [`.regex(new RegExp(${json})`, ", ", ")"]);
  r += withMessage(schema, "minLength", ({ json }) => [`.min(${json}`, ", ", ")"]);
  r += withMessage(schema, "maxLength", ({ json }) => [`.max(${json}`, ", ", ")"]);
  return r;
}, "parseString");

// src/transforms/zui-from-json-schema-legacy/parsers/parseNullable.ts
var parseNullable = /* @__PURE__ */ __name((schema, refs) => {
  return `${parseSchema(omit(schema, "nullable"), refs, true)}.nullable()`;
}, "parseNullable");

// src/transforms/zui-from-json-schema-legacy/parsers/parseRef.ts
var parseRef = /* @__PURE__ */ __name((schema) => {
  return `z.ref('${schema.$ref}')`;
}, "parseRef");

// src/transforms/zui-from-json-schema-legacy/parsers/parseDiscriminator.ts
var parseDiscriminator = /* @__PURE__ */ __name((schema, refs) => {
  var _a, _b;
  if (schema.oneOf.length <= 1 || !((_a = schema.discriminator) == null ? void 0 : _a.propertyName)) {
    return parseOneOf(schema, refs);
  }
  const schemas = schema.oneOf.map(
    (schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "oneOf", i]
    }))
  );
  return `z.discriminatedUnion("${(_b = schema.discriminator) == null ? void 0 : _b.propertyName}", [${schemas.join(", ")}])`;
}, "parseDiscriminator");

// src/transforms/zui-from-json-schema-legacy/parsers/parseSchema.ts
var parseSchema = /* @__PURE__ */ __name((schema, refs = { seen: /* @__PURE__ */ new Map(), path: [] }, blockMeta) => {
  if (typeof schema !== "object") return schema ? "z.any()" : "z.never()";
  if (refs.parserOverride) {
    const custom2 = refs.parserOverride(schema, refs);
    if (typeof custom2 === "string") {
      return custom2;
    }
  }
  let seen = refs.seen.get(schema);
  if (seen) {
    if (seen.r !== void 0) {
      return seen.r;
    }
    if (refs.depth === void 0 || seen.n >= refs.depth) {
      return "z.any()";
    }
    seen.n += 1;
  } else {
    seen = { r: void 0, n: 0 };
    refs.seen.set(schema, seen);
  }
  let parsed = selectParser(schema, refs);
  if (!blockMeta) {
    parsed = addMeta(schema, parsed);
    if (!refs.withoutDefaults) {
      parsed = addDefaults(schema, parsed);
    }
  }
  seen.r = parsed;
  return parsed;
}, "parseSchema");
var addMeta = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.description) {
    parsed += `.describe(${JSON.stringify(schema.description)})`;
  }
  return parsed;
}, "addMeta");
var addDefaults = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.default !== void 0) {
    parsed += `.default(${JSON.stringify(schema.default)})`;
  }
  return parsed;
}, "addDefaults");
var selectParser = /* @__PURE__ */ __name((schema, refs) => {
  if (its.a.nullable(schema)) {
    return parseNullable(schema, refs);
  } else if (its.an.object(schema)) {
    return parseObject(schema, refs);
  } else if (its.an.array(schema)) {
    return parseArray(schema, refs);
  } else if (its.an.anyOf(schema)) {
    return parseAnyOf(schema, refs);
  } else if (its.an.allOf(schema)) {
    return parseAllOf(schema, refs);
  } else if (its.a.discriminator(schema)) {
    return parseDiscriminator(schema, refs);
  } else if (its.a.oneOf(schema)) {
    return parseOneOf(schema, refs);
  } else if (its.a.not(schema)) {
    return parseNot(schema, refs);
  } else if (its.an.enum(schema)) {
    return parseEnum(schema);
  } else if (its.a.const(schema)) {
    return parseConst(schema);
  } else if (its.a.multipleType(schema)) {
    return parseMultipleType(schema, refs);
  } else if (its.a.primitive(schema, "string")) {
    return parseString(schema);
  } else if (its.a.primitive(schema, "number") || its.a.primitive(schema, "integer")) {
    return parseNumber(schema);
  } else if (its.a.primitive(schema, "boolean")) {
    return parseBoolean(schema);
  } else if (its.a.primitive(schema, "null")) {
    return parseNull(schema);
  } else if (its.a.conditional(schema)) {
    return parseIfThenElse(schema, refs);
  } else if (its.a.ref(schema)) {
    return parseRef(schema);
  } else {
    return parseDefault(schema);
  }
}, "selectParser");
var its = {
  an: {
    object: /* @__PURE__ */ __name((x) => x.type === "object", "object"),
    array: /* @__PURE__ */ __name((x) => x.type === "array", "array"),
    anyOf: /* @__PURE__ */ __name((x) => x.anyOf !== void 0, "anyOf"),
    allOf: /* @__PURE__ */ __name((x) => x.allOf !== void 0, "allOf"),
    enum: /* @__PURE__ */ __name((x) => x.enum !== void 0, "enum")
  },
  a: {
    nullable: /* @__PURE__ */ __name((x) => x.nullable === true, "nullable"),
    multipleType: /* @__PURE__ */ __name((x) => Array.isArray(x.type), "multipleType"),
    not: /* @__PURE__ */ __name((x) => x.not !== void 0, "not"),
    const: /* @__PURE__ */ __name((x) => x.const !== void 0, "const"),
    primitive: /* @__PURE__ */ __name((x, p) => x.type === p, "primitive"),
    conditional: /* @__PURE__ */ __name((x) => Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else), "conditional"),
    discriminator: /* @__PURE__ */ __name((x) => {
      var _a;
      return x.oneOf !== void 0 && ((_a = x.discriminator) == null ? void 0 : _a.propertyName) !== void 0;
    }, "discriminator"),
    oneOf: /* @__PURE__ */ __name((x) => x.oneOf !== void 0, "oneOf"),
    ref: /* @__PURE__ */ __name((x) => x.$ref !== void 0, "ref")
  }
};

// src/transforms/common/eval-zui-string.ts
var evalZuiString = /* @__PURE__ */ __name((zuiString) => {
  let result;
  try {
    result = new Function("z", `return ${zuiString}`)(z_default);
  } catch (thrown) {
    const err = thrown instanceof Error ? thrown : new Error(String(thrown));
    return { sucess: false, error: `Failed to evaluate schema: ${err.message}` };
  }
  if (!(result instanceof z_default.ZodType)) {
    return { sucess: false, error: `String "${zuiString}" does not evaluate to a Zod schema` };
  }
  return {
    sucess: true,
    value: result
  };
}, "evalZuiString");

// src/transforms/zui-from-json-schema-legacy/index.ts
var jsonSchemaToZodStr = /* @__PURE__ */ __name((schema) => {
  return parseSchema(schema, {
    seen: /* @__PURE__ */ new Map(),
    path: []
  });
}, "jsonSchemaToZodStr");
var jsonSchemaToZod = /* @__PURE__ */ __name((schema) => {
  let code = jsonSchemaToZodStr(schema);
  code = code.replaceAll("errors: z.ZodError[]", "errors");
  const evaluationResult = evalZuiString(code);
  if (!evaluationResult.sucess) {
    throw new JSONSchemaToZuiError(evaluationResult.error);
  }
  return evaluationResult.value;
}, "jsonSchemaToZod");
var applyZuiPropsRecursively = /* @__PURE__ */ __name((zodField, jsonSchemaField) => {
  var _a, _b;
  if (jsonSchemaField[zuiKey] && zodField._def) {
    zodField.naked()._def[zuiKey] = jsonSchemaField[zuiKey];
  }
  if (((_a = zodField._def) == null ? void 0 : _a.typeName) === "ZodObject" && jsonSchemaField.type === "object" && jsonSchemaField.properties) {
    Object.entries(jsonSchemaField.properties).forEach(([key, nestedField]) => {
      const shape = typeof zodField._def.shape === "function" ? zodField._def.shape() : zodField._def.shape;
      if (shape[key]) {
        applyZuiPropsRecursively(shape[key], nestedField);
      }
    });
  }
  if (((_b = zodField._def) == null ? void 0 : _b.typeName) === "ZodRecord" && jsonSchemaField.type === "object" && jsonSchemaField.additionalProperties) {
    applyZuiPropsRecursively(zodField._def.valueType, jsonSchemaField.additionalProperties);
  }
  if (jsonSchemaField.type === "array" && jsonSchemaField.items) {
    const items = jsonSchemaField.items;
    if (typeof items === "object" && !Array.isArray(items)) {
      const arrayShape = zodField._def.type;
      if (arrayShape) {
        applyZuiPropsRecursively(arrayShape, items);
      }
    } else if (Array.isArray(items)) {
      items.forEach((item, index) => {
        const def = zodField._def;
        if (def.typeName === z_exports.ZodFirstPartyTypeKind.ZodTuple) {
          applyZuiPropsRecursively(def.items[index], item);
        }
      });
    }
  }
}, "applyZuiPropsRecursively");
var fromJSONSchemaLegacy = /* @__PURE__ */ __name((schema) => {
  const zodSchema = jsonSchemaToZod(schema);
  applyZuiPropsRecursively(zodSchema, schema);
  return zodSchema;
}, "fromJSONSchemaLegacy");

// src/transforms/zui-from-json-schema/guards.ts
var isOptionalSchema = /* @__PURE__ */ __name((s) => {
  var _a, _b;
  return s.anyOf !== void 0 && s.anyOf.length === 2 && s.anyOf.some((s2) => typeof s2 !== "boolean" && isUndefinedSchema(s2)) && ((_b = (_a = s["x-zui"]) == null ? void 0 : _a.def) == null ? void 0 : _b.typeName) === z_default.ZodFirstPartyTypeKind.ZodOptional;
}, "isOptionalSchema");
var isNullableSchema = /* @__PURE__ */ __name((s) => {
  var _a, _b;
  return s.anyOf !== void 0 && s.anyOf.length === 2 && s.anyOf.some((s2) => typeof s2 !== "boolean" && s2.type === "null") && ((_b = (_a = s["x-zui"]) == null ? void 0 : _a.def) == null ? void 0 : _b.typeName) === z_default.ZodFirstPartyTypeKind.ZodNullable;
}, "isNullableSchema");
var isUndefinedSchema = /* @__PURE__ */ __name((s) => {
  var _a, _b;
  return s.not === true && ((_b = (_a = s["x-zui"]) == null ? void 0 : _a.def) == null ? void 0 : _b.typeName) === z_default.ZodFirstPartyTypeKind.ZodUndefined;
}, "isUndefinedSchema");
var isUnknownSchema = /* @__PURE__ */ __name((s) => {
  var _a, _b;
  return !s.not && ((_b = (_a = s["x-zui"]) == null ? void 0 : _a.def) == null ? void 0 : _b.typeName) === z_default.ZodFirstPartyTypeKind.ZodUnknown;
}, "isUnknownSchema");

// src/transforms/zui-from-json-schema/primitives/number.ts
var numberJSONSchemaToZuiNumber = /* @__PURE__ */ __name(({
  type,
  minimum,
  exclusiveMinimum,
  maximum,
  exclusiveMaximum,
  multipleOf,
  format
}) => {
  let zodNumber = z_default.number();
  if (type === "integer") {
    zodNumber = zodNumber.int();
  }
  if (format === "finite") {
    zodNumber = zodNumber.finite();
  }
  if (exclusiveMinimum !== void 0) {
    zodNumber = zodNumber.gt(exclusiveMinimum);
  } else if (minimum !== void 0) {
    zodNumber = zodNumber.gte(minimum);
  }
  if (exclusiveMaximum !== void 0) {
    zodNumber = zodNumber.lt(exclusiveMaximum);
  } else if (maximum !== void 0) {
    zodNumber = zodNumber.lte(maximum);
  }
  if (multipleOf !== void 0) {
    zodNumber = zodNumber.multipleOf(multipleOf);
  }
  return zodNumber;
}, "numberJSONSchemaToZuiNumber");

// src/transforms/zui-from-json-schema/primitives/string.ts
var stringJSONSchemaToZuiString = /* @__PURE__ */ __name(({
  format,
  pattern,
  minLength,
  maxLength
}) => {
  let zodString = z_default.string();
  if (minLength && maxLength && minLength === maxLength) {
    zodString = zodString.length(minLength);
  } else {
    if (minLength) {
      zodString = zodString.min(minLength);
    }
    if (maxLength) {
      zodString = zodString.max(maxLength);
    }
  }
  if (format === "cuid" || pattern === zodPatterns.cuid) {
    zodString = zodString.cuid();
  } else if (format === "cuid2" || pattern === zodPatterns.cuid2) {
    zodString = zodString.cuid2();
  } else if (format === "emoji" || pattern === zodPatterns.emoji) {
    zodString = zodString.emoji();
  } else if (format === "ulid" || pattern === zodPatterns.ulid) {
    zodString = zodString.ulid();
  } else if (format === "date-time") {
    const { precision, offset } = pattern ? extractPrecisionAndOffset(pattern) : {};
    zodString = zodString.datetime({ precision, offset });
  } else if (format === "email" || pattern === zodPatterns.email) {
    zodString = zodString.email();
  } else if (format === "ipv4" || pattern === zodPatterns.ipv4) {
    zodString = zodString.ip();
  } else if (format === "ipv6" || pattern === zodPatterns.ipv6) {
    zodString = zodString.ip("v6");
  } else if (format === "uri") {
    zodString = zodString.url();
  } else if (format === "uuid" || pattern === zodPatterns.uuid) {
    zodString = zodString.uuid();
  } else if (pattern) {
    zodString = zodString.regex(new RegExp(pattern));
  }
  return zodString;
}, "stringJSONSchemaToZuiString");

// src/transforms/zui-from-json-schema/primitives/index.ts
var toZuiPrimitive = /* @__PURE__ */ __name((type, schema) => {
  const values = [];
  if (schema.enum !== void 0) {
    values.push(...schema.enum);
  }
  if (schema.const !== void 0) {
    values.push(schema.const);
  }
  const primitiveValues = values.filter((value) => typeof value === type);
  const [first] = primitiveValues;
  if (!first) {
    if (type === "string" && schema.type === "string") {
      return stringJSONSchemaToZuiString(schema);
    }
    if (type === "number" && (schema.type === "number" || schema.type === "integer")) {
      return numberJSONSchemaToZuiNumber(
        schema
      );
    }
    if (type === "boolean") {
      return z_default.boolean();
    }
    if (type === "null") {
      return z_default.null();
    }
    throw new JSONSchemaToZuiError(`Unknown primitive type: "${type}"`);
  }
  if (primitiveValues.length === 1) {
    return z_default.literal(first);
  }
  const items = primitiveValues.map((value) => z_default.literal(value));
  return z_default.union(items);
}, "toZuiPrimitive");

// src/transforms/zui-from-json-schema/iterables/array.ts
var arrayJSONSchemaToZuiArray = /* @__PURE__ */ __name((schema, toZui) => _isTuple(schema) ? _handleTuple(schema, toZui) : _isSet(schema) ? _handleSet(schema, toZui) : _handleArray(schema, toZui), "arrayJSONSchemaToZuiArray");
var _isTuple = /* @__PURE__ */ __name((schema) => Array.isArray(schema.items), "_isTuple");
var _isSet = /* @__PURE__ */ __name((schema) => schema.items !== void 0 && schema.uniqueItems, "_isSet");
var _handleTuple = /* @__PURE__ */ __name(({ items, additionalItems }, toZui) => {
  const itemSchemas = items.map(toZui);
  let zodTuple = z_default.tuple(itemSchemas);
  if (additionalItems !== void 0) {
    zodTuple = zodTuple.rest(toZui(additionalItems));
  }
  return zodTuple;
}, "_handleTuple");
var _handleSet = /* @__PURE__ */ __name(({ items, minItems, maxItems }, toZui) => {
  let zodSet = z_default.set(toZui(items));
  if (minItems) {
    zodSet = zodSet.min(minItems);
  }
  if (maxItems) {
    zodSet = zodSet.max(maxItems);
  }
  return zodSet;
}, "_handleSet");
var _handleArray = /* @__PURE__ */ __name(({ minItems, maxItems, items }, toZui) => {
  let zodArray = z_default.array(toZui(items));
  if (minItems && minItems === maxItems) {
    return zodArray.length(minItems);
  }
  if (minItems) {
    zodArray = zodArray.min(minItems);
  }
  if (maxItems) {
    zodArray = zodArray.max(maxItems);
  }
  return zodArray;
}, "_handleArray");

// src/transforms/zui-from-json-schema/index.ts
var DEFAULT_TYPE = z_default.any();
function fromJSONSchema(schema) {
  return _fromJSONSchema(schema);
}
__name(fromJSONSchema, "fromJSONSchema");
function _fromJSONSchema(schema) {
  var _b;
  if (schema === void 0) {
    return DEFAULT_TYPE;
  }
  if (schema === true) {
    return z_default.any();
  }
  if (schema === false) {
    return z_default.never();
  }
  if (schema.default !== void 0) {
    const inner = _fromJSONSchema(__spreadProps(__spreadValues({}, schema), { default: void 0 }));
    return inner.default(schema.default);
  }
  if (schema.readOnly) {
    const inner = _fromJSONSchema(__spreadProps(__spreadValues({}, schema), { readOnly: void 0 }));
    return inner.readonly();
  }
  if (schema.oneOf !== void 0) {
    throw new UnsupportedJSONSchemaToZuiError({ oneOf: schema.oneOf });
  }
  if (schema.patternProperties !== void 0) {
    throw new UnsupportedJSONSchemaToZuiError({ patternProperties: schema.patternProperties });
  }
  if (schema.propertyNames !== void 0) {
    throw new UnsupportedJSONSchemaToZuiError({ propertyNames: schema.propertyNames });
  }
  if (schema.if !== void 0) {
    throw new UnsupportedJSONSchemaToZuiError({ if: schema.if });
  }
  if (schema.then !== void 0) {
    throw new UnsupportedJSONSchemaToZuiError({ then: schema.then });
  }
  if (schema.else !== void 0) {
    throw new UnsupportedJSONSchemaToZuiError({ else: schema.else });
  }
  if (schema.$ref !== void 0) {
    return z_default.ref(schema.$ref);
  }
  if (schema.not !== void 0) {
    if (isUndefinedSchema(schema)) {
      return z_default.undefined();
    }
    if (schema.not === true) {
      return z_default.never();
    }
    throw new UnsupportedJSONSchemaToZuiError({ not: schema.not });
  }
  if (Array.isArray(schema.type)) {
    if (schema.type.length === 0) {
      return DEFAULT_TYPE;
    }
    if (schema.type.length === 1) {
      return _fromJSONSchema(__spreadProps(__spreadValues({}, schema), { type: schema.type[0] }));
    }
    const _a = schema, { type: _ } = _a, tmp = __objRest(_a, ["type"]);
    const types = schema.type.map((t) => _fromJSONSchema(__spreadProps(__spreadValues({}, tmp), { type: t })));
    return z_default.union(types);
  }
  if (schema.type === "string") {
    if (schema.enum && schema.enum.length > 0) {
      return z_default.enum(schema.enum);
    }
    return toZuiPrimitive("string", schema);
  }
  if (schema.type === "integer") {
    const zSchema = toZuiPrimitive("number", schema);
    if (zSchema instanceof z_default.ZodNumber) {
      return zSchema.int();
    }
    return zSchema;
  }
  if (schema.type === "number") {
    return toZuiPrimitive("number", schema);
  }
  if (schema.type === "boolean") {
    return toZuiPrimitive("boolean", schema);
  }
  if (schema.type === "null") {
    return toZuiPrimitive("null", schema);
  }
  if (schema.type === "array") {
    return arrayJSONSchemaToZuiArray(schema, _fromJSONSchema);
  }
  if (schema.type === "object") {
    if (schema.additionalProperties !== void 0 && schema.properties !== void 0) {
      const catchAll = _fromJSONSchema(schema.additionalProperties);
      const inner = _fromJSONSchema(__spreadProps(__spreadValues({}, schema), { additionalProperties: void 0 }));
      return inner.catchall(catchAll);
    }
    if (schema.properties !== void 0) {
      const properties = {};
      for (const [key, value] of Object.entries(schema.properties)) {
        const mapped = _fromJSONSchema(value);
        const required = (_b = schema.required) != null ? _b : [];
        properties[key] = required.includes(key) ? mapped : mapped.optional();
      }
      return z_default.object(properties);
    }
    if (schema.additionalProperties !== void 0) {
      const inner = _fromJSONSchema(schema.additionalProperties);
      return z_default.record(inner);
    }
    return z_default.record(DEFAULT_TYPE);
  }
  if (schema.anyOf !== void 0) {
    if (schema.anyOf.length === 0) {
      return DEFAULT_TYPE;
    }
    if (schema.anyOf.length === 1) {
      return _fromJSONSchema(schema.anyOf[0]);
    }
    if (isOptionalSchema(schema)) {
      const inner = _fromJSONSchema(schema.anyOf[0]);
      return inner.optional();
    }
    if (isNullableSchema(schema)) {
      const inner = _fromJSONSchema(schema.anyOf[0]);
      return inner.nullable();
    }
    const options = schema.anyOf.map(_fromJSONSchema);
    return z_default.union(options);
  }
  if (schema.allOf !== void 0) {
    if (schema.allOf.length === 0) {
      return DEFAULT_TYPE;
    }
    if (schema.allOf.length === 1) {
      return _fromJSONSchema(schema.allOf[0]);
    }
    const [left, ...right] = schema.allOf;
    const zLeft = _fromJSONSchema(left);
    const zRight = _fromJSONSchema({ allOf: right });
    return z_default.intersection(zLeft, zRight);
  }
  if (isUnknownSchema(schema)) {
    return z_default.unknown();
  }
  return DEFAULT_TYPE;
}
__name(_fromJSONSchema, "_fromJSONSchema");

// src/transforms/zui-from-object/index.ts
var dateTimeRegex = /^\d{4}-\d{2}-\d{2}(T|\s)?((\d{2}:\d{2}:\d{2}(\.\d{1,3})?)|(\d{2}:\d{2}))?(\s?([+-]\d{2}:\d{2}|Z))?$/;
var fromObject = /* @__PURE__ */ __name((obj, opts, isRoot = true) => {
  if (typeof obj !== "object") {
    throw new ObjectToZuiError("Input must be an object");
  }
  const applyOptions = /* @__PURE__ */ __name((zodType) => {
    let newType = zodType;
    if (opts == null ? void 0 : opts.nullable) {
      newType = newType.nullable();
    }
    if (opts == null ? void 0 : opts.optional) {
      newType = newType.optional();
    }
    if ((opts == null ? void 0 : opts.passtrough) && typeof newType.passthrough === "function") {
      newType = newType.passthrough();
    }
    return newType;
  }, "applyOptions");
  const schema = Object.entries(obj).reduce((acc, [key, value]) => {
    if (value === null) {
      acc[key] = applyOptions(z_exports.null());
    } else {
      switch (typeof value) {
        case "string":
          acc[key] = dateTimeRegex.test(value) ? applyOptions(z_exports.string().datetime()) : applyOptions(z_exports.string());
          break;
        case "number":
          acc[key] = applyOptions(z_exports.number());
          break;
        case "boolean":
          acc[key] = applyOptions(z_exports.boolean());
          break;
        case "object":
          if (Array.isArray(value)) {
            if (value.length === 0) {
              acc[key] = applyOptions(z_exports.array(z_exports.unknown()));
            } else if (typeof value[0] === "object") {
              acc[key] = applyOptions(z_exports.array(fromObject(value[0], opts, false)));
            } else if (["string", "number", "boolean"].includes(typeof value[0])) {
              acc[key] = applyOptions(z_exports.array(z_exports[typeof value[0]]()));
            }
          } else {
            acc[key] = applyOptions(fromObject(value, opts, false));
          }
          break;
        default:
          throw new ObjectToZuiError(`Unsupported type for key ${key}`);
      }
    }
    return acc;
  }, {});
  const hasProperties = Object.keys(schema).length > 0;
  if ((opts == null ? void 0 : opts.passtrough) || !isRoot && !hasProperties) {
    return z_exports.object(schema).passthrough();
  }
  return z_exports.object(schema);
}, "fromObject");

// src/transforms/zui-to-json-schema-legacy/parsers/any.ts
function parseAnyDef() {
  return {};
}
__name(parseAnyDef, "parseAnyDef");

// src/transforms/zui-to-json-schema-legacy/parsers/array.ts
function parseArrayDef(def, refs) {
  var _a, _b;
  const res = {
    type: "array"
  };
  if (((_b = (_a = def.type) == null ? void 0 : _a._def) == null ? void 0 : _b.typeName) !== "ZodAny" /* ZodAny */) {
    res.items = parseDef(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");

// src/transforms/zui-to-json-schema-legacy/parsers/bigint.ts
function parseBigintDef(def, refs) {
  const res = __spreadValues({
    type: "integer",
    format: "int64"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");

// src/transforms/zui-to-json-schema-legacy/parsers/boolean.ts
function parseBooleanDef(def) {
  return __spreadValues({
    type: "boolean"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
}
__name(parseBooleanDef, "parseBooleanDef");

// src/transforms/zui-to-json-schema-legacy/parsers/branded.ts
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");

// src/transforms/zui-to-json-schema-legacy/parsers/catch.ts
var parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseCatchDef");

// src/transforms/zui-to-json-schema-legacy/parsers/date.ts
function parseDateDef(def, refs) {
  if (refs.dateStrategy == "integer") {
    return integerDateParser(def, refs);
  } else {
    return __spreadValues({
      type: "string",
      format: "date-time"
    }, def.coerce ? {
      [zuiKey]: {
        coerce: def.coerce || void 0
      }
    } : {});
  }
}
__name(parseDateDef, "parseDateDef");
var integerDateParser = /* @__PURE__ */ __name((def, refs) => {
  const res = __spreadValues({
    type: "integer",
    format: "unix-time"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
    }
  }
  return res;
}, "integerDateParser");

// src/transforms/zui-to-json-schema-legacy/parsers/default.ts
function parseDefaultDef(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
__name(parseDefaultDef, "parseDefaultDef");

// src/transforms/zui-to-json-schema-legacy/parsers/effects.ts
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
__name(parseEffectsDef, "parseEffectsDef");

// src/transforms/zui-to-json-schema-legacy/parsers/enum.ts
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}
__name(parseEnumDef, "parseEnumDef");

// src/transforms/zui-to-json-schema-legacy/parsers/intersection.ts
var isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a = schema, { additionalProperties } = _a, rest = __objRest(_a, ["additionalProperties"]);
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? __spreadValues({
    allOf: mergedAllOf
  }, unevaluatedProperties) : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");

// src/transforms/zui-to-json-schema-legacy/parsers/literal.ts
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");

// src/transforms/zui-to-json-schema-legacy/parsers/record.ts
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e;
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce(
        (acc, key) => {
          var _a2;
          return __spreadProps(__spreadValues({}, acc), {
            [key]: (_a2 = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
              currentPath: [...refs.currentPath, "properties", key]
            }))) != null ? _a2 : {}
          });
        },
        {}
      ),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: (_b = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _b : {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_c = def.keyType) == null ? void 0 : _c._def.typeName) === "ZodString" /* ZodString */ && ((_d = def.keyType._def.checks) == null ? void 0 : _d.length)) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce(
      (acc, [key, value]) => key === "type" ? acc : __spreadProps(__spreadValues({}, acc), { [key]: value }),
      {}
    );
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  }
  return schema;
}
__name(parseRecordDef, "parseRecordDef");

// src/transforms/zui-to-json-schema-legacy/parsers/map.ts
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys2 = parseDef(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || {};
  const values = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys2, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");

// src/transforms/zui-to-json-schema-legacy/parsers/nativeEnum.ts
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues.filter(
      (value) => typeof value === "string" || typeof value === "number"
    )
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");

// src/transforms/zui-to-json-schema-legacy/parsers/never.ts
function parseNeverDef() {
  return {
    not: {}
  };
}
__name(parseNeverDef, "parseNeverDef");

// src/transforms/zui-to-json-schema-legacy/parsers/null.ts
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");

// src/transforms/zui-to-json-schema-legacy/parsers/union.ts
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3") return asUnionOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null) return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))],
        []
      )
    };
  }
  return asUnionOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
var asUnionOf = /* @__PURE__ */ __name((def, refs) => {
  const unionOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, refs.unionStrategy, `${i}`]
    }))
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  const discriminator = refs.discriminator && def.typeName === "ZodDiscriminatedUnion" && typeof def.discriminator === "string" ? { discriminator: { propertyName: def.discriminator } } : {};
  if (!unionOf.length) {
    return void 0;
  }
  return refs.unionStrategy === "anyOf" ? __spreadValues({ anyOf: unionOf }, discriminator) : __spreadValues({ oneOf: unionOf }, discriminator);
}, "asUnionOf");

// src/transforms/zui-to-json-schema-legacy/parsers/nullable.ts
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    const inner = def.innerType;
    if (refs.target === "openApi3") {
      const schema2 = {
        type: primitiveMappings[inner._def.typeName],
        nullable: true
      };
      return addMeta2(inner._def, refs, schema2);
    }
    const schema = {
      type: [primitiveMappings[inner._def.typeName], "null"]
    };
    return addMeta2(inner._def, refs, schema);
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath]
    }));
    return base2 && __spreadProps(__spreadValues({}, base2), { nullable: true });
  }
  const base = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");

// src/transforms/zui-to-json-schema-legacy/parsers/number.ts
function parseNumberDef(def, refs) {
  const res = __spreadValues({
    type: "number"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");

// src/transforms/zui-to-json-schema-legacy/parsers/object.ts
var getAdditionalProperties = /* @__PURE__ */ __name((def, refs) => {
  var _a;
  if (def.unknownKeys instanceof ZodType) {
    return (_a = parseDef(def.unknownKeys._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a : true;
  }
  if (def.unknownKeys === "passthrough") {
    return true;
  }
  return false;
}, "getAdditionalProperties");
function parseObjectDef(def, refs) {
  const result = __spreadProps(__spreadValues({
    type: "object"
  }, Object.entries(def.shape()).reduce(
    (acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0) return acc;
      const parsedDef = parseDef(propDef._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      }));
      if (parsedDef === void 0) return acc;
      return {
        properties: __spreadProps(__spreadValues({}, acc.properties), { [propName]: parsedDef }),
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    },
    { properties: {}, required: [] }
  )), {
    additionalProperties: getAdditionalProperties(def, refs)
  });
  if (!result.required.length) delete result.required;
  return result;
}
__name(parseObjectDef, "parseObjectDef");

// src/transforms/zui-to-json-schema-legacy/parsers/optional.ts
var parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "1"]
  }));
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
}, "parseOptionalDef");

// src/transforms/zui-to-json-schema-legacy/parsers/pipeline.ts
var parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", "0"]
  }));
  const b = parseDef(def.out._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  }));
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");

// src/transforms/zui-to-json-schema-legacy/parsers/promise.ts
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");

// src/transforms/zui-to-json-schema-legacy/parsers/set.ts
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
__name(parseSetDef, "parseSetDef");

// src/transforms/zui-to-json-schema-legacy/parsers/tuple.ts
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
__name(parseTupleDef, "parseTupleDef");

// src/transforms/zui-to-json-schema-legacy/parsers/undefined.ts
function parseUndefinedDef() {
  return {
    not: {}
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");

// src/transforms/zui-to-json-schema-legacy/parsers/unknown.ts
function parseUnknownDef() {
  return {};
}
__name(parseUnknownDef, "parseUnknownDef");

// src/transforms/zui-to-json-schema-legacy/parsers/readonly.ts
var parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseReadonlyDef");

// src/transforms/zui-to-json-schema-legacy/parsers/ref.ts
function parseRefDef(def) {
  return {
    $ref: def.uri
  };
}
__name(parseRefDef, "parseRefDef");

// src/transforms/zui-to-json-schema-legacy/parseDef.ts
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser2(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta2(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
__name(parseDef, "parseDef");
var get$ref = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
}, "get$ref");
var getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, "getRelativePath");
var selectParser2 = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case "ZodString" /* ZodString */:
      return parseStringDef(def, refs);
    case "ZodNumber" /* ZodNumber */:
      return parseNumberDef(def, refs);
    case "ZodObject" /* ZodObject */:
      return parseObjectDef(def, refs);
    case "ZodBigInt" /* ZodBigInt */:
      return parseBigintDef(def, refs);
    case "ZodBoolean" /* ZodBoolean */:
      return parseBooleanDef(def);
    case "ZodDate" /* ZodDate */:
      return parseDateDef(def, refs);
    case "ZodUndefined" /* ZodUndefined */:
      return parseUndefinedDef();
    case "ZodNull" /* ZodNull */:
      return parseNullDef(refs);
    case "ZodArray" /* ZodArray */:
      return parseArrayDef(def, refs);
    case "ZodUnion" /* ZodUnion */:
    case "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */:
      return parseUnionDef(def, refs);
    case "ZodIntersection" /* ZodIntersection */:
      return parseIntersectionDef(def, refs);
    case "ZodTuple" /* ZodTuple */:
      return parseTupleDef(def, refs);
    case "ZodRecord" /* ZodRecord */:
      return parseRecordDef(def, refs);
    case "ZodRef" /* ZodRef */:
      return parseRefDef(def);
    case "ZodLiteral" /* ZodLiteral */:
      return parseLiteralDef(def, refs);
    case "ZodEnum" /* ZodEnum */:
      return parseEnumDef(def);
    case "ZodNativeEnum" /* ZodNativeEnum */:
      return parseNativeEnumDef(def);
    case "ZodNullable" /* ZodNullable */:
      return parseNullableDef(def, refs);
    case "ZodOptional" /* ZodOptional */:
      return parseOptionalDef(def, refs);
    case "ZodMap" /* ZodMap */:
      return parseMapDef(def, refs);
    case "ZodSet" /* ZodSet */:
      return parseSetDef(def, refs);
    case "ZodLazy" /* ZodLazy */:
      return parseDef(def.getter()._def, refs);
    case "ZodPromise" /* ZodPromise */:
      return parsePromiseDef(def, refs);
    case "ZodNaN" /* ZodNaN */:
    case "ZodNever" /* ZodNever */:
      return parseNeverDef();
    case "ZodEffects" /* ZodEffects */:
      return parseEffectsDef(def, refs);
    case "ZodAny" /* ZodAny */:
      return parseAnyDef();
    case "ZodUnknown" /* ZodUnknown */:
      return parseUnknownDef();
    case "ZodDefault" /* ZodDefault */:
      return parseDefaultDef(def, refs);
    case "ZodBranded" /* ZodBranded */:
      return parseBrandedDef(def, refs);
    case "ZodReadonly" /* ZodReadonly */:
      return parseReadonlyDef(def, refs);
    case "ZodCatch" /* ZodCatch */:
      return parseCatchDef(def, refs);
    case "ZodPipeline" /* ZodPipeline */:
      return parsePipelineDef(def, refs);
    case "ZodFunction" /* ZodFunction */:
    case "ZodVoid" /* ZodVoid */:
    case "ZodSymbol" /* ZodSymbol */:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");
var addMeta2 = /* @__PURE__ */ __name((def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  Object.assign(jsonSchema, { [zuiKey]: __spreadValues(__spreadValues({}, def[zuiKey]), jsonSchema[zuiKey]) });
  return jsonSchema;
}, "addMeta");

// src/transforms/zui-to-json-schema-legacy/Options.ts
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  emailStrategy: "format:email",
  discriminator: false,
  unionStrategy: "anyOf"
};
var getDefaultOptions = /* @__PURE__ */ __name((options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions), {
  name: options
}) : __spreadValues(__spreadValues({}, defaultOptions), options), "getDefaultOptions");

// src/transforms/zui-to-json-schema-legacy/Refs.ts
var getRefs = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return __spreadProps(__spreadValues({}, _options), {
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
}, "getRefs");

// src/transforms/zui-to-json-schema-legacy/zodToJsonSchema.ts
var zodToJsonSchema = /* @__PURE__ */ __name((schema, options) => {
  var _a;
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2, schema2]) => {
      var _a2;
      return __spreadProps(__spreadValues({}, acc), {
        [name2]: (_a2 = parseDef(
          schema2._def,
          __spreadProps(__spreadValues({}, refs), {
            currentPath: [...refs.basePath, refs.definitionPath, name2]
          }),
          true
        )) != null ? _a2 : {}
      });
    },
    {}
  ) : void 0;
  const name = typeof options === "string" ? options : options == null ? void 0 : options.name;
  const main = (_a = parseDef(
    schema._def,
    name === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }),
    false
  )) != null ? _a : {};
  const combined = name === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
    [refs.definitionPath]: definitions
  }) : main : {
    $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
    [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
      [name]: main
    })
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
}, "zodToJsonSchema");

// src/transforms/zui-to-json-schema-legacy/zui-extension.ts
var toJSONSchemaLegacy = /* @__PURE__ */ __name((zuiType, opts = { target: "openApi3" }) => {
  const jsonSchema = zodToJsonSchema(zuiType, opts);
  if (opts.$schemaUrl === false) {
    delete jsonSchema.$schema;
  } else if (typeof opts.$schemaUrl === "string") {
    jsonSchema.$schema = opts.$schemaUrl;
  }
  return jsonSchema;
}, "toJSONSchemaLegacy");
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=index.cjs.map