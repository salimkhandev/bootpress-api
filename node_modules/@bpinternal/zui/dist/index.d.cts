import { JSONSchema7 } from 'json-schema';
export { JSONSchema7 } from 'json-schema';

type allKeys<T> = T extends any ? keyof T : never;
type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;
type typeToFlattenedError<T, U = string> = {
    formErrors: U[];
    fieldErrors: {
        [P in allKeys<T>]?: U[];
    };
};
declare const ZodIssueCode: {
    invalid_type: "invalid_type";
    invalid_literal: "invalid_literal";
    custom: "custom";
    invalid_union: "invalid_union";
    invalid_union_discriminator: "invalid_union_discriminator";
    invalid_enum_value: "invalid_enum_value";
    unrecognized_keys: "unrecognized_keys";
    invalid_arguments: "invalid_arguments";
    invalid_return_type: "invalid_return_type";
    invalid_date: "invalid_date";
    invalid_string: "invalid_string";
    too_small: "too_small";
    too_big: "too_big";
    invalid_intersection_types: "invalid_intersection_types";
    not_multiple_of: "not_multiple_of";
    not_finite: "not_finite";
    unresolved_reference: "unresolved_reference";
};
type ZodIssueCode = keyof typeof ZodIssueCode;
type ZodIssueBase = {
    path: (string | number)[];
    message?: string;
};
interface ZodInvalidTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_type;
    expected: ZodParsedType;
    received: ZodParsedType;
}
interface ZodInvalidLiteralIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_literal;
    expected: unknown;
    received: unknown;
}
interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.unrecognized_keys;
    keys: string[];
}
interface ZodInvalidUnionIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union;
    unionErrors: ZodError[];
}
interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union_discriminator;
    options: Primitive[];
}
interface ZodInvalidEnumValueIssue extends ZodIssueBase {
    received: string | number;
    code: typeof ZodIssueCode.invalid_enum_value;
    options: (string | number)[];
}
interface ZodInvalidArgumentsIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_arguments;
    argumentsError: ZodError;
}
interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_return_type;
    returnTypeError: ZodError;
}
interface ZodInvalidDateIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_date;
}
type StringValidation = 'email' | 'url' | 'emoji' | 'uuid' | 'regex' | 'cuid' | 'cuid2' | 'ulid' | 'datetime' | 'ip' | {
    includes: string;
    position?: number;
} | {
    startsWith: string;
} | {
    endsWith: string;
};
interface ZodInvalidStringIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_string;
    validation: StringValidation;
}
interface ZodTooSmallIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_small;
    minimum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: 'array' | 'string' | 'number' | 'set' | 'date' | 'bigint';
}
interface ZodTooBigIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_big;
    maximum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: 'array' | 'string' | 'number' | 'set' | 'date' | 'bigint';
}
interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_intersection_types;
}
interface ZodNotMultipleOfIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_multiple_of;
    multipleOf: number | bigint;
}
interface ZodNotFiniteIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_finite;
}
interface ZodUnresolvedReferenceIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.unresolved_reference;
}
interface ZodCustomIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params?: {
        [k: string]: any;
    };
}
type DenormalizedError = {
    [k: string]: DenormalizedError | string[];
};
type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodUnresolvedReferenceIssue | ZodCustomIssue;
type ZodIssue = ZodIssueOptionalMessage & {
    fatal?: boolean;
    message: string;
};
declare const quotelessJson: (obj: any) => string;
type recursiveZodFormattedError<T> = T extends [any, ...any[]] ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : T extends any[] ? {
    [k: number]: ZodFormattedError<T[number]>;
} : T extends object ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : unknown;
type ZodFormattedError<T, U = string> = {
    _errors: U[];
} & recursiveZodFormattedError<NonNullable<T>>;
type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;
declare class ZodError<T = any> extends Error {
    issues: ZodIssue[];
    get errors(): ZodIssue[];
    constructor(issues: ZodIssue[]);
    format(): ZodFormattedError<T>;
    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;
    static create: (issues: ZodIssue[]) => ZodError<any>;
    static assert(value: unknown): asserts value is ZodError;
    toString(): string;
    get message(): string;
    get isEmpty(): boolean;
    addIssue: (sub: ZodIssue) => void;
    addIssues: (subs?: ZodIssue[]) => void;
    flatten(): typeToFlattenedError<T>;
    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;
    get formErrors(): typeToFlattenedError<T, string>;
}
type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
type IssueData = stripPath<ZodIssueOptionalMessage> & {
    path?: (string | number)[];
    fatal?: boolean;
};
type ErrorMapCtx = {
    defaultError: string;
    data: any;
};
type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {
    message: string;
};

declare function setErrorMap(map: ZodErrorMap): void;
declare function getErrorMap(): ZodErrorMap;

declare const makeIssue: (params: {
    data: any;
    path: (string | number)[];
    errorMaps: ZodErrorMap[];
    issueData: IssueData;
}) => ZodIssue;
type ParseParams = {
    path: (string | number)[];
    errorMap: ZodErrorMap;
    async: boolean;
};
type ParsePathComponent = string | number;
type ParsePath = ParsePathComponent[];
declare const EMPTY_PATH: ParsePath;
interface ParseContext {
    readonly common: {
        readonly issues: ZodIssue[];
        readonly contextualErrorMap?: ZodErrorMap;
        readonly async: boolean;
    };
    readonly path: ParsePath;
    readonly schemaErrorMap?: ZodErrorMap;
    readonly parent: ParseContext | null;
    readonly data: any;
    readonly parsedType: ZodParsedType;
}
type ParseInput = {
    data: any;
    path: (string | number)[];
    parent: ParseContext;
};
declare function addIssueToContext(ctx: ParseContext, issueData: IssueData): void;
type ObjectPair = {
    key: SyncParseReturnType<any>;
    value: SyncParseReturnType<any>;
};
declare class ParseStatus {
    value: 'aborted' | 'dirty' | 'valid';
    dirty(): void;
    abort(): void;
    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;
    static mergeObjectAsync(status: ParseStatus, pairs: {
        key: ParseReturnType<any>;
        value: ParseReturnType<any>;
    }[]): Promise<SyncParseReturnType<any>>;
    static mergeObjectSync(status: ParseStatus, pairs: {
        key: SyncParseReturnType<any>;
        value: SyncParseReturnType<any>;
        alwaysSet?: boolean;
    }[]): SyncParseReturnType;
}
interface ParseResult {
    status: 'aborted' | 'dirty' | 'valid';
    data: any;
}
type INVALID = {
    status: 'aborted';
};
declare const INVALID: INVALID;
type DIRTY<T> = {
    status: 'dirty';
    value: T;
};
declare const DIRTY: <T>(value: T) => DIRTY<T>;
type OK<T> = {
    status: 'valid';
    value: T;
};
declare const OK: <T>(value: T) => OK<T>;
type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;
declare const isAborted: (x: ParseReturnType<any>) => x is INVALID;
declare const isDirty: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;
declare const isValid: <T>(x: ParseReturnType<T>) => x is OK<T>;
declare const isAsync: <T>(x: ParseReturnType<T>) => x is AsyncParseReturnType<T>;

type Primitive = string | number | symbol | bigint | boolean | null | undefined;
type Scalars = Primitive | Primitive[];

declare const variableType: ZodEnum<["any", "string", "number", "boolean", "object", "pattern", "date", "array", "target", "time", "enum"]>;
declare const variable: (opts?: {
    type?: TypeOf<typeof variableType>;
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const conversation: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const user: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const message: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const agent: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const event: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const table: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const tablerow: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const intent: (opts?: {
    params?: {
        horizontal?: boolean;
    };
}) => ZodString;
declare const aimodel: () => ZodEnum<["gpt-3.5-turbo", "gpt-3.5-turbo-16k", "gpt-4", "gpt-4-1106-preview", "gpt-4-vision-preview", "gpt-4-0125-preview", "gpt-4-turbo-preview", "gpt-4-turbo", "gpt-4o", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-1106"]>;
declare const datasource: (opts?: {
    horizontal?: boolean;
}) => ZodString;
declare const knowledgebase: (opts?: {
    horizontal?: boolean;
}) => ZodString;

declare const late: {
    object: <T extends ZodRawShape>(shape: () => T, params?: RawCreateParams) => ZodObject<T, "strip">;
};
type ZodFirstPartySchemaTypes = ZodString | ZodNumber | ZodNaN | ZodBigInt | ZodBoolean | ZodDate | ZodUndefined | ZodNull | ZodAny | ZodUnknown | ZodNever | ZodVoid | ZodArray | ZodObject | ZodUnion | ZodDiscriminatedUnion | ZodIntersection | ZodTuple | ZodRecord | ZodMap | ZodSet | ZodFunction | ZodLazy | ZodLiteral | ZodEnum | ZodEffects | ZodNativeEnum | ZodOptional | ZodNullable | ZodDefault | ZodCatch | ZodPromise | ZodBranded | ZodPipeline | ZodReadonly | ZodSymbol | ZodRef;
declare abstract class Class {
    constructor(..._: any[]);
}
declare const instanceOfType: <T extends typeof Class>(cls: T, params?: CustomParams) => ZodType<InstanceType<T>, ZodTypeDef, InstanceType<T>>;
declare const stringType: (params?: RawCreateParams & {
    coerce?: true;
}) => ZodString;
declare const numberType: (params?: RawCreateParams & {
    coerce?: boolean;
}) => ZodNumber;
declare const nanType: (params?: RawCreateParams) => ZodNaN;
declare const bigIntType: (params?: RawCreateParams & {
    coerce?: boolean;
}) => ZodBigInt;
declare const booleanType: (params?: RawCreateParams & {
    coerce?: boolean;
}) => ZodBoolean;
declare const dateType: (params?: RawCreateParams & {
    coerce?: boolean;
}) => ZodDate;
declare const symbolType: (params?: RawCreateParams) => ZodSymbol;
declare const undefinedType: (params?: RawCreateParams) => ZodUndefined;
declare const nullType: (params?: RawCreateParams) => ZodNull;
declare const anyType: (params?: RawCreateParams) => ZodAny;
declare const unknownType: (params?: RawCreateParams) => ZodUnknown;
declare const neverType: (params?: RawCreateParams) => ZodNever;
declare const voidType: (params?: RawCreateParams) => ZodVoid;
declare const arrayType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodArray<T>;
declare const objectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, "strip">;
declare const strictObjectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, "strict">;
declare const unionType: <T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(types: T, params?: RawCreateParams) => ZodUnion<T>;
declare const discriminatedUnionType: typeof ZodDiscriminatedUnion.create;
declare const intersectionType: <T extends ZodTypeAny, U extends ZodTypeAny>(left: T, right: U, params?: RawCreateParams) => ZodIntersection<T, U>;
declare const tupleType: <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(schemas: T, params?: RawCreateParams) => ZodTuple<T, null>;
declare const recordType: typeof ZodRecord.create;
declare const refType: (uri: string) => ZodRef;
declare const readonlyType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodReadonly<T>;
declare const mapType: <Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny>(keyType: Key, valueType: Value, params?: RawCreateParams) => ZodMap<Key, Value>;
declare const setType: <Value extends ZodTypeAny = ZodTypeAny>(valueType: Value, params?: RawCreateParams) => ZodSet<Value>;
declare const functionType: typeof ZodFunction.create;
declare const lazyType: <T extends ZodTypeAny>(getter: () => T, params?: RawCreateParams) => ZodLazy<T>;
declare const literalType: <T extends Primitive>(value: T, params?: RawCreateParams) => ZodLiteral<T>;
declare const enumType: typeof createZodEnum;
declare const nativeEnumType: <T extends EnumLike>(values: T, params?: RawCreateParams) => ZodNativeEnum<T>;
declare const promiseType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodPromise<T>;
declare const effectsType: <I extends ZodType>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"]>;
declare const optionalType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodOptional<T>;
declare const nullableType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodNullable<T>;
declare const defaultType: <T extends ZodTypeAny>(type: T, value: T["_input"] | (() => util.noUndefined<T["_input"]>), params?: RawCreateParams) => ZodDefault<T>;
declare const preprocessType: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
declare const pipelineType: typeof ZodPipeline.create;
declare const ostring: () => ZodOptional<ZodString>;
declare const onumber: () => ZodOptional<ZodNumber>;
declare const oboolean: () => ZodOptional<ZodBoolean>;
declare const coerce: {
    string: (typeof ZodString)["create"];
    number: (typeof ZodNumber)["create"];
    boolean: (typeof ZodBoolean)["create"];
    bigint: (typeof ZodBigInt)["create"];
    date: (typeof ZodDate)["create"];
};

declare const NEVER: never;

type z_AdditionalProperties<T extends UnknownKeysParam> = AdditionalProperties<T>;
type z_AnyZodObject = AnyZodObject;
type z_AnyZodTuple = AnyZodTuple;
type z_ArrayCardinality = ArrayCardinality;
type z_ArrayKeys = ArrayKeys;
type z_AssertArray<T> = AssertArray<T>;
type z_AsyncParseReturnType<T> = AsyncParseReturnType<T>;
type z_BRAND<T extends Key = Key> = BRAND<T>;
type z_CatchFn<Y> = CatchFn<Y>;
type z_CustomErrorParams = CustomErrorParams;
type z_CustomParams = CustomParams;
declare const z_DIRTY: typeof DIRTY;
type z_DenormalizedError = DenormalizedError;
declare const z_EMPTY_PATH: typeof EMPTY_PATH;
type z_Effect<T> = Effect<T>;
type z_EnumLike = EnumLike;
type z_EnumValues = EnumValues;
type z_ErrorMapCtx = ErrorMapCtx;
type z_FilterEnum<Values, ToExclude> = FilterEnum<Values, ToExclude>;
declare const z_INVALID: typeof INVALID;
type z_Indices<T> = Indices<T>;
type z_InnerTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = InnerTypeOfFunction<Args, Returns>;
type z_InputTypeOfTuple<T extends ZodTupleItems | []> = InputTypeOfTuple<T>;
type z_InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = InputTypeOfTupleWithRest<T, Rest>;
type z_IpVersion = IpVersion;
type z_IssueData = IssueData;
type z_KeySchema = KeySchema;
type z_KindToDef<T extends ZodFirstPartyTypeKind> = KindToDef<T>;
type z_Maskable<T = any> = Maskable<T>;
declare const z_NEVER: typeof NEVER;
declare const z_OK: typeof OK;
type z_ObjectPair = ObjectPair;
type z_OfType<O, T extends __ZodType> = OfType<O, T>;
type z_OuterTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = OuterTypeOfFunction<Args, Returns>;
type z_OutputTypeOfTuple<T extends ZodTupleItems | []> = OutputTypeOfTuple<T>;
type z_OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = OutputTypeOfTupleWithRest<T, Rest>;
type z_ParseContext = ParseContext;
type z_ParseInput = ParseInput;
type z_ParseInputLazyPath = ParseInputLazyPath;
declare const z_ParseInputLazyPath: typeof ParseInputLazyPath;
type z_ParseParams = ParseParams;
type z_ParsePath = ParsePath;
type z_ParsePathComponent = ParsePathComponent;
type z_ParseResult = ParseResult;
type z_ParseReturnType<T> = ParseReturnType<T>;
type z_ParseStatus = ParseStatus;
declare const z_ParseStatus: typeof ParseStatus;
type z_PreprocessEffect<T> = PreprocessEffect<T>;
type z_Primitive = Primitive;
type z_ProcessedCreateParams = ProcessedCreateParams;
type z_RawCreateParams = RawCreateParams;
type z_RecordType<K extends string | number | symbol, V> = RecordType<K, V>;
type z_Refinement<T> = Refinement<T>;
type z_RefinementCtx = RefinementCtx;
type z_RefinementEffect<T> = RefinementEffect<T>;
type z_SafeParseError<Input> = SafeParseError<Input>;
type z_SafeParseReturnType<Input, Output> = SafeParseReturnType<Input, Output>;
type z_SafeParseSuccess<Output> = SafeParseSuccess<Output>;
type z_Scalars = Scalars;
type z_SomeZodObject = SomeZodObject;
type z_StringValidation = StringValidation;
type z_SuperRefinement<T> = SuperRefinement<T>;
type z_SyncParseReturnType<T = any> = SyncParseReturnType<T>;
type z_TransformEffect<T> = TransformEffect<T>;
type z_TypeOf<T extends __ZodType> = TypeOf<T>;
type z_UnknownKeysInputType<T extends UnknownKeysParam> = UnknownKeysInputType<T>;
type z_UnknownKeysOutputType<T extends UnknownKeysParam> = UnknownKeysOutputType<T>;
type z_UnknownKeysParam = UnknownKeysParam;
type z_Values<T extends EnumValues> = Values<T>;
type z_Writeable<T> = Writeable<T>;
type z_ZodAny = ZodAny;
declare const z_ZodAny: typeof ZodAny;
type z_ZodAnyDef = ZodAnyDef;
type z_ZodArray<T extends ZodTypeAny = ZodTypeAny, Cardinality extends ArrayCardinality = 'many'> = ZodArray<T, Cardinality>;
declare const z_ZodArray: typeof ZodArray;
type z_ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> = ZodArrayDef<T>;
type z_ZodBigInt = ZodBigInt;
declare const z_ZodBigInt: typeof ZodBigInt;
type z_ZodBigIntCheck = ZodBigIntCheck;
type z_ZodBigIntDef = ZodBigIntDef;
type z_ZodBoolean = ZodBoolean;
declare const z_ZodBoolean: typeof ZodBoolean;
type z_ZodBooleanDef = ZodBooleanDef;
type z_ZodBranded<T extends ZodTypeAny = ZodTypeAny, B extends Key = Key> = ZodBranded<T, B>;
declare const z_ZodBranded: typeof ZodBranded;
type z_ZodBrandedDef<T extends ZodTypeAny = ZodTypeAny> = ZodBrandedDef<T>;
type z_ZodCatch<T extends ZodTypeAny = ZodTypeAny> = ZodCatch<T>;
declare const z_ZodCatch: typeof ZodCatch;
type z_ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> = ZodCatchDef<T>;
type z_ZodCustomIssue = ZodCustomIssue;
type z_ZodDate = ZodDate;
declare const z_ZodDate: typeof ZodDate;
type z_ZodDateCheck = ZodDateCheck;
type z_ZodDateDef = ZodDateDef;
type z_ZodDef = ZodDef;
type z_ZodDefault<T extends ZodTypeAny = ZodTypeAny> = ZodDefault<T>;
declare const z_ZodDefault: typeof ZodDefault;
type z_ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> = ZodDefaultDef<T>;
type z_ZodDiscriminatedUnion<Discriminator extends string = string, Options extends ZodDiscriminatedUnionOption<Discriminator>[] = ZodDiscriminatedUnionOption<Discriminator>[]> = ZodDiscriminatedUnion<Discriminator, Options>;
declare const z_ZodDiscriminatedUnion: typeof ZodDiscriminatedUnion;
type z_ZodDiscriminatedUnionDef<Discriminator extends string = string, Options extends ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]> = ZodDiscriminatedUnionDef<Discriminator, Options>;
type z_ZodDiscriminatedUnionOption<Discriminator extends string> = ZodDiscriminatedUnionOption<Discriminator>;
type z_ZodEffects<T extends ZodTypeAny = ZodTypeAny, Output = output<T>, Input = input<T>> = ZodEffects<T, Output, Input>;
declare const z_ZodEffects: typeof ZodEffects;
type z_ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> = ZodEffectsDef<T>;
type z_ZodEnum<T extends [string, ...string[]] = [string, ...string[]]> = ZodEnum<T>;
declare const z_ZodEnum: typeof ZodEnum;
type z_ZodEnumDef<T extends EnumValues = EnumValues> = ZodEnumDef<T>;
type z_ZodError<T = any> = ZodError<T>;
declare const z_ZodError: typeof ZodError;
type z_ZodErrorMap = ZodErrorMap;
type z_ZodFirstPartySchemaTypes = ZodFirstPartySchemaTypes;
type z_ZodFirstPartyTypeKind = ZodFirstPartyTypeKind;
declare const z_ZodFirstPartyTypeKind: typeof ZodFirstPartyTypeKind;
type z_ZodFormattedError<T, U = string> = ZodFormattedError<T, U>;
type z_ZodFunction<Args extends ZodTuple<any, any> = ZodTuple, Returns extends ZodTypeAny = ZodTypeAny> = ZodFunction<Args, Returns>;
declare const z_ZodFunction: typeof ZodFunction;
type z_ZodFunctionDef<Args extends ZodTuple<any, any> = ZodTuple, Returns extends ZodTypeAny = ZodTypeAny> = ZodFunctionDef<Args, Returns>;
type z_ZodIntersection<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> = ZodIntersection<T, U>;
declare const z_ZodIntersection: typeof ZodIntersection;
type z_ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> = ZodIntersectionDef<T, U>;
type z_ZodInvalidArgumentsIssue = ZodInvalidArgumentsIssue;
type z_ZodInvalidDateIssue = ZodInvalidDateIssue;
type z_ZodInvalidEnumValueIssue = ZodInvalidEnumValueIssue;
type z_ZodInvalidIntersectionTypesIssue = ZodInvalidIntersectionTypesIssue;
type z_ZodInvalidLiteralIssue = ZodInvalidLiteralIssue;
type z_ZodInvalidReturnTypeIssue = ZodInvalidReturnTypeIssue;
type z_ZodInvalidStringIssue = ZodInvalidStringIssue;
type z_ZodInvalidTypeIssue = ZodInvalidTypeIssue;
type z_ZodInvalidUnionDiscriminatorIssue = ZodInvalidUnionDiscriminatorIssue;
type z_ZodInvalidUnionIssue = ZodInvalidUnionIssue;
type z_ZodIssue = ZodIssue;
type z_ZodIssueBase = ZodIssueBase;
type z_ZodIssueCode = ZodIssueCode;
type z_ZodIssueOptionalMessage = ZodIssueOptionalMessage;
type z_ZodLazy<T extends ZodTypeAny = ZodTypeAny> = ZodLazy<T>;
declare const z_ZodLazy: typeof ZodLazy;
type z_ZodLazyDef<T extends ZodTypeAny = ZodTypeAny> = ZodLazyDef<T>;
type z_ZodLiteral<T extends Primitive = Primitive> = ZodLiteral<T>;
declare const z_ZodLiteral: typeof ZodLiteral;
type z_ZodLiteralDef<T extends Primitive = Primitive> = ZodLiteralDef<T>;
type z_ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> = ZodMap<Key, Value>;
declare const z_ZodMap: typeof ZodMap;
type z_ZodMapDef<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> = ZodMapDef<Key, Value>;
type z_ZodNaN = ZodNaN;
declare const z_ZodNaN: typeof ZodNaN;
type z_ZodNaNDef = ZodNaNDef;
type z_ZodNativeEnum<T extends EnumLike = EnumLike> = ZodNativeEnum<T>;
declare const z_ZodNativeEnum: typeof ZodNativeEnum;
type z_ZodNativeEnumDef<T extends EnumLike = EnumLike> = ZodNativeEnumDef<T>;
type z_ZodNever = ZodNever;
declare const z_ZodNever: typeof ZodNever;
type z_ZodNeverDef = ZodNeverDef;
type z_ZodNonEmptyArray<T extends ZodTypeAny> = ZodNonEmptyArray<T>;
type z_ZodNotFiniteIssue = ZodNotFiniteIssue;
type z_ZodNotMultipleOfIssue = ZodNotMultipleOfIssue;
type z_ZodNull = ZodNull;
declare const z_ZodNull: typeof ZodNull;
type z_ZodNullDef = ZodNullDef;
type z_ZodNullable<T extends ZodTypeAny = ZodTypeAny> = ZodNullable<T>;
declare const z_ZodNullable: typeof ZodNullable;
type z_ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> = ZodNullableDef<T>;
type z_ZodNullableType<T extends ZodTypeAny> = ZodNullableType<T>;
type z_ZodNumber = ZodNumber;
declare const z_ZodNumber: typeof ZodNumber;
type z_ZodNumberCheck = ZodNumberCheck;
type z_ZodNumberDef = ZodNumberDef;
type z_ZodObject<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Output = objectOutputType<T, UnknownKeys>, Input = objectInputType<T, UnknownKeys>> = ZodObject<T, UnknownKeys, Output, Input>;
declare const z_ZodObject: typeof ZodObject;
type z_ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = ZodObjectDef<T, UnknownKeys>;
type z_ZodOptional<T extends ZodTypeAny = ZodTypeAny> = ZodOptional<T>;
declare const z_ZodOptional: typeof ZodOptional;
type z_ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> = ZodOptionalDef<T>;
type z_ZodOptionalType<T extends ZodTypeAny> = ZodOptionalType<T>;
type z_ZodParsedType = ZodParsedType;
type z_ZodPipeline<A extends ZodTypeAny = ZodTypeAny, B extends ZodTypeAny = ZodTypeAny> = ZodPipeline<A, B>;
declare const z_ZodPipeline: typeof ZodPipeline;
type z_ZodPipelineDef<A extends ZodTypeAny = ZodTypeAny, B extends ZodTypeAny = ZodTypeAny> = ZodPipelineDef<A, B>;
type z_ZodPromise<T extends ZodTypeAny = ZodTypeAny> = ZodPromise<T>;
declare const z_ZodPromise: typeof ZodPromise;
type z_ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> = ZodPromiseDef<T>;
type z_ZodRawShape = ZodRawShape;
type z_ZodReadonly<T extends ZodTypeAny = ZodTypeAny> = ZodReadonly<T>;
declare const z_ZodReadonly: typeof ZodReadonly;
type z_ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> = ZodReadonlyDef<T>;
type z_ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> = ZodRecord<Key, Value>;
declare const z_ZodRecord: typeof ZodRecord;
type z_ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> = ZodRecordDef<Key, Value>;
type z_ZodRef = ZodRef;
declare const z_ZodRef: typeof ZodRef;
type z_ZodRefDef = ZodRefDef;
type z_ZodSet<Value extends ZodTypeAny = ZodTypeAny> = ZodSet<Value>;
declare const z_ZodSet: typeof ZodSet;
type z_ZodSetDef<Value extends ZodTypeAny = ZodTypeAny> = ZodSetDef<Value>;
type z_ZodString = ZodString;
declare const z_ZodString: typeof ZodString;
type z_ZodStringCheck = ZodStringCheck;
type z_ZodStringDef = ZodStringDef;
type z_ZodSymbol = ZodSymbol;
declare const z_ZodSymbol: typeof ZodSymbol;
type z_ZodSymbolDef = ZodSymbolDef;
type z_ZodTooBigIssue = ZodTooBigIssue;
type z_ZodTooSmallIssue = ZodTooSmallIssue;
type z_ZodTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]], Rest extends ZodTypeAny | null = null> = ZodTuple<T, Rest>;
declare const z_ZodTuple: typeof ZodTuple;
type z_ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> = ZodTupleDef<T, Rest>;
type z_ZodTupleItems = ZodTupleItems;
type z_ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> = ZodType<Output, Def, Input>;
declare const z_ZodType: typeof ZodType;
type z_ZodTypeAny = ZodTypeAny;
type z_ZodTypeDef = ZodTypeDef;
type z_ZodUndefined = ZodUndefined;
declare const z_ZodUndefined: typeof ZodUndefined;
type z_ZodUndefinedDef = ZodUndefinedDef;
type z_ZodUnion<T extends ZodUnionOptions = DefaultZodUnionOptions> = ZodUnion<T>;
declare const z_ZodUnion: typeof ZodUnion;
type z_ZodUnionDef<T extends ZodUnionOptions = DefaultZodUnionOptions> = ZodUnionDef<T>;
type z_ZodUnionOptions = ZodUnionOptions;
type z_ZodUnknown = ZodUnknown;
declare const z_ZodUnknown: typeof ZodUnknown;
type z_ZodUnknownDef = ZodUnknownDef;
type z_ZodUnrecognizedKeysIssue = ZodUnrecognizedKeysIssue;
type z_ZodUnresolvedReferenceIssue = ZodUnresolvedReferenceIssue;
type z_ZodVoid = ZodVoid;
declare const z_ZodVoid: typeof ZodVoid;
type z_ZodVoidDef = ZodVoidDef;
declare const z_addIssueToContext: typeof addIssueToContext;
declare const z_agent: typeof agent;
declare const z_aimodel: typeof aimodel;
type z_arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = 'many'> = arrayOutputType<T, Cardinality>;
type z_baseObjectInputType<Shape extends ZodRawShape> = baseObjectInputType<Shape>;
type z_baseObjectOutputType<Shape extends ZodRawShape> = baseObjectOutputType<Shape>;
declare const z_coerce: typeof coerce;
declare const z_conversation: typeof conversation;
declare const z_createZodEnum: typeof createZodEnum;
declare const z_cuid2Regex: typeof cuid2Regex;
declare const z_cuidRegex: typeof cuidRegex;
declare const z_custom: typeof custom;
declare const z_datasource: typeof datasource;
type z_deoptional<T extends ZodTypeAny> = deoptional<T>;
declare const z_emailRegex: typeof emailRegex;
declare const z_enumUtil: typeof enumUtil;
declare const z_errorUtil: typeof errorUtil;
declare const z_event: typeof event;
declare const z_getErrorMap: typeof getErrorMap;
declare const z_getParsedType: typeof getParsedType;
type z_inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = inferFlattenedErrors<T, U>;
type z_inferFormattedError<T extends ZodType<any, any, any>, U = string> = inferFormattedError<T, U>;
type z_input<T extends __ZodType> = input<T>;
declare const z_intent: typeof intent;
declare const z_ipv4Regex: typeof ipv4Regex;
declare const z_ipv6Regex: typeof ipv6Regex;
declare const z_isAborted: typeof isAborted;
declare const z_isAsync: typeof isAsync;
declare const z_isDirty: typeof isDirty;
declare const z_isEmojiRegex: typeof isEmojiRegex;
declare const z_isValid: typeof isValid;
declare const z_knowledgebase: typeof knowledgebase;
declare const z_late: typeof late;
declare const z_makeIssue: typeof makeIssue;
type z_mergeTypes<A, B> = mergeTypes<A, B>;
declare const z_message: typeof message;
type z_noUnrecognized<Obj extends object, Shape extends object> = noUnrecognized<Obj, Shape>;
type z_objectInputType<Shape extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectInputType<Shape, UnknownKeys>;
type z_objectOutputType<Shape extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectOutputType<Shape, UnknownKeys>;
declare const z_objectUtil: typeof objectUtil;
declare const z_oboolean: typeof oboolean;
declare const z_onumber: typeof onumber;
declare const z_ostring: typeof ostring;
type z_output<T extends __ZodType> = output<T>;
declare const z_partialUtil: typeof partialUtil;
declare const z_processCreateParams: typeof processCreateParams;
declare const z_quotelessJson: typeof quotelessJson;
declare const z_setErrorMap: typeof setErrorMap;
declare const z_table: typeof table;
declare const z_tablerow: typeof tablerow;
type z_typeToFlattenedError<T, U = string> = typeToFlattenedError<T, U>;
type z_typecast<A, T> = typecast<A, T>;
declare const z_ulidRegex: typeof ulidRegex;
declare const z_user: typeof user;
declare const z_util: typeof util;
declare const z_uuidRegex: typeof uuidRegex;
declare const z_variable: typeof variable;
declare namespace z {
  export { type z_AdditionalProperties as AdditionalProperties, type z_AnyZodObject as AnyZodObject, type z_AnyZodTuple as AnyZodTuple, type z_ArrayCardinality as ArrayCardinality, type z_ArrayKeys as ArrayKeys, type z_AssertArray as AssertArray, type z_AsyncParseReturnType as AsyncParseReturnType, type z_BRAND as BRAND, type z_CatchFn as CatchFn, type z_CustomErrorParams as CustomErrorParams, type z_CustomParams as CustomParams, z_DIRTY as DIRTY, type z_DenormalizedError as DenormalizedError, z_EMPTY_PATH as EMPTY_PATH, type z_Effect as Effect, type z_EnumLike as EnumLike, type z_EnumValues as EnumValues, type z_ErrorMapCtx as ErrorMapCtx, type z_FilterEnum as FilterEnum, z_INVALID as INVALID, type z_Indices as Indices, type z_InnerTypeOfFunction as InnerTypeOfFunction, type z_InputTypeOfTuple as InputTypeOfTuple, type z_InputTypeOfTupleWithRest as InputTypeOfTupleWithRest, type z_IpVersion as IpVersion, type z_IssueData as IssueData, type z_KeySchema as KeySchema, type z_KindToDef as KindToDef, type z_Maskable as Maskable, z_NEVER as NEVER, z_OK as OK, type z_ObjectPair as ObjectPair, type z_OfType as OfType, type z_OuterTypeOfFunction as OuterTypeOfFunction, type z_OutputTypeOfTuple as OutputTypeOfTuple, type z_OutputTypeOfTupleWithRest as OutputTypeOfTupleWithRest, type z_ParseContext as ParseContext, type z_ParseInput as ParseInput, z_ParseInputLazyPath as ParseInputLazyPath, type z_ParseParams as ParseParams, type z_ParsePath as ParsePath, type z_ParsePathComponent as ParsePathComponent, type z_ParseResult as ParseResult, type z_ParseReturnType as ParseReturnType, z_ParseStatus as ParseStatus, type z_PreprocessEffect as PreprocessEffect, type z_Primitive as Primitive, type z_ProcessedCreateParams as ProcessedCreateParams, type z_RawCreateParams as RawCreateParams, type z_RecordType as RecordType, type z_Refinement as Refinement, type z_RefinementCtx as RefinementCtx, type z_RefinementEffect as RefinementEffect, type z_SafeParseError as SafeParseError, type z_SafeParseReturnType as SafeParseReturnType, type z_SafeParseSuccess as SafeParseSuccess, type z_Scalars as Scalars, ZodType as Schema, type z_SomeZodObject as SomeZodObject, type z_StringValidation as StringValidation, type z_SuperRefinement as SuperRefinement, type z_SyncParseReturnType as SyncParseReturnType, type z_TransformEffect as TransformEffect, type z_TypeOf as TypeOf, type z_UnknownKeysInputType as UnknownKeysInputType, type z_UnknownKeysOutputType as UnknownKeysOutputType, type z_UnknownKeysParam as UnknownKeysParam, type z_Values as Values, type z_Writeable as Writeable, z_ZodAny as ZodAny, type z_ZodAnyDef as ZodAnyDef, z_ZodArray as ZodArray, type z_ZodArrayDef as ZodArrayDef, z_ZodBigInt as ZodBigInt, type z_ZodBigIntCheck as ZodBigIntCheck, type z_ZodBigIntDef as ZodBigIntDef, z_ZodBoolean as ZodBoolean, type z_ZodBooleanDef as ZodBooleanDef, z_ZodBranded as ZodBranded, type z_ZodBrandedDef as ZodBrandedDef, z_ZodCatch as ZodCatch, type z_ZodCatchDef as ZodCatchDef, type z_ZodCustomIssue as ZodCustomIssue, z_ZodDate as ZodDate, type z_ZodDateCheck as ZodDateCheck, type z_ZodDateDef as ZodDateDef, type z_ZodDef as ZodDef, z_ZodDefault as ZodDefault, type z_ZodDefaultDef as ZodDefaultDef, z_ZodDiscriminatedUnion as ZodDiscriminatedUnion, type z_ZodDiscriminatedUnionDef as ZodDiscriminatedUnionDef, type z_ZodDiscriminatedUnionOption as ZodDiscriminatedUnionOption, z_ZodEffects as ZodEffects, type z_ZodEffectsDef as ZodEffectsDef, z_ZodEnum as ZodEnum, type z_ZodEnumDef as ZodEnumDef, z_ZodError as ZodError, type z_ZodErrorMap as ZodErrorMap, type z_ZodFirstPartySchemaTypes as ZodFirstPartySchemaTypes, z_ZodFirstPartyTypeKind as ZodFirstPartyTypeKind, type z_ZodFormattedError as ZodFormattedError, z_ZodFunction as ZodFunction, type z_ZodFunctionDef as ZodFunctionDef, z_ZodIntersection as ZodIntersection, type z_ZodIntersectionDef as ZodIntersectionDef, type z_ZodInvalidArgumentsIssue as ZodInvalidArgumentsIssue, type z_ZodInvalidDateIssue as ZodInvalidDateIssue, type z_ZodInvalidEnumValueIssue as ZodInvalidEnumValueIssue, type z_ZodInvalidIntersectionTypesIssue as ZodInvalidIntersectionTypesIssue, type z_ZodInvalidLiteralIssue as ZodInvalidLiteralIssue, type z_ZodInvalidReturnTypeIssue as ZodInvalidReturnTypeIssue, type z_ZodInvalidStringIssue as ZodInvalidStringIssue, type z_ZodInvalidTypeIssue as ZodInvalidTypeIssue, type z_ZodInvalidUnionDiscriminatorIssue as ZodInvalidUnionDiscriminatorIssue, type z_ZodInvalidUnionIssue as ZodInvalidUnionIssue, type z_ZodIssue as ZodIssue, type z_ZodIssueBase as ZodIssueBase, type z_ZodIssueCode as ZodIssueCode, type z_ZodIssueOptionalMessage as ZodIssueOptionalMessage, z_ZodLazy as ZodLazy, type z_ZodLazyDef as ZodLazyDef, z_ZodLiteral as ZodLiteral, type z_ZodLiteralDef as ZodLiteralDef, z_ZodMap as ZodMap, type z_ZodMapDef as ZodMapDef, z_ZodNaN as ZodNaN, type z_ZodNaNDef as ZodNaNDef, z_ZodNativeEnum as ZodNativeEnum, type z_ZodNativeEnumDef as ZodNativeEnumDef, z_ZodNever as ZodNever, type z_ZodNeverDef as ZodNeverDef, type z_ZodNonEmptyArray as ZodNonEmptyArray, type z_ZodNotFiniteIssue as ZodNotFiniteIssue, type z_ZodNotMultipleOfIssue as ZodNotMultipleOfIssue, z_ZodNull as ZodNull, type z_ZodNullDef as ZodNullDef, z_ZodNullable as ZodNullable, type z_ZodNullableDef as ZodNullableDef, type z_ZodNullableType as ZodNullableType, z_ZodNumber as ZodNumber, type z_ZodNumberCheck as ZodNumberCheck, type z_ZodNumberDef as ZodNumberDef, z_ZodObject as ZodObject, type z_ZodObjectDef as ZodObjectDef, z_ZodOptional as ZodOptional, type z_ZodOptionalDef as ZodOptionalDef, type z_ZodOptionalType as ZodOptionalType, type z_ZodParsedType as ZodParsedType, z_ZodPipeline as ZodPipeline, type z_ZodPipelineDef as ZodPipelineDef, z_ZodPromise as ZodPromise, type z_ZodPromiseDef as ZodPromiseDef, type z_ZodRawShape as ZodRawShape, z_ZodReadonly as ZodReadonly, type z_ZodReadonlyDef as ZodReadonlyDef, z_ZodRecord as ZodRecord, type z_ZodRecordDef as ZodRecordDef, z_ZodRef as ZodRef, type z_ZodRefDef as ZodRefDef, ZodType as ZodSchema, z_ZodSet as ZodSet, type z_ZodSetDef as ZodSetDef, z_ZodString as ZodString, type z_ZodStringCheck as ZodStringCheck, type z_ZodStringDef as ZodStringDef, z_ZodSymbol as ZodSymbol, type z_ZodSymbolDef as ZodSymbolDef, type z_ZodTooBigIssue as ZodTooBigIssue, type z_ZodTooSmallIssue as ZodTooSmallIssue, ZodEffects as ZodTransformer, z_ZodTuple as ZodTuple, type z_ZodTupleDef as ZodTupleDef, type z_ZodTupleItems as ZodTupleItems, z_ZodType as ZodType, type z_ZodTypeAny as ZodTypeAny, type z_ZodTypeDef as ZodTypeDef, z_ZodUndefined as ZodUndefined, type z_ZodUndefinedDef as ZodUndefinedDef, z_ZodUnion as ZodUnion, type z_ZodUnionDef as ZodUnionDef, type z_ZodUnionOptions as ZodUnionOptions, z_ZodUnknown as ZodUnknown, type z_ZodUnknownDef as ZodUnknownDef, type z_ZodUnrecognizedKeysIssue as ZodUnrecognizedKeysIssue, type z_ZodUnresolvedReferenceIssue as ZodUnresolvedReferenceIssue, z_ZodVoid as ZodVoid, type z_ZodVoidDef as ZodVoidDef, z_addIssueToContext as addIssueToContext, z_agent as agent, z_aimodel as aimodel, anyType as any, arrayType as array, type z_arrayOutputType as arrayOutputType, type z_baseObjectInputType as baseObjectInputType, type z_baseObjectOutputType as baseObjectOutputType, bigIntType as bigint, booleanType as boolean, z_coerce as coerce, z_conversation as conversation, z_createZodEnum as createZodEnum, z_cuid2Regex as cuid2Regex, z_cuidRegex as cuidRegex, z_custom as custom, z_datasource as datasource, dateType as date, defaultType as default, type z_deoptional as deoptional, discriminatedUnionType as discriminatedUnion, effectsType as effect, z_emailRegex as emailRegex, enumType as enum, z_enumUtil as enumUtil, z_errorUtil as errorUtil, z_event as event, functionType as function, z_getErrorMap as getErrorMap, z_getParsedType as getParsedType, type TypeOf as infer, type z_inferFlattenedErrors as inferFlattenedErrors, type z_inferFormattedError as inferFormattedError, type z_input as input, instanceOfType as instanceof, z_intent as intent, intersectionType as intersection, z_ipv4Regex as ipv4Regex, z_ipv6Regex as ipv6Regex, z_isAborted as isAborted, z_isAsync as isAsync, z_isDirty as isDirty, z_isEmojiRegex as isEmojiRegex, z_isValid as isValid, z_knowledgebase as knowledgebase, z_late as late, lazyType as lazy, literalType as literal, z_makeIssue as makeIssue, mapType as map, type z_mergeTypes as mergeTypes, z_message as message, nanType as nan, nativeEnumType as nativeEnum, neverType as never, type z_noUnrecognized as noUnrecognized, nullType as null, nullableType as nullable, numberType as number, objectType as object, type z_objectInputType as objectInputType, type z_objectOutputType as objectOutputType, z_objectUtil as objectUtil, z_oboolean as oboolean, z_onumber as onumber, optionalType as optional, z_ostring as ostring, type z_output as output, z_partialUtil as partialUtil, pipelineType as pipeline, preprocessType as preprocess, z_processCreateParams as processCreateParams, promiseType as promise, z_quotelessJson as quotelessJson, readonlyType as readonly, recordType as record, refType as ref, setType as set, z_setErrorMap as setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, z_table as table, z_tablerow as tablerow, effectsType as transformer, tupleType as tuple, type z_typeToFlattenedError as typeToFlattenedError, type z_typecast as typecast, z_ulidRegex as ulidRegex, undefinedType as undefined, unionType as union, unknownType as unknown, z_user as user, z_util as util, z_uuidRegex as uuidRegex, z_variable as variable, voidType as void };
}

type ZuiMetadata = string | number | boolean | null | undefined | ZuiMetadata[] | {
    [key: string]: ZuiMetadata;
};
type SerializedFunction = string;
type ZuiExtensionObject = {
    tooltip?: boolean;
    displayAs?: [string, any];
    title?: string;
    disabled?: boolean | SerializedFunction;
    hidden?: boolean | SerializedFunction;
    placeholder?: string;
    secret?: boolean;
    coerce?: boolean;
    [key: string]: ZuiMetadata;
};
type BaseType = 'number' | 'string' | 'boolean' | 'object' | 'array' | 'discriminatedUnion';
type UIComponentDefinitions = {
    [T in BaseType]: {
        [K: string]: {
            id: string;
            params: ZodObject<any>;
        };
    };
};
type ZodKindToBaseType<T extends ZodTypeDef> = T extends infer U ? U extends {
    typeName: ZodFirstPartyTypeKind.ZodString;
} ? 'string' : U extends {
    typeName: ZodFirstPartyTypeKind.ZodNumber;
} ? 'number' : U extends {
    typeName: ZodFirstPartyTypeKind.ZodBoolean;
} ? 'boolean' : U extends {
    typeName: ZodFirstPartyTypeKind.ZodArray;
} ? 'array' : U extends {
    typeName: ZodFirstPartyTypeKind.ZodObject;
} ? 'object' : U extends {
    typeName: ZodFirstPartyTypeKind.ZodTuple;
} ? never : U extends ZodEnumDef ? 'string' : U extends {
    typeName: ZodFirstPartyTypeKind.ZodDefault;
    innerType: ZodTypeAny;
} ? ZodKindToBaseType<U['innerType']['_def']> : U extends {
    typeName: ZodFirstPartyTypeKind.ZodOptional;
    innerType: ZodTypeAny;
} ? ZodKindToBaseType<U['innerType']['_def']> : U extends {
    typeName: ZodFirstPartyTypeKind.ZodNullable;
    innerType: ZodTypeAny;
} ? ZodKindToBaseType<U['innerType']['_def']> : U extends {
    typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
    options: ZodDiscriminatedUnionOption<any>[];
} ? 'discriminatedUnion' : never : never;
type ParseSchema<I> = I extends infer U ? U extends {
    id: string;
    params: AnyZodObject;
} ? {
    id: U['id'];
    params: TypeOf<U['params']>;
} : object : never;

declare const zuiKey: "x-zui";

type CatchFn<Y> = (ctx: {
    error: ZodError;
    input: unknown;
}) => Y;
interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    catchValue: CatchFn<T['_output']>;
    typeName: ZodFirstPartyTypeKind.ZodCatch;
}
declare class ZodCatch<T extends ZodTypeAny = ZodTypeAny> extends ZodType<T['_output'], ZodCatchDef<T>, unknown> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    removeCatch(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params: RawCreateParams & {
        catch: T_1["_output"] | CatchFn<T_1["_output"]>;
    }) => ZodCatch<T_1>;
    isEqual(schema: ZodType): boolean;
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodCatch<T>;
    naked(): ZodTypeAny;
    mandatory(): ZodCatch<ZodTypeAny>;
}

type DeclarationProps = {
    type: 'variable';
    schema: z.Schema;
    identifier: string;
} | {
    type: 'type';
    schema: z.Schema;
    identifier: string;
    args: string[];
} | {
    type: 'none';
    schema: z.Schema;
};
type TypescriptDeclarationType = DeclarationProps['type'];
type TypescriptGenerationOptions = {
    formatter?: (typing: string) => string;
    declaration?: boolean | TypescriptDeclarationType;
    /**
     * Whether to include closing tags in the generated TypeScript declarations when they exceed 5 lines.
     * This improves readability for large type declarations by adding comments like "// end of TypeName".
     */
    includeClosingTags?: boolean;
};
/**
 *
 * @param schema zui schema
 * @param options generation options
 * @returns a string of the TypeScript **type** representing the schema
 */
declare function toTypescriptType(schema: z.Schema, options?: TypescriptGenerationOptions): string;

/**
 * This type is not part of the original Zod library, it's been added in Zui to:
 * - Brand the type as a ZuiType and avoid conflicts with 'zod' types
 * - Simplify the type checks and inference for `infer`, `input`, and `output`
 *
 * The original `infer` type inference on ZodType takes a lot of compute because the TS compiler has to check all the methods and properties of the class.
 * The fact that we add __type__ here allows the TS compiler to shortcircuit the type inference when it's not present and prevents infinite circular inferences
 */
type __ZodType<Output = any, Input = Output> = {
    readonly __type__: 'ZuiType';
    readonly _output: Output;
    readonly _input: Input;
};
type RefinementCtx = {
    addIssue: (arg: IssueData) => void;
    path: (string | number)[];
};
type ZodRawShape = {
    [k: string]: ZodTypeAny;
};
type ZodTypeAny = ZodType<any, any, any>;
type TypeOf<T extends __ZodType> = T['_output'];
type OfType<O, T extends __ZodType> = T extends __ZodType<O> ? T : never;
type input<T extends __ZodType> = T['_input'];
type output<T extends __ZodType> = T['_output'];

type Maskable<T = any> = boolean | ((shape: T | null) => util.DeepPartialBoolean<T> | boolean);
type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, 'code'>>;
interface ZodTypeDef {
    typeName: ZodFirstPartyTypeKind;
    errorMap?: ZodErrorMap;
    description?: string;
    [zuiKey]?: ZuiExtensionObject;
}
declare class ParseInputLazyPath implements ParseInput {
    parent: ParseContext;
    data: any;
    _path: ParsePath;
    _key: string | number | (string | number)[];
    _cachedPath: ParsePath;
    constructor(parent: ParseContext, value: any, path: ParsePath, key: string | number | (string | number)[]);
    get path(): ParsePath;
}
type RawCreateParams = {
    errorMap?: ZodErrorMap;
    invalid_type_error?: string;
    required_error?: string;
    description?: string;
    [zuiKey]?: ZuiExtensionObject;
} | undefined;
type ProcessedCreateParams = {
    errorMap?: ZodErrorMap;
    description?: string;
    [zuiKey]?: ZuiExtensionObject;
};
type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
    error?: never;
};
type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
    data?: never;
};
type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
declare abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> implements __ZodType<Output, Input> {
    readonly __type__ = "ZuiType";
    readonly _type: Output;
    readonly _output: Output;
    readonly _input: Input;
    readonly _def: Def;
    get description(): string | undefined;
    abstract _parse(input: ParseInput): ParseReturnType<Output>;
    /** deeply replace all references in the schema */
    dereference(_defs: Record<string, ZodTypeAny>): ZodTypeAny;
    /** deeply scans the schema to check if it contains references */
    getReferences(): string[];
    clone(): ZodType<Output, Def, Input>;
    /** checks if a schema is equal to another */
    abstract isEqual(schema: ZodType): boolean;
    _getType(input: ParseInput): string;
    _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;
    _processInputParams(input: ParseInput): {
        status: ParseStatus;
        ctx: ParseContext;
    };
    _parseSync(input: ParseInput): SyncParseReturnType<Output>;
    _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;
    parse(data: unknown, params?: Partial<ParseParams>): Output;
    safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;
    parseAsync(data: unknown, params?: Partial<ParseParams>): Promise<Output>;
    safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
    /** Alias of safeParseAsync */
    spa: (data: unknown, params?: Partial<ParseParams>) => Promise<SafeParseReturnType<Input, Output>>;
    refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;
    refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;
    refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;
    refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;
    _refinement(refinement: RefinementEffect<Output>['refinement']): ZodEffects<this, Output, Input>;
    superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>): ZodEffects<this, Output, Input>;
    constructor(def: Def);
    optional(): ZodOptional<this>;
    nullable(): ZodNullable<this>;
    nullish(): ZodOptional<ZodNullable<this>>;
    array(): ZodArray<this>;
    promise(): ZodPromise<this>;
    /**
     * # \#\#\# Experimental \#\#\#
     *
     * @experimental This function is experimental and is subject to breaking changes in the future.
     *
     * Would have been named `required` but a method with that name already exists in ZodObject.
     * Makes the schema required; i.e. not optional or undefined. If the schema is already required than it returns itself.
     * Null is not considered optional and remains unchanged.
     *
     * @example z.string().optional().mandatory() // z.string()
     * @example z.string().nullable().mandatory() // z.string().nullable()
     * @example z.string().or(z.undefined()).mandatory() // z.string()
     * @example z.union([z.string(), z.number(), z.undefined()]).mandatory() // z.union([z.string(), z.number()])
     */
    mandatory(): ZodType;
    or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]>;
    and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;
    transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;
    default(def: util.noUndefined<Input>): ZodDefault<this>;
    default(def: () => util.noUndefined<Input>): ZodDefault<this>;
    brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;
    catch(def: Output | CatchFn<Output>): ZodCatch<this>;
    describe(description: string): this;
    pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;
    readonly(): ZodReadonly<this>;
    isOptional(): boolean;
    isNullable(): boolean;
    /** append metadata to the schema */
    metadata(data: Record<string, ZuiMetadata>): this;
    /** get metadata of the schema */
    getMetadata(): Record<string, ZuiMetadata>;
    /** set metadata of the schema */
    setMetadata(data: Record<string, ZuiMetadata>): void;
    /**
     * get metadata of the schema
     * @deprecated use `getMetadata()` instead
     */
    get ui(): Record<string, ZuiMetadata>;
    /**
     * Some Schemas aren't meant to contain metadata, like ZodDefault.
     * In a zui construction like `z.string().default('hello').title('Hello')`, the user's intention is usually to set a title on the string, not on the default value.
     * Also, in JSON-Schema, default is not a data-type like it is in Zui, but an annotation added on the schema itself. Therefore, only one metadata can apply to both the schema and the default value.
     * This property is used to get the root schema that should contain the metadata.
     */
    get _metadataRoot(): ZodType;
    /**
     * The type of component to use to display the field and its options
     */
    displayAs<UI extends UIComponentDefinitions = UIComponentDefinitions, Type extends BaseType = ZodKindToBaseType<this['_def']>>(options: ParseSchema<UI[Type][keyof UI[Type]]>): this;
    /**
     * The title of the field. Defaults to the field name.
     */
    title(title: string): this;
    /**
     * Whether the field is hidden in the UI. Useful for internal fields.
     * @default false
     */
    hidden<T extends any = this['_output']>(value?: boolean | ((shape: T | null) => util.DeepPartialBoolean<T> | boolean)): this;
    /**
     * Whether the field is disabled
     * @default false
     */
    disabled<T extends any = this['_output']>(value?: boolean | ((shape: T | null) => util.DeepPartialBoolean<T> | boolean)): this;
    /**
     * Placeholder text for the field
     */
    placeholder(placeholder: string): this;
    /**
     *
     * @returns a JSON Schema equivalent to the Zui schema
     */
    toJSONSchema(): Schema;
    /**
     *
     * @param options generation options
     * @returns a string of the TypeScript type representing the schema
     */
    toTypescriptType(opts?: TypescriptGenerationOptions): string;
    /**
     *
     * @param options generation options
     * @returns a typescript program (a string) that would construct the given schema if executed
     */
    toTypescriptSchema(): string;
    /**
     * Allows removing all wrappers around the schema
     * @returns either this or the closest children schema that represents the actual data
     */
    naked(): ZodTypeAny;
}

type ZodDef = ZodStringDef | ZodNumberDef | ZodBigIntDef | ZodBooleanDef | ZodDateDef | ZodUndefinedDef | ZodNullDef | ZodDefaultDef | ZodCatchDef | ZodReadonlyDef | ZodDiscriminatedUnionDef | ZodBrandedDef | ZodPipelineDef | ZodAnyDef | ZodUnknownDef | ZodNeverDef | ZodVoidDef | ZodArrayDef | ZodObjectDef | ZodUnionDef | ZodIntersectionDef | ZodTupleDef | ZodRecordDef | ZodMapDef | ZodFunctionDef | ZodLazyDef | ZodLiteralDef | ZodEnumDef | ZodEffectsDef | ZodNativeEnumDef | ZodOptionalDef | ZodNullableDef | ZodPromiseDef | ZodRefDef | ZodSetDef;
declare enum ZodFirstPartyTypeKind {
    ZodString = "ZodString",
    ZodNumber = "ZodNumber",
    ZodNaN = "ZodNaN",
    ZodBigInt = "ZodBigInt",
    ZodBoolean = "ZodBoolean",
    ZodDate = "ZodDate",
    ZodSymbol = "ZodSymbol",
    ZodUndefined = "ZodUndefined",
    ZodNull = "ZodNull",
    ZodAny = "ZodAny",
    ZodUnknown = "ZodUnknown",
    ZodNever = "ZodNever",
    ZodVoid = "ZodVoid",
    ZodArray = "ZodArray",
    ZodObject = "ZodObject",
    ZodUnion = "ZodUnion",
    ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    ZodIntersection = "ZodIntersection",
    ZodTuple = "ZodTuple",
    ZodRecord = "ZodRecord",
    ZodRef = "ZodRef",
    ZodMap = "ZodMap",
    ZodSet = "ZodSet",
    ZodFunction = "ZodFunction",
    ZodLazy = "ZodLazy",
    ZodLiteral = "ZodLiteral",
    ZodEnum = "ZodEnum",
    ZodEffects = "ZodEffects",
    ZodNativeEnum = "ZodNativeEnum",
    ZodOptional = "ZodOptional",
    ZodNullable = "ZodNullable",
    ZodDefault = "ZodDefault",
    ZodCatch = "ZodCatch",
    ZodPromise = "ZodPromise",
    ZodBranded = "ZodBranded",
    ZodPipeline = "ZodPipeline",
    ZodReadonly = "ZodReadonly"
}
type KindToDef<T extends ZodFirstPartyTypeKind> = T extends ZodFirstPartyTypeKind.ZodString ? ZodStringDef : T extends ZodFirstPartyTypeKind.ZodNumber ? ZodNumberDef : T extends ZodFirstPartyTypeKind.ZodBigInt ? ZodBigIntDef : T extends ZodFirstPartyTypeKind.ZodBoolean ? ZodBooleanDef : T extends ZodFirstPartyTypeKind.ZodDate ? ZodDateDef : T extends ZodFirstPartyTypeKind.ZodUndefined ? ZodUndefinedDef : T extends ZodFirstPartyTypeKind.ZodNull ? ZodNullDef : T extends ZodFirstPartyTypeKind.ZodAny ? ZodAnyDef : T extends ZodFirstPartyTypeKind.ZodUnknown ? ZodUnknownDef : T extends ZodFirstPartyTypeKind.ZodNever ? ZodNeverDef : T extends ZodFirstPartyTypeKind.ZodVoid ? ZodVoidDef : T extends ZodFirstPartyTypeKind.ZodArray ? ZodArrayDef : T extends ZodFirstPartyTypeKind.ZodObject ? ZodObjectDef : T extends ZodFirstPartyTypeKind.ZodUnion ? ZodUnionDef : T extends ZodFirstPartyTypeKind.ZodIntersection ? ZodIntersectionDef : T extends ZodFirstPartyTypeKind.ZodTuple ? ZodTupleDef : T extends ZodFirstPartyTypeKind.ZodRecord ? ZodRecordDef : T extends ZodFirstPartyTypeKind.ZodMap ? ZodMapDef : T extends ZodFirstPartyTypeKind.ZodFunction ? ZodFunctionDef : T extends ZodFirstPartyTypeKind.ZodLazy ? ZodLazyDef : T extends ZodFirstPartyTypeKind.ZodLiteral ? ZodLiteralDef : T extends ZodFirstPartyTypeKind.ZodEnum ? ZodEnumDef : T extends ZodFirstPartyTypeKind.ZodEffects ? ZodEffectsDef : T extends ZodFirstPartyTypeKind.ZodNativeEnum ? ZodNativeEnumDef : T extends ZodFirstPartyTypeKind.ZodOptional ? ZodOptionalDef : T extends ZodFirstPartyTypeKind.ZodNullable ? ZodNullableDef : T extends ZodFirstPartyTypeKind.ZodPromise ? ZodPromiseDef : T extends ZodFirstPartyTypeKind.ZodDiscriminatedUnion ? ZodDiscriminatedUnionDef<any> : T extends ZodFirstPartyTypeKind.ZodCatch ? ZodCatchDef : T extends ZodFirstPartyTypeKind.ZodDefault ? ZodDefaultDef : T extends ZodFirstPartyTypeKind.ZodBranded ? ZodBrandedDef<any> : T extends ZodFirstPartyTypeKind.ZodPipeline ? ZodPipelineDef<any, any> : T extends ZodFirstPartyTypeKind.ZodReadonly ? ZodReadonlyDef : never;

declare namespace enumUtil {
    type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;
    type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;
    type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
    type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;
    export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
    export {  };
}

declare namespace errorUtil {
    type ErrMessage = string | {
        message?: string;
    };
    const errToObj: (message?: ErrMessage) => {
        message?: string;
    };
    const toString: (message?: ErrMessage) => string | undefined;
}

declare namespace partialUtil {
    type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<ZodRawShape> ? ZodObject<{
        [k in keyof T['shape']]: ZodOptional<DeepPartial<T['shape'][k]>>;
    }, T['_def']['unknownKeys']> : T extends ZodArray<infer Type, infer Card> ? ZodArray<DeepPartial<Type>, Card> : T extends ZodOptional<infer Type> ? ZodOptional<DeepPartial<Type>> : T extends ZodNullable<infer Type> ? ZodNullable<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {
        [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;
    } extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;
}

interface ZodAnyDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodAny;
}
declare class ZodAny extends ZodType<any, ZodAnyDef> {
    _any: true;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: (params?: RawCreateParams) => ZodAny;
    isEqual(schema: ZodType): schema is ZodAny;
}

interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodArray;
    exactLength: {
        value: number;
        message?: string;
    } | null;
    minLength: {
        value: number;
        message?: string;
    } | null;
    maxLength: {
        value: number;
        message?: string;
    } | null;
}
type ArrayCardinality = 'many' | 'atleastone';
type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = 'many'> = Cardinality extends 'atleastone' ? [T['_output'], ...T['_output'][]] : T['_output'][];
declare class ZodArray<T extends ZodTypeAny = ZodTypeAny, Cardinality extends ArrayCardinality = 'many'> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends 'atleastone' ? [T['_input'], ...T['_input'][]] : T['_input'][]> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodArray<T, Cardinality>;
    isEqual(schema: ZodType): boolean;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get element(): T;
    min(minLength: number, message?: errorUtil.ErrMessage): this;
    max(maxLength: number, message?: errorUtil.ErrMessage): this;
    length(len: number, message?: errorUtil.ErrMessage): this;
    nonempty(message?: errorUtil.ErrMessage): ZodArray<T, 'atleastone'>;
    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodArray<T_1>;
}
type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, 'atleastone'>;

type ZodBigIntCheck = {
    kind: 'min';
    value: bigint;
    inclusive: boolean;
    message?: string;
} | {
    kind: 'max';
    value: bigint;
    inclusive: boolean;
    message?: string;
} | {
    kind: 'multipleOf';
    value: bigint;
    message?: string;
};
interface ZodBigIntDef extends ZodTypeDef {
    checks: ZodBigIntCheck[];
    typeName: ZodFirstPartyTypeKind.ZodBigInt;
    coerce: boolean;
}
declare class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
    _parse(input: ParseInput): ParseReturnType<bigint>;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodBigInt;
    isEqual(schema: ZodType): boolean;
    gte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
    min: (value: bigint, message?: errorUtil.ErrMessage) => ZodBigInt;
    gt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
    lte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
    max: (value: bigint, message?: errorUtil.ErrMessage) => ZodBigInt;
    lt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
    protected setLimit(kind: 'min' | 'max', value: bigint, inclusive: boolean, message?: string): ZodBigInt;
    _addCheck(check: ZodBigIntCheck): ZodBigInt;
    positive(message?: errorUtil.ErrMessage): ZodBigInt;
    negative(message?: errorUtil.ErrMessage): ZodBigInt;
    nonpositive(message?: errorUtil.ErrMessage): ZodBigInt;
    nonnegative(message?: errorUtil.ErrMessage): ZodBigInt;
    multipleOf(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;
    get minValue(): bigint | null;
    get maxValue(): bigint | null;
}

interface ZodBooleanDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodBoolean;
    coerce: boolean;
}
declare class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
    _parse(input: ParseInput): ParseReturnType<boolean>;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodBoolean;
    isEqual(schema: ZodType): boolean;
}

type Key = string | number | symbol;
interface ZodBrandedDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodBranded;
}
declare const BRAND: unique symbol;
type BRAND<T extends Key = Key> = {
    [BRAND]: {
        [k in T]: true;
    };
};
declare class ZodBranded<T extends ZodTypeAny = ZodTypeAny, B extends Key = Key> extends ZodType<T['_output'] & BRAND<B>, ZodBrandedDef<T>, T['_input']> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodBranded<T, B>;
    _parse(input: ParseInput): ParseReturnType<any>;
    unwrap(): T;
    isEqual(schema: ZodType): boolean;
    naked(): ZodTypeAny;
    mandatory(): ZodBranded<ZodTypeAny, B>;
}

type CustomParams = CustomErrorParams & {
    fatal?: boolean;
};
declare const custom: <T>(check?: (data: unknown) => any, params?: string | CustomParams | ((input: any) => CustomParams), 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal?: boolean) => ZodType<T>;

type ZodDateCheck = {
    kind: 'min';
    value: number;
    message?: string;
} | {
    kind: 'max';
    value: number;
    message?: string;
};
interface ZodDateDef extends ZodTypeDef {
    checks: ZodDateCheck[];
    coerce: boolean;
    typeName: ZodFirstPartyTypeKind.ZodDate;
}
declare class ZodDate extends ZodType<Date, ZodDateDef> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    _addCheck(check: ZodDateCheck): ZodDate;
    min(minDate: Date, message?: errorUtil.ErrMessage): ZodDate;
    max(maxDate: Date, message?: errorUtil.ErrMessage): ZodDate;
    get minDate(): Date | null;
    get maxDate(): Date | null;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodDate;
    isEqual(schema: ZodType): boolean;
}

interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    defaultValue: () => util.noUndefined<T['_input']>;
    typeName: ZodFirstPartyTypeKind.ZodDefault;
}
declare class ZodDefault<T extends ZodTypeAny = ZodTypeAny> extends ZodType<util.noUndefined<T['_output']>, ZodDefaultDef<T>, T['_input'] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    removeDefault(): T;
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodDefault<T>;
    static create: <T_1 extends ZodTypeAny>(type: T_1, value: T_1["_input"] | (() => util.noUndefined<T_1["_input"]>), params?: RawCreateParams) => ZodDefault<T_1>;
    isEqual(schema: ZodType): boolean;
    unwrap(): T;
    naked(): ZodTypeAny;
    mandatory(): ZodDefault<ZodTypeAny>;
}

type ZodDiscriminatedUnionOption<Discriminator extends string> = ZodObject<{
    [key in Discriminator]: ZodTypeAny;
} & ZodRawShape, UnknownKeysParam>;
interface ZodDiscriminatedUnionDef<Discriminator extends string = string, Options extends ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]> extends ZodTypeDef {
    discriminator: Discriminator;
    options: Options;
    optionsMap: Map<Primitive, ZodDiscriminatedUnionOption<any>>;
    typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
}
declare class ZodDiscriminatedUnion<Discriminator extends string = string, Options extends ZodDiscriminatedUnionOption<Discriminator>[] = ZodDiscriminatedUnionOption<Discriminator>[]> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodDiscriminatedUnion<Discriminator, Options>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get discriminator(): Discriminator;
    get options(): Options;
    get optionsMap(): Map<Primitive, ZodDiscriminatedUnionOption<any>>;
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create<Discriminator extends string, Types extends [ZodDiscriminatedUnionOption<Discriminator>, ...ZodDiscriminatedUnionOption<Discriminator>[]]>(discriminator: Discriminator, options: Types, params?: RawCreateParams): ZodDiscriminatedUnion<Discriminator, Types>;
    private static _getOptionsMap;
    isEqual(schema: ZodType): boolean;
}

type ArrayKeys = keyof any[];
type Indices<T> = Exclude<keyof T, ArrayKeys>;
type EnumValues = [string, ...string[]];
type Values<T extends EnumValues> = {
    [k in T[number]]: k;
};
interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {
    values: T;
    typeName: ZodFirstPartyTypeKind.ZodEnum;
}
type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
type FilterEnum<Values, ToExclude> = Values extends [] ? [] : Values extends [infer Head, ...infer Rest] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [Head, ...FilterEnum<Rest, ToExclude>] : never;
type typecast<A, T> = A extends T ? A : never;
declare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
declare function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;
declare class ZodEnum<T extends [string, ...string[]] = [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get options(): T;
    get enum(): Values<T>;
    get Values(): Values<T>;
    get Enum(): Values<T>;
    extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract, newDef?: RawCreateParams): ZodEnum<Writeable<ToExtract>>;
    exclude<ToExclude extends readonly [T[number], ...T[number][]]>(values: ToExclude, newDef?: RawCreateParams): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>>;
    static create: typeof createZodEnum;
    isEqual(schema: ZodType): boolean;
}

interface ZodFunctionDef<Args extends ZodTuple<any, any> = ZodTuple, Returns extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    args: Args;
    returns: Returns;
    typeName: ZodFirstPartyTypeKind.ZodFunction;
}
type OuterTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args['_input'] extends Array<any> ? (...args: Args['_input']) => Returns['_output'] : never;
type InnerTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args['_output'] extends Array<any> ? (...args: Args['_output']) => Returns['_input'] : never;
declare class ZodFunction<Args extends ZodTuple<any, any> = ZodTuple, Returns extends ZodTypeAny = ZodTypeAny> extends ZodType<OuterTypeOfFunction<Args, Returns>, ZodFunctionDef<Args, Returns>, InnerTypeOfFunction<Args, Returns>> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodFunction<Args, Returns>;
    _parse(input: ParseInput): ParseReturnType<any>;
    parameters(): Args;
    returnType(): Returns;
    args<Items extends Parameters<(typeof ZodTuple)['create']>[0]>(...items: Items): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns>;
    returns<NewReturnType extends ZodType<any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType>;
    implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): ReturnType<F> extends Returns['_output'] ? (...args: Args['_input']) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;
    strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns>;
    validate: <F extends InnerTypeOfFunction<Args, Returns>>(func: F) => ReturnType<F> extends Returns["_output"] ? (...args: Args["_input"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;
    static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;
    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;
    static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;
    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;
    isEqual(schema: ZodType): boolean;
}

interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    left: T;
    right: U;
    typeName: ZodFirstPartyTypeKind.ZodIntersection;
}
declare class ZodIntersection<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodType<T['_output'] & U['_output'], ZodIntersectionDef<T, U>, T['_input'] & U['_input']> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodIntersection<T, U>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: <T_1 extends ZodTypeAny, U_1 extends ZodTypeAny>(left: T_1, right: U_1, params?: RawCreateParams) => ZodIntersection<T_1, U_1>;
    isEqual(schema: ZodType): boolean;
}

interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    getter: () => T;
    typeName: ZodFirstPartyTypeKind.ZodLazy;
}
declare class ZodLazy<T extends ZodTypeAny = ZodTypeAny> extends ZodType<output<T>, ZodLazyDef<T>, input<T>> {
    get schema(): T;
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodLazy<T>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: <T_1 extends ZodTypeAny>(getter: () => T_1, params?: RawCreateParams) => ZodLazy<T_1>;
    isEqual(schema: ZodType): boolean;
    naked(): ZodTypeAny;
    mandatory(): ZodLazy<ZodTypeAny>;
}

interface ZodLiteralDef<T extends Primitive = Primitive> extends ZodTypeDef {
    value: T;
    typeName: ZodFirstPartyTypeKind.ZodLiteral;
}
declare class ZodLiteral<T extends Primitive = Primitive> extends ZodType<T, ZodLiteralDef<T>> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get value(): T;
    static create: <T_1 extends Primitive>(value: T_1, params?: RawCreateParams) => ZodLiteral<T_1>;
    isEqual(schema: ZodType): boolean;
}

interface ZodMapDef<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    valueType: Value;
    keyType: Key;
    typeName: ZodFirstPartyTypeKind.ZodMap;
}
declare class ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Map<Key['_output'], Value['_output']>, ZodMapDef<Key, Value>, Map<Key['_input'], Value['_input']>> {
    get keySchema(): Key;
    get valueSchema(): Value;
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodMap<Key, Value>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: <Key_1 extends ZodTypeAny = ZodTypeAny, Value_1 extends ZodTypeAny = ZodTypeAny>(keyType: Key_1, valueType: Value_1, params?: RawCreateParams) => ZodMap<Key_1, Value_1>;
    isEqual(schema: ZodType): boolean;
}

interface ZodNaNDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodNaN;
}
declare class ZodNaN extends ZodType<number, ZodNaNDef> {
    _parse(input: ParseInput): ParseReturnType<any>;
    static create: (params?: RawCreateParams) => ZodNaN;
    isEqual(schema: ZodType): boolean;
}

interface ZodNativeEnumDef<T extends EnumLike = EnumLike> extends ZodTypeDef {
    values: T;
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
}
type EnumLike = {
    [k: string]: string | number;
    [nu: number]: string;
};
declare class ZodNativeEnum<T extends EnumLike = EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>> {
    _parse(input: ParseInput): ParseReturnType<T[keyof T]>;
    get enum(): T;
    static create: <T_1 extends EnumLike>(values: T_1, params?: RawCreateParams) => ZodNativeEnum<T_1>;
    isEqual(schema: ZodType): boolean;
}

interface ZodNeverDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodNever;
}
declare class ZodNever extends ZodType<never, ZodNeverDef> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: (params?: RawCreateParams) => ZodNever;
    isEqual(schema: ZodType): boolean;
}

interface ZodNullDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodNull;
}
declare class ZodNull extends ZodType<null, ZodNullDef> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: (params?: RawCreateParams) => ZodNull;
    isEqual(schema: ZodType): boolean;
}

interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodNullable;
}
type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;
declare class ZodNullable<T extends ZodTypeAny = ZodTypeAny> extends ZodType<T['_output'] | null, ZodNullableDef<T>, T['_input'] | null> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodNullable<T>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    unwrap(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodNullable<T_1>;
    isEqual(schema: ZodType): boolean;
    naked(): ZodTypeAny;
    mandatory(): ZodNullable<ZodTypeAny>;
}

type ZodNumberCheck = {
    kind: 'min';
    value: number;
    inclusive: boolean;
    message?: string;
} | {
    kind: 'max';
    value: number;
    inclusive: boolean;
    message?: string;
} | {
    kind: 'int';
    message?: string;
} | {
    kind: 'multipleOf';
    value: number;
    message?: string;
} | {
    kind: 'finite';
    message?: string;
};
interface ZodNumberDef extends ZodTypeDef {
    checks: ZodNumberCheck[];
    typeName: ZodFirstPartyTypeKind.ZodNumber;
    coerce: boolean;
}
declare class ZodNumber extends ZodType<number, ZodNumberDef> {
    _parse(input: ParseInput): ParseReturnType<number>;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodNumber;
    gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    min: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    max: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    protected setLimit(kind: 'min' | 'max', value: number, inclusive: boolean, message?: string): ZodNumber;
    _addCheck(check: ZodNumberCheck): ZodNumber;
    int(message?: errorUtil.ErrMessage): ZodNumber;
    positive(message?: errorUtil.ErrMessage): ZodNumber;
    negative(message?: errorUtil.ErrMessage): ZodNumber;
    nonpositive(message?: errorUtil.ErrMessage): ZodNumber;
    nonnegative(message?: errorUtil.ErrMessage): ZodNumber;
    multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    step: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    finite(message?: errorUtil.ErrMessage): ZodNumber;
    safe(message?: errorUtil.ErrMessage): ZodNumber;
    get minValue(): number | null;
    get maxValue(): number | null;
    get isInt(): boolean;
    get isFinite(): boolean;
    isEqual(schema: ZodType): boolean;
}

type UnknownKeysParam = 'passthrough' | 'strict' | 'strip' | ZodTypeAny;
interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodObject;
    shape: () => T;
    unknownKeys: UnknownKeys;
}
type mergeTypes<A, B> = {
    [k in keyof A | keyof B]: k extends keyof B ? B[k] : k extends keyof A ? A[k] : never;
};
type objectOutputType<Shape extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = UnknownKeysOutputType<UnknownKeys> & objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>>;
type baseObjectOutputType<Shape extends ZodRawShape> = {
    [k in keyof Shape]: Shape[k]['_output'];
};
type objectInputType<Shape extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<baseObjectInputType<Shape>> & UnknownKeysInputType<UnknownKeys>;
type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]['_input'];
}>;
type UnknownKeysInputType<T extends UnknownKeysParam> = T extends ZodTypeAny ? {
    [k: string]: T['_input'] | unknown;
} : T extends 'passthrough' ? {
    [k: string]: unknown;
} : {};
type UnknownKeysOutputType<T extends UnknownKeysParam> = T extends ZodTypeAny ? {
    [k: string]: T['_output'] | unknown;
} : T extends 'passthrough' ? {
    [k: string]: unknown;
} : {};
type AdditionalProperties<T extends UnknownKeysParam> = T extends ZodTypeAny ? T : T extends 'passthrough' ? ZodAny : T extends 'strict' ? ZodNever : undefined;
type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;
type SomeZodObject = ZodObject<ZodRawShape, UnknownKeysParam>;
type noUnrecognized<Obj extends object, Shape extends object> = {
    [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
};
declare class ZodObject<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Output = objectOutputType<T, UnknownKeys>, Input = objectInputType<T, UnknownKeys>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys>, Input> {
    private _cached;
    _getCached(): {
        shape: T;
        keys: string[];
    };
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodObject<T, UnknownKeys, Output, Input>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get shape(): T;
    strict(message?: errorUtil.ErrMessage): ZodObject<T, 'strict'>;
    strip(): ZodObject<T, 'strip'>;
    passthrough(): ZodObject<T, 'passthrough'>;
    /**
     * @returns The ZodType that is used to validate additional properties or undefined if extra keys are stripped.
     */
    additionalProperties(): AdditionalProperties<UnknownKeys>;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    nonstrict: () => ZodObject<T, "passthrough">;
    extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys>;
    /**
     * @deprecated Use `.extend` instead
     *  */
    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys>;
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge<Incoming extends AnyZodObject, Augmentation extends Incoming['shape']>(merging: Incoming): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming['_def']['unknownKeys']>;
    setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {
        [k in Key]: Schema;
    }, UnknownKeys>;
    catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, Index>;
    pick<Mask extends {
        [k in keyof T]?: true;
    }>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys>;
    omit<Mask extends {
        [k in keyof T]?: true;
    }>(mask: Mask): ZodObject<Omit<T, keyof Mask>, UnknownKeys>;
    /**
     * @deprecated
     */
    deepPartial(): partialUtil.DeepPartial<this>;
    partial(): ZodObject<{
        [k in keyof T]: ZodOptional<T[k]>;
    }, UnknownKeys>;
    partial<Mask extends {
        [k in keyof T]?: true;
    }>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>, UnknownKeys>;
    required(): ZodObject<{
        [k in keyof T]: deoptional<T[k]>;
    }, UnknownKeys>;
    required<Mask extends {
        [k in keyof T]?: true;
    }>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
    }>, UnknownKeys>;
    keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;
    isEqual(schema: ZodType): boolean;
    private _unknownKeysEqual;
    static create: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strip">;
    static strictCreate: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strict">;
    static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1, params?: RawCreateParams) => ZodObject<T_1, "strip">;
}
type AnyZodObject = ZodObject<any, any>;

interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodOptional;
}
type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;
declare class ZodOptional<T extends ZodTypeAny = ZodTypeAny> extends ZodType<T['_output'] | undefined, ZodOptionalDef<T>, T['_input'] | undefined> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodOptional<T>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    unwrap(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodOptional<T_1>;
    isEqual(schema: ZodType): boolean;
    naked(): ZodTypeAny;
    mandatory(): ZodTypeAny;
}

interface ZodPipelineDef<A extends ZodTypeAny = ZodTypeAny, B extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    in: A;
    out: B;
    typeName: ZodFirstPartyTypeKind.ZodPipeline;
}
declare class ZodPipeline<A extends ZodTypeAny = ZodTypeAny, B extends ZodTypeAny = ZodTypeAny> extends ZodType<B['_output'], ZodPipelineDef<A, B>, A['_input']> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodPipeline<A, B>;
    _parse(input: ParseInput): ParseReturnType<any>;
    static create<A extends ZodTypeAny, B extends ZodTypeAny>(a: A, b: B): ZodPipeline<A, B>;
    isEqual(schema: ZodType): boolean;
}

interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodPromise;
}
declare class ZodPromise<T extends ZodTypeAny = ZodTypeAny> extends ZodType<Promise<T['_output']>, ZodPromiseDef<T>, Promise<T['_input']>> {
    unwrap(): T;
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodPromise<T>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodPromise<T_1>;
    isEqual(schema: ZodTypeAny): boolean;
    naked(): ZodTypeAny;
}

type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {
    readonly [Symbol.toStringTag]: string;
} | Date | Error | Generator | Promise<unknown> | RegExp;
type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;
interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodReadonly;
}
declare class ZodReadonly<T extends ZodTypeAny = ZodTypeAny> extends ZodType<MakeReadonly<T['_output']>, ZodReadonlyDef<T>, MakeReadonly<T['_input']>> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodReadonly<T>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodReadonly<T_1>;
    unwrap(): T;
    isEqual(schema: ZodType): boolean;
    naked(): ZodTypeAny;
    mandatory(): ZodReadonly<ZodTypeAny>;
}

interface ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    valueType: Value;
    keyType: Key;
    typeName: ZodFirstPartyTypeKind.ZodRecord;
}
type KeySchema = ZodType<string | number | symbol, any, any>;
type RecordType<K extends string | number | symbol, V> = [string] extends [K] ? Record<K, V> : [number] extends [K] ? Record<K, V> : [symbol] extends [K] ? Record<K, V> : [BRAND<string | number | symbol>] extends [K] ? Record<K, V> : Partial<Record<K, V>>;
declare class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<RecordType<Key['_output'], Value['_output']>, ZodRecordDef<Key, Value>, RecordType<Key['_input'], Value['_input']>> {
    get keySchema(): Key;
    get valueSchema(): Value;
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodRecord<Key, Value>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get element(): Value;
    static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;
    static create<Keys extends KeySchema, Value extends ZodTypeAny>(keySchema: Keys, valueType: Value, params?: RawCreateParams): ZodRecord<Keys, Value>;
    isEqual(schema: ZodType): boolean;
}

interface ZodRefDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodRef;
    uri: string;
}
type ZodRefOutput = NonNullable<unknown>;
declare class ZodRef extends ZodType<ZodRefOutput, ZodRefDef> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    _parse(input: ParseInput): ParseReturnType<never>;
    static create: (uri: string) => ZodRef;
    isOptional(): boolean;
    isNullable(): boolean;
    isEqual(schema: ZodType): boolean;
}

interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    valueType: Value;
    typeName: ZodFirstPartyTypeKind.ZodSet;
    minSize: {
        value: number;
        message?: string;
    } | null;
    maxSize: {
        value: number;
        message?: string;
    } | null;
}
declare class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Set<Value['_output']>, ZodSetDef<Value>, Set<Value['_input']>> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodSet<Value>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    min(minSize: number, message?: errorUtil.ErrMessage): this;
    max(maxSize: number, message?: errorUtil.ErrMessage): this;
    size(size: number, message?: errorUtil.ErrMessage): this;
    nonempty(message?: errorUtil.ErrMessage): ZodSet<Value>;
    static create: <Value_1 extends ZodTypeAny = ZodTypeAny>(valueType: Value_1, params?: RawCreateParams) => ZodSet<Value_1>;
    isEqual(schema: ZodType): boolean;
}

type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void | Promise<void>;
type RefinementEffect<T> = {
    type: 'refinement';
    refinement: (arg: T, ctx: RefinementCtx) => any;
};
type TransformEffect<T> = {
    type: 'transform';
    transform: (arg: T, ctx: RefinementCtx) => any;
};
type PreprocessEffect<T> = {
    type: 'preprocess';
    transform: (arg: T, ctx: RefinementCtx) => any;
};
type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;
interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    schema: T;
    typeName: ZodFirstPartyTypeKind.ZodEffects;
    effect: Effect<any>;
}
declare class ZodEffects<T extends ZodTypeAny = ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {
    innerType(): T;
    /**
     * @deprecated use naked() instead
     */
    sourceType(): T;
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodEffects<T, Output, Input>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: <I extends ZodType>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"]>;
    static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
    isEqual(schema: ZodType): boolean;
    naked(): ZodTypeAny;
    mandatory(): ZodEffects<ZodTypeAny>;
}

type IpVersion = 'v4' | 'v6';
type ZodStringCheck = {
    kind: 'min';
    value: number;
    message?: string;
} | {
    kind: 'max';
    value: number;
    message?: string;
} | {
    kind: 'length';
    value: number;
    message?: string;
} | {
    kind: 'email';
    message?: string;
} | {
    kind: 'url';
    message?: string;
} | {
    kind: 'emoji';
    message?: string;
} | {
    kind: 'uuid';
    message?: string;
} | {
    kind: 'cuid';
    message?: string;
} | {
    kind: 'includes';
    value: string;
    position?: number;
    message?: string;
} | {
    kind: 'cuid2';
    message?: string;
} | {
    kind: 'ulid';
    message?: string;
} | {
    kind: 'startsWith';
    value: string;
    message?: string;
} | {
    kind: 'endsWith';
    value: string;
    message?: string;
} | {
    kind: 'regex';
    regex: RegExp;
    message?: string;
} | {
    kind: 'trim';
    message?: string;
} | {
    kind: 'toLowerCase';
    message?: string;
} | {
    kind: 'toUpperCase';
    message?: string;
} | {
    kind: 'datetime';
    offset: boolean;
    precision: number | null;
    message?: string;
} | {
    kind: 'ip';
    version?: IpVersion;
    message?: string;
};
interface ZodStringDef extends ZodTypeDef {
    checks: ZodStringCheck[];
    typeName: ZodFirstPartyTypeKind.ZodString;
    coerce: boolean;
}
declare const cuidRegex: RegExp;
declare const cuid2Regex: RegExp;
declare const ulidRegex: RegExp;
declare const uuidRegex: RegExp;
declare const emailRegex: RegExp;
declare const isEmojiRegex: (value: any) => boolean;
declare const ipv4Regex: RegExp;
declare const ipv6Regex: RegExp;
declare class ZodString extends ZodType<string, ZodStringDef> {
    _parse(input: ParseInput): ParseReturnType<string>;
    protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage): ZodEffects<this, string, string>;
    _addCheck(check: ZodStringCheck): ZodString;
    email(message?: errorUtil.ErrMessage): ZodString;
    url(message?: errorUtil.ErrMessage): ZodString;
    emoji(message?: errorUtil.ErrMessage): ZodString;
    uuid(message?: errorUtil.ErrMessage): ZodString;
    cuid(message?: errorUtil.ErrMessage): ZodString;
    cuid2(message?: errorUtil.ErrMessage): ZodString;
    ulid(message?: errorUtil.ErrMessage): ZodString;
    ip(options?: string | {
        version?: 'v4' | 'v6';
        message?: string;
    }): ZodString;
    datetime(options?: string | {
        message?: string | undefined;
        precision?: number | null;
        offset?: boolean;
    }): ZodString;
    regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;
    includes(value: string, options?: {
        message?: string;
        position?: number;
    }): ZodString;
    startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    min(minLength: number, message?: errorUtil.ErrMessage): ZodString;
    max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;
    length(len: number, message?: errorUtil.ErrMessage): ZodString;
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message?: errorUtil.ErrMessage): ZodString;
    trim(): ZodString;
    secret(): this;
    toLowerCase(): ZodString;
    toUpperCase(): ZodString;
    get isDatetime(): boolean;
    get isEmail(): boolean;
    get isURL(): boolean;
    get isEmoji(): boolean;
    get isUUID(): boolean;
    get isCUID(): boolean;
    get isCUID2(): boolean;
    get isULID(): boolean;
    get isIP(): boolean;
    get minLength(): number | null;
    get maxLength(): number | null;
    static create: (params?: RawCreateParams & {
        coerce?: true;
    }) => ZodString;
    isEqual(schema: ZodType): boolean;
}

interface ZodSymbolDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodSymbol;
}
declare class ZodSymbol extends ZodType<symbol, ZodSymbolDef, symbol> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: (params?: RawCreateParams) => ZodSymbol;
    isEqual(schema: ZodType): boolean;
}

type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
type AssertArray<T> = T extends any[] ? T : never;
type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]['_output'] : never;
}>;
type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest['_output'][]] : OutputTypeOfTuple<T>;
type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]['_input'] : never;
}>;
type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest['_input'][]] : InputTypeOfTuple<T>;
interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {
    items: T;
    rest: Rest;
    typeName: ZodFirstPartyTypeKind.ZodTuple;
}
type AnyZodTuple = ZodTuple<[ZodTypeAny, ...ZodTypeAny[]] | [], ZodTypeAny | null>;
declare class ZodTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]], Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodTuple<T, Rest>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get items(): T;
    rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest>;
    static create: <T_1 extends [ZodTypeAny, ...ZodTypeAny[]] | []>(schemas: T_1, params?: RawCreateParams) => ZodTuple<T_1, null>;
    isEqual(schema: ZodType): boolean;
    private _restEquals;
}

interface ZodUndefinedDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodUndefined;
}
declare class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    params?: RawCreateParams;
    static create: (params?: RawCreateParams) => ZodUndefined;
    isEqual(schema: ZodType): boolean;
    mandatory(): ZodNever;
}

type DefaultZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>;
type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
interface ZodUnionDef<T extends ZodUnionOptions = DefaultZodUnionOptions> extends ZodTypeDef {
    options: T;
    typeName: ZodFirstPartyTypeKind.ZodUnion;
}
declare class ZodUnion<T extends ZodUnionOptions = DefaultZodUnionOptions> extends ZodType<T[number]['_output'], ZodUnionDef<T>, T[number]['_input']> {
    dereference(defs: Record<string, ZodTypeAny>): ZodTypeAny;
    getReferences(): string[];
    clone(): ZodUnion<T>;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    get options(): T;
    static create: <T_1 extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(types: T_1, params?: RawCreateParams) => ZodUnion<T_1>;
    isEqual(schema: ZodType): boolean;
    mandatory(): ZodType;
}

interface ZodUnknownDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodUnknown;
}
declare class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
    _unknown: true;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: (params?: RawCreateParams) => ZodUnknown;
    isEqual(schema: ZodType): boolean;
}

interface ZodVoidDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodVoid;
}
declare class ZodVoid extends ZodType<void, ZodVoidDef> {
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create: (params?: RawCreateParams) => ZodVoid;
    isEqual(schema: ZodType): boolean;
}

declare namespace util {
    export type IsEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;
    export type isAny<T> = 0 extends 1 & T ? true : false;
    export const assertEqual: <A, B>(val: IsEqual<A, B>) => IsEqual<A, B>;
    export function assertIs<T>(_arg: T): void;
    export function assertNever(_x: never): never;
    export type AssertNever<_T extends never> = true;
    export type AssertTrue<_T extends true> = true;
    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
    export type DeepPartialBoolean<T> = {
        [K in keyof T]?: T[K] extends object ? DeepPartialBoolean<T[K]> | boolean : boolean;
    };
    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };
    export const getValidEnumValues: (obj: any) => any[];
    export const objectValues: (obj: any) => any[];
    export const objectKeys: ObjectConstructor['keys'];
    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;
    export type identity<T> = objectUtil.identity<T>;
    export type flatten<T> = objectUtil.flatten<T>;
    export type noUndefined<T> = T extends undefined ? never : T;
    export const isInteger: NumberConstructor['isInteger'];
    export function joinValues<T extends any[]>(array: T, separator?: string): string;
    export const jsonStringifyReplacer: (_: string, value: any) => any;
    export const compareFunctions: (a: Function, b: Function) => boolean;
    export const mock: <T>() => T;
    export type Satisfies<X extends Y, Y> = X;
    type NormalizeObject<T extends object> = T extends infer O ? {
        [K in keyof O]: Normalize<O[K]>;
    } : never;
    export type Normalize<T> = T extends (...args: infer A) => infer R ? (...args: Normalize<A>) => Normalize<R> : T extends Array<infer E> ? Array<Normalize<E>> : T extends ReadonlyArray<infer E> ? ReadonlyArray<Normalize<E>> : T extends Promise<infer R> ? Promise<Normalize<R>> : T extends Buffer ? Buffer : T extends object ? NormalizeObject<T> : T;
    export {  };
}
declare namespace objectUtil {
    export type MergeShapes<U, V> = {
        [k in Exclude<keyof U, keyof V>]: U[k];
    } & V;
    type optionalKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? k : never;
    }[keyof T];
    type requiredKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? never : k;
    }[keyof T];
    export type addQuestionMarks<T extends object, R extends keyof T = requiredKeys<T>, O extends keyof T = optionalKeys<T>> = Pick<T, R> & Partial<Pick<T, O>> & {
        [k in keyof T]?: unknown;
    };
    export type identity<T> = T;
    export type flatten<T> = identity<{
        [k in keyof T]: T[k];
    }>;
    export type noNeverKeys<T> = {
        [k in keyof T]: [T[k]] extends [never] ? never : k;
    }[keyof T];
    export type noNever<T> = identity<{
        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
    }>;
    export const mergeShapes: <U, T>(first: U, second: T) => T & U;
    export type extendShape<A, B> = flatten<Omit<A, keyof B> & B>;
    export {  };
}
declare const ZodParsedType: {
    string: "string";
    number: "number";
    bigint: "bigint";
    boolean: "boolean";
    symbol: "symbol";
    undefined: "undefined";
    object: "object";
    function: "function";
    map: "map";
    nan: "nan";
    integer: "integer";
    float: "float";
    date: "date";
    null: "null";
    array: "array";
    unknown: "unknown";
    promise: "promise";
    void: "void";
    never: "never";
    set: "set";
};
type ZodParsedType = keyof typeof ZodParsedType;
declare const getParsedType: (data: any) => ZodParsedType;
declare function processCreateParams(params: RawCreateParams & ({
    supportsExtensions?: 'secret'[];
} | undefined)): ProcessedCreateParams;

/**
 * Definitions:
 *
 * Mutiple zui schemas map to the same JSON schema; undefined/never, any/unknown, union/discriminated-union
 * Adding some ZodDef to the ZuiExtension allows us to differentiate between them
 */
type NullableDef = util.Satisfies<{
    typeName: z.ZodFirstPartyTypeKind.ZodNullable;
}, Partial<z.ZodNullableDef>>;
type OptionalDef = util.Satisfies<{
    typeName: z.ZodFirstPartyTypeKind.ZodOptional;
}, Partial<z.ZodOptionalDef>>;
type UndefinedDef = util.Satisfies<{
    typeName: z.ZodFirstPartyTypeKind.ZodUndefined;
}, Partial<z.ZodUndefinedDef>>;
type UnknownDef = util.Satisfies<{
    typeName: z.ZodFirstPartyTypeKind.ZodUnknown;
}, Partial<z.ZodUnknownDef>>;
/**
 * ZuiJSONSchema:
 *
 * A ZUI flavored subset of JSONSchema7
 */
type ZuiExtension<Def extends Partial<z.ZodDef> = {}> = {
    def?: Def;
} & ZuiExtensionObject;
type JsonData = string | number | boolean | null | JsonData[] | {
    [key: string]: JsonData;
};
type BaseZuiJSONSchema<Def extends Partial<z.ZodDef> = {}> = util.Satisfies<{
    description?: string;
    readOnly?: boolean;
    default?: JsonData;
    ['x-zui']?: ZuiExtension<Def>;
}, JSONSchema7>;
type _ZodSpecificStringFormat = 'cuid' | 'cuid2' | 'emoji' | 'ulid';
type _JSONSchemaStringFormat = 'date-time' | 'email' | 'ipv4' | 'ipv6' | 'uri' | 'uuid';
type _StringSchema = util.Satisfies<{
    type: 'string';
    pattern?: string;
    format?: _JSONSchemaStringFormat | _ZodSpecificStringFormat;
    minLength?: number;
    maxLength?: number;
}, JSONSchema7>;
type _ZodSpecificNumberFormat = 'finite';
type _NumberSchema = util.Satisfies<{
    type: 'number' | 'integer';
    minimum?: number;
    exclusiveMinimum?: number;
    maximum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
    format?: _ZodSpecificNumberFormat;
}, JSONSchema7>;
type _BooleanSchema = util.Satisfies<{
    type: 'boolean';
}, JSONSchema7>;
type _NullSchema = util.Satisfies<{
    type: 'null';
}, JSONSchema7>;
type _UndefinedSchema = util.Satisfies<{
    not: true;
}, JSONSchema7>;
type _NeverSchema = util.Satisfies<{
    not: true;
}, JSONSchema7>;
type _ArraySchema = util.Satisfies<{
    type: 'array';
    items: Schema;
    minItems?: number;
    maxItems?: number;
}, JSONSchema7>;
type _UnionSchema = util.Satisfies<{
    anyOf: Schema[];
}, JSONSchema7>;
type _DiscriminatedUnionSchema = util.Satisfies<{
    anyOf: Schema[];
}, JSONSchema7>;
type _IntersectionSchema = util.Satisfies<{
    allOf: Schema[];
}, JSONSchema7>;
type _SetSchema = util.Satisfies<{
    type: 'array';
    items: Schema;
    uniqueItems: true;
    minItems?: number;
    maxItems?: number;
}, JSONSchema7>;
type _EnumSchema = util.Satisfies<{
    type: 'string';
    enum: string[];
}, JSONSchema7>;
type _RefSchema = util.Satisfies<{
    $ref: string;
}, JSONSchema7>;
type _ObjectSchema = util.Satisfies<{
    type: 'object';
    properties: {
        [key: string]: Schema;
    };
    additionalProperties?: Schema | boolean;
    required?: string[];
}, JSONSchema7>;
type _TupleSchema = util.Satisfies<{
    type: 'array';
    items: Schema[];
    additionalItems?: Schema;
}, JSONSchema7>;
type _RecordSchema = util.Satisfies<{
    type: 'object';
    additionalProperties: Schema;
}, JSONSchema7>;
type _LiteralStringSchema = util.Satisfies<{
    type: 'string';
    const: string;
}, JSONSchema7>;
type _LiteralNumberSchema = util.Satisfies<{
    type: 'number';
    const: number;
}, JSONSchema7>;
type _LiteralBooleanSchema = util.Satisfies<{
    type: 'boolean';
    const: boolean;
}, JSONSchema7>;
type _OptionalSchema = util.Satisfies<{
    anyOf: [Schema, UndefinedSchema];
}, JSONSchema7>;
type _NullableSchema = util.Satisfies<{
    anyOf: [Schema, NullSchema];
}, JSONSchema7>;
type StringSchema = _StringSchema & BaseZuiJSONSchema;
type NumberSchema = _NumberSchema & BaseZuiJSONSchema;
type BooleanSchema = _BooleanSchema & BaseZuiJSONSchema;
type NullSchema = _NullSchema & BaseZuiJSONSchema;
type UndefinedSchema = _UndefinedSchema & BaseZuiJSONSchema<UndefinedDef>;
type NeverSchema = _NeverSchema & BaseZuiJSONSchema;
type AnySchema = BaseZuiJSONSchema;
type UnknownSchema = BaseZuiJSONSchema<UnknownDef>;
type ArraySchema = _ArraySchema & BaseZuiJSONSchema;
type UnionSchema = _UnionSchema & BaseZuiJSONSchema;
type DiscriminatedUnionSchema = _DiscriminatedUnionSchema & BaseZuiJSONSchema;
type IntersectionSchema = _IntersectionSchema & BaseZuiJSONSchema;
type SetSchema = _SetSchema & BaseZuiJSONSchema;
type EnumSchema = _EnumSchema & BaseZuiJSONSchema;
type RefSchema = _RefSchema & BaseZuiJSONSchema;
type ObjectSchema = _ObjectSchema & BaseZuiJSONSchema;
type TupleSchema = _TupleSchema & BaseZuiJSONSchema;
type RecordSchema = _RecordSchema & BaseZuiJSONSchema;
type LiteralStringSchema = _LiteralStringSchema & BaseZuiJSONSchema;
type LiteralNumberSchema = _LiteralNumberSchema & BaseZuiJSONSchema;
type LiteralBooleanSchema = _LiteralBooleanSchema & BaseZuiJSONSchema;
type OptionalSchema = _OptionalSchema & BaseZuiJSONSchema<OptionalDef>;
type NullableSchema = _NullableSchema & BaseZuiJSONSchema<NullableDef>;
type LiteralSchema = LiteralStringSchema | LiteralNumberSchema | LiteralBooleanSchema;
/**
 * Zui flavored JSON Schema; a subset of JSONSchema7 that includes Zui extensions
 */
type Schema = StringSchema | NumberSchema | BooleanSchema | UndefinedSchema | NullSchema | AnySchema | UnknownSchema | NeverSchema | ArraySchema | ObjectSchema | UnionSchema | DiscriminatedUnionSchema | IntersectionSchema | TupleSchema | RecordSchema | SetSchema | LiteralSchema | EnumSchema | RefSchema | OptionalSchema | NullableSchema;

type jsonSchema_AnySchema = AnySchema;
type jsonSchema_ArraySchema = ArraySchema;
type jsonSchema_BooleanSchema = BooleanSchema;
type jsonSchema_DiscriminatedUnionSchema = DiscriminatedUnionSchema;
type jsonSchema_EnumSchema = EnumSchema;
type jsonSchema_IntersectionSchema = IntersectionSchema;
type jsonSchema_LiteralBooleanSchema = LiteralBooleanSchema;
type jsonSchema_LiteralNumberSchema = LiteralNumberSchema;
type jsonSchema_LiteralSchema = LiteralSchema;
type jsonSchema_LiteralStringSchema = LiteralStringSchema;
type jsonSchema_NeverSchema = NeverSchema;
type jsonSchema_NullSchema = NullSchema;
type jsonSchema_NullableSchema = NullableSchema;
type jsonSchema_NumberSchema = NumberSchema;
type jsonSchema_ObjectSchema = ObjectSchema;
type jsonSchema_OptionalSchema = OptionalSchema;
type jsonSchema_RecordSchema = RecordSchema;
type jsonSchema_RefSchema = RefSchema;
type jsonSchema_Schema = Schema;
type jsonSchema_SetSchema = SetSchema;
type jsonSchema_StringSchema = StringSchema;
type jsonSchema_TupleSchema = TupleSchema;
type jsonSchema_UndefinedSchema = UndefinedSchema;
type jsonSchema_UnionSchema = UnionSchema;
type jsonSchema_UnknownSchema = UnknownSchema;
declare namespace jsonSchema {
  export type { jsonSchema_AnySchema as AnySchema, jsonSchema_ArraySchema as ArraySchema, jsonSchema_BooleanSchema as BooleanSchema, jsonSchema_DiscriminatedUnionSchema as DiscriminatedUnionSchema, jsonSchema_EnumSchema as EnumSchema, jsonSchema_IntersectionSchema as IntersectionSchema, jsonSchema_LiteralBooleanSchema as LiteralBooleanSchema, jsonSchema_LiteralNumberSchema as LiteralNumberSchema, jsonSchema_LiteralSchema as LiteralSchema, jsonSchema_LiteralStringSchema as LiteralStringSchema, jsonSchema_NeverSchema as NeverSchema, jsonSchema_NullSchema as NullSchema, jsonSchema_NullableSchema as NullableSchema, jsonSchema_NumberSchema as NumberSchema, jsonSchema_ObjectSchema as ObjectSchema, jsonSchema_OptionalSchema as OptionalSchema, jsonSchema_RecordSchema as RecordSchema, jsonSchema_RefSchema as RefSchema, jsonSchema_Schema as Schema, jsonSchema_SetSchema as SetSchema, jsonSchema_StringSchema as StringSchema, jsonSchema_TupleSchema as TupleSchema, jsonSchema_UndefinedSchema as UndefinedSchema, jsonSchema_UnionSchema as UnionSchema, jsonSchema_UnknownSchema as UnknownSchema };
}

type JsonSchema7AnyType = {
    [zuiKey]?: ZuiExtensionObject;
};

type Targets = 'jsonSchema7' | 'jsonSchema2019-09' | 'openApi3';
type Options<Target extends Targets = 'jsonSchema7'> = {
    name: string | undefined;
    $refStrategy: 'root' | 'relative' | 'none' | 'seen';
    basePath: string[];
    effectStrategy: 'input' | 'any';
    pipeStrategy: 'input' | 'output' | 'all';
    dateStrategy: 'string' | 'integer';
    mapStrategy: 'entries' | 'record';
    target: Target;
    strictUnions: boolean;
    definitionPath: string;
    definitions: Record<string, ZodType>;
    errorMessages: boolean;
    markdownDescription: boolean;
    patternStrategy: 'escape' | 'preserve';
    emailStrategy: 'format:email' | 'format:idn-email' | 'pattern:zod';
    discriminator: boolean;
    unionStrategy: 'anyOf' | 'oneOf';
};

type ErrorMessages<T extends JsonSchema7TypeUnion, OmitProperties extends string = ''> = Partial<Omit<{
    [key in keyof T]: string;
}, OmitProperties | 'type' | 'errorMessages'>>;

type JsonSchema7ArrayType = {
    type: 'array';
    items?: JsonSchema7Type;
    minItems?: number;
    maxItems?: number;
    errorMessages?: ErrorMessages<JsonSchema7ArrayType, 'items'>;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7BigintType = {
    type: 'integer';
    format: 'int64';
    minimum?: BigInt;
    exclusiveMinimum?: BigInt;
    maximum?: BigInt;
    exclusiveMaximum?: BigInt;
    multipleOf?: BigInt;
    errorMessage?: ErrorMessages<JsonSchema7BigintType>;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7BooleanType = {
    type: 'boolean';
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7NumberType = {
    type: 'number' | 'integer';
    minimum?: number;
    exclusiveMinimum?: number;
    maximum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
    errorMessage?: ErrorMessages<JsonSchema7NumberType>;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7DateType = {
    type: 'integer' | 'string';
    format: 'unix-time' | 'date-time';
    minimum?: number;
    maximum?: number;
    errorMessage?: ErrorMessages<JsonSchema7NumberType>;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7EnumType = {
    type: 'string';
    enum: string[];
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7AllOfType = {
    allOf: JsonSchema7Type[];
    unevaluatedProperties?: boolean;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7LiteralType = {
    type: 'string' | 'number' | 'integer' | 'boolean';
    const: string | number | boolean;
    [zuiKey]?: ZuiExtensionObject;
} | {
    type: 'object' | 'array';
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7StringType = {
    type: 'string';
    minLength?: number;
    maxLength?: number;
    format?: 'email' | 'idn-email' | 'uri' | 'uuid' | 'date-time' | 'ipv4' | 'ipv6';
    pattern?: string;
    allOf?: {
        pattern: string;
        errorMessage?: ErrorMessages<{
            type: 'string';
            pattern: string;
        }>;
    }[];
    anyOf?: {
        format: string;
        errorMessage?: ErrorMessages<{
            type: 'string';
            format: string;
        }>;
    }[];
    errorMessage?: ErrorMessages<JsonSchema7StringType>;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7RecordPropertyNamesType = Omit<JsonSchema7StringType, 'type'> | Omit<JsonSchema7EnumType, 'type'>;
type JsonSchema7RecordType = {
    type: 'object';
    additionalProperties: JsonSchema7Type;
    propertyNames?: JsonSchema7RecordPropertyNamesType;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7MapType = {
    type: 'array';
    maxItems: 125;
    items: {
        type: 'array';
        items: [JsonSchema7Type, JsonSchema7Type];
        minItems: 2;
        maxItems: 2;
    };
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7NativeEnumType = {
    type: 'string' | 'number' | ['string', 'number'];
    enum: (string | number)[];
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7NeverType = {
    not: {};
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7NullType = {
    type: 'null';
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7NullableType = {
    anyOf: [JsonSchema7Type, JsonSchema7NullType];
    [zuiKey]?: ZuiExtensionObject;
} | {
    type: [string, 'null'];
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7ObjectType = {
    type: 'object';
    properties: Record<string, JsonSchema7Type>;
    additionalProperties: boolean | JsonSchema7Type;
    required?: string[];
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7SetType = {
    type: 'array';
    uniqueItems: true;
    items?: JsonSchema7Type;
    minItems?: number;
    maxItems?: number;
    errorMessage?: ErrorMessages<JsonSchema7SetType>;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7TupleType = {
    type: 'array';
    minItems: number;
    items: JsonSchema7Type[];
    [zuiKey]?: ZuiExtensionObject;
} & ({
    maxItems: number;
} | {
    additionalItems?: JsonSchema7Type;
});

type JsonSchema7UndefinedType = {
    not: {};
    [zuiKey]?: ZuiExtensionObject;
};

declare const primitiveMappings: {
    readonly ZodString: "string";
    readonly ZodNumber: "number";
    readonly ZodBigInt: "integer";
    readonly ZodBoolean: "boolean";
    readonly ZodNull: "null";
};
type JsonSchema7Primitive = (typeof primitiveMappings)[keyof typeof primitiveMappings];
type JsonSchema7UnionType = JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | JsonSchema7OneOfType;
type JsonSchema7PrimitiveUnionType = {
    type: JsonSchema7Primitive | JsonSchema7Primitive[];
    [zuiKey]?: ZuiExtensionObject;
} | {
    type: JsonSchema7Primitive | JsonSchema7Primitive[];
    enum: (string | number | bigint | boolean | null)[];
    [zuiKey]?: ZuiExtensionObject;
};
type JsonSchema7AnyOfType = {
    anyOf: JsonSchema7Type[];
    discriminator?: {
        propertyName: string;
    };
};
type JsonSchema7OneOfType = {
    oneOf: JsonSchema7Type[];
    discriminator?: {
        propertyName: string;
    };
};

type JsonSchema7UnknownType = {
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7RefType = {
    $ref: string;
    [zuiKey]?: ZuiExtensionObject;
};

type JsonSchema7Meta = {
    default?: any;
    description?: string;
    markdownDescription?: string;
};
type JsonSchema7TypeUnion = JsonSchema7StringType | JsonSchema7ArrayType | JsonSchema7NumberType | JsonSchema7BigintType | JsonSchema7BooleanType | JsonSchema7DateType | JsonSchema7EnumType | JsonSchema7LiteralType | JsonSchema7NativeEnumType | JsonSchema7NullType | JsonSchema7NumberType | JsonSchema7ObjectType | JsonSchema7RecordType | JsonSchema7TupleType | JsonSchema7UnionType | JsonSchema7UndefinedType | JsonSchema7RefType | JsonSchema7NeverType | JsonSchema7MapType | JsonSchema7AnyType | JsonSchema7NullableType | JsonSchema7AllOfType | JsonSchema7UnknownType | JsonSchema7SetType;
type JsonSchema7Type = JsonSchema7TypeUnion & JsonSchema7Meta;

/**
 * Converts a JSONSchema to a Zui schema.
 *
 * @deprecated Use the new fromJSONSchema function instead.
 */
declare const fromJSONSchemaLegacy: (schema: JsonSchema7Type) => ZodTypeAny;

/**
 * Converts a JSON Schema to a ZUI Schema.
 * @param schema json schema
 * @returns ZUI Schema
 */
declare function fromJSONSchema(schema: JSONSchema7): z.ZodType;

type ObjectToZuiOptions = {
    optional?: boolean;
    nullable?: boolean;
    passtrough?: boolean;
};
/**
 * Converts a plain object to a Zod schema, by inferring the types of its properties.
 *
 * @param obj - The object to convert.
 * @param opts - Options to customize the Zod schema:
 * @returns A Zod schema representing the object.
 */
declare const fromObject: (obj: object, opts?: ObjectToZuiOptions, isRoot?: boolean) => ZodTypeAny;

type ZuiSchemaOptions = {
    /**
     * The scope is the full path to the property defined in the JSON schema, the root node being represented by #
     * Objects doesn't have any scope, only  its child does
     * @default "#/properties/"
     * */
    rootScope?: string;
    /**
     * Sets the $schema path. If set to false, it will remove the $schema property from the schema
     */
    $schemaUrl?: string | false;
    target?: 'jsonSchema7' | 'openApi3';
} & Partial<Pick<Options, 'unionStrategy' | 'discriminator'>>;
/**
 * Converts a Zod schema to a JSON Schema.
 *
 * @deprecated Use the new toJSONSchema function instead.
 */
declare const toJSONSchemaLegacy: (zuiType: ZodTypeAny, opts?: ZuiSchemaOptions) => JSONSchema7;

/**
 * Converts a Zui schema to a ZUI flavored JSON schema.
 * @param schema zui schema
 * @returns ZUI flavored JSON schema
 */
declare function toJSONSchema(schema: z.Schema): Schema;

/**
 *
 * @param schema zui schema
 * @param options generation options
 * @returns a typescript program that would construct the given schema if executed
 */
declare function toTypescriptSchema(schema: z.Schema): string;

type Transform = 'json-schema-to-zui' | 'object-to-zui' | 'zui-to-json-schema' | 'zui-to-typescript-schema' | 'zui-to-typescript-type';
declare abstract class ZuiTransformError extends Error {
    readonly transform: Transform;
    constructor(transform: Transform, message?: string);
}
declare class JSONSchemaToZuiError extends ZuiTransformError {
    constructor(message?: string);
}
declare class ObjectToZuiError extends ZuiTransformError {
    constructor(message?: string);
}
declare class ZuiToJSONSchemaError extends ZuiTransformError {
    constructor(message?: string);
}
declare class UnsupportedZuiToJSONSchemaError extends ZuiToJSONSchemaError {
    constructor(type: ZodFirstPartyTypeKind, { suggestedAlternative }?: {
        suggestedAlternative?: string;
    });
}
declare class UnsupportedZuiCheckToJSONSchemaError extends ZuiToJSONSchemaError {
    constructor({ zodType, checkKind }: {
        zodType: ZodFirstPartyTypeKind;
        checkKind: string;
    });
}
declare class UnsupportedJSONSchemaToZuiError extends JSONSchemaToZuiError {
    constructor(schema: JSONSchema7);
}
declare class ZuiToTypescriptSchemaError extends ZuiTransformError {
    constructor(message?: string);
}
declare class UnsupportedZuiToTypescriptSchemaError extends ZuiToTypescriptSchemaError {
    constructor(type: ZodFirstPartyTypeKind);
}
declare class ZuiToTypescriptTypeError extends ZuiTransformError {
    constructor(message?: string);
}
declare class UnsupportedZuiToTypescriptTypeError extends ZuiToTypescriptTypeError {
    constructor(type: ZodFirstPartyTypeKind);
}
declare class UntitledDeclarationError extends ZuiToTypescriptTypeError {
    constructor();
}
declare class UnrepresentableGenericError extends ZuiToTypescriptTypeError {
    constructor();
}

type errors_JSONSchemaToZuiError = JSONSchemaToZuiError;
declare const errors_JSONSchemaToZuiError: typeof JSONSchemaToZuiError;
type errors_ObjectToZuiError = ObjectToZuiError;
declare const errors_ObjectToZuiError: typeof ObjectToZuiError;
type errors_UnrepresentableGenericError = UnrepresentableGenericError;
declare const errors_UnrepresentableGenericError: typeof UnrepresentableGenericError;
type errors_UnsupportedJSONSchemaToZuiError = UnsupportedJSONSchemaToZuiError;
declare const errors_UnsupportedJSONSchemaToZuiError: typeof UnsupportedJSONSchemaToZuiError;
type errors_UnsupportedZuiCheckToJSONSchemaError = UnsupportedZuiCheckToJSONSchemaError;
declare const errors_UnsupportedZuiCheckToJSONSchemaError: typeof UnsupportedZuiCheckToJSONSchemaError;
type errors_UnsupportedZuiToJSONSchemaError = UnsupportedZuiToJSONSchemaError;
declare const errors_UnsupportedZuiToJSONSchemaError: typeof UnsupportedZuiToJSONSchemaError;
type errors_UnsupportedZuiToTypescriptSchemaError = UnsupportedZuiToTypescriptSchemaError;
declare const errors_UnsupportedZuiToTypescriptSchemaError: typeof UnsupportedZuiToTypescriptSchemaError;
type errors_UnsupportedZuiToTypescriptTypeError = UnsupportedZuiToTypescriptTypeError;
declare const errors_UnsupportedZuiToTypescriptTypeError: typeof UnsupportedZuiToTypescriptTypeError;
type errors_UntitledDeclarationError = UntitledDeclarationError;
declare const errors_UntitledDeclarationError: typeof UntitledDeclarationError;
type errors_ZuiToJSONSchemaError = ZuiToJSONSchemaError;
declare const errors_ZuiToJSONSchemaError: typeof ZuiToJSONSchemaError;
type errors_ZuiToTypescriptSchemaError = ZuiToTypescriptSchemaError;
declare const errors_ZuiToTypescriptSchemaError: typeof ZuiToTypescriptSchemaError;
type errors_ZuiToTypescriptTypeError = ZuiToTypescriptTypeError;
declare const errors_ZuiToTypescriptTypeError: typeof ZuiToTypescriptTypeError;
type errors_ZuiTransformError = ZuiTransformError;
declare const errors_ZuiTransformError: typeof ZuiTransformError;
declare namespace errors {
  export { errors_JSONSchemaToZuiError as JSONSchemaToZuiError, errors_ObjectToZuiError as ObjectToZuiError, errors_UnrepresentableGenericError as UnrepresentableGenericError, errors_UnsupportedJSONSchemaToZuiError as UnsupportedJSONSchemaToZuiError, errors_UnsupportedZuiCheckToJSONSchemaError as UnsupportedZuiCheckToJSONSchemaError, errors_UnsupportedZuiToJSONSchemaError as UnsupportedZuiToJSONSchemaError, errors_UnsupportedZuiToTypescriptSchemaError as UnsupportedZuiToTypescriptSchemaError, errors_UnsupportedZuiToTypescriptTypeError as UnsupportedZuiToTypescriptTypeError, errors_UntitledDeclarationError as UntitledDeclarationError, errors_ZuiToJSONSchemaError as ZuiToJSONSchemaError, errors_ZuiToTypescriptSchemaError as ZuiToTypescriptSchemaError, errors_ZuiToTypescriptTypeError as ZuiToTypescriptTypeError, errors_ZuiTransformError as ZuiTransformError };
}

type index_TypescriptGenerationOptions = TypescriptGenerationOptions;
declare const index_errors: typeof errors;
declare const index_fromJSONSchema: typeof fromJSONSchema;
declare const index_fromJSONSchemaLegacy: typeof fromJSONSchemaLegacy;
declare const index_fromObject: typeof fromObject;
declare const index_toJSONSchema: typeof toJSONSchema;
declare const index_toJSONSchemaLegacy: typeof toJSONSchemaLegacy;
declare const index_toTypescriptSchema: typeof toTypescriptSchema;
declare const index_toTypescriptType: typeof toTypescriptType;
declare namespace index {
  export { type index_TypescriptGenerationOptions as TypescriptGenerationOptions, index_errors as errors, index_fromJSONSchema as fromJSONSchema, index_fromJSONSchemaLegacy as fromJSONSchemaLegacy, index_fromObject as fromObject, index_toJSONSchema as toJSONSchema, index_toJSONSchemaLegacy as toJSONSchemaLegacy, index_toTypescriptSchema as toTypescriptSchema, index_toTypescriptType as toTypescriptType };
}

export { type AdditionalProperties, type AnyZodObject, type AnyZodTuple, type ArrayCardinality, type ArrayKeys, type AssertArray, type AsyncParseReturnType, BRAND, type CatchFn, type CustomErrorParams, type CustomParams, DIRTY, type DenormalizedError, EMPTY_PATH, type Effect, type EnumLike, type EnumValues, type ErrorMapCtx, type FilterEnum, INVALID, type Indices, type InnerTypeOfFunction, type InputTypeOfTuple, type InputTypeOfTupleWithRest, type IpVersion, type IssueData, type KeySchema, type KindToDef, type Maskable, NEVER, OK, type ObjectPair, type OfType, type OuterTypeOfFunction, type OutputTypeOfTuple, type OutputTypeOfTupleWithRest, type ParseContext, type ParseInput, ParseInputLazyPath, type ParseParams, type ParsePath, type ParsePathComponent, type ParseResult, type ParseReturnType, ParseStatus, type PreprocessEffect, type Primitive, type ProcessedCreateParams, type RawCreateParams, type RecordType, type Refinement, type RefinementCtx, type RefinementEffect, type SafeParseError, type SafeParseReturnType, type SafeParseSuccess, type Scalars, ZodType as Schema, type SomeZodObject, type StringValidation, type SuperRefinement, type SyncParseReturnType, type TransformEffect, type TypeOf, type UnknownKeysInputType, type UnknownKeysOutputType, type UnknownKeysParam, type Values, type Writeable, ZodAny, type ZodAnyDef, ZodArray, type ZodArrayDef, ZodBigInt, type ZodBigIntCheck, type ZodBigIntDef, ZodBoolean, type ZodBooleanDef, ZodBranded, type ZodBrandedDef, ZodCatch, type ZodCatchDef, type ZodCustomIssue, ZodDate, type ZodDateCheck, type ZodDateDef, type ZodDef, ZodDefault, type ZodDefaultDef, ZodDiscriminatedUnion, type ZodDiscriminatedUnionDef, type ZodDiscriminatedUnionOption, ZodEffects, type ZodEffectsDef, ZodEnum, type ZodEnumDef, ZodError, type ZodErrorMap, type ZodFirstPartySchemaTypes, ZodFirstPartyTypeKind, type ZodFormattedError, ZodFunction, type ZodFunctionDef, ZodIntersection, type ZodIntersectionDef, type ZodInvalidArgumentsIssue, type ZodInvalidDateIssue, type ZodInvalidEnumValueIssue, type ZodInvalidIntersectionTypesIssue, type ZodInvalidLiteralIssue, type ZodInvalidReturnTypeIssue, type ZodInvalidStringIssue, type ZodInvalidTypeIssue, type ZodInvalidUnionDiscriminatorIssue, type ZodInvalidUnionIssue, type ZodIssue, type ZodIssueBase, ZodIssueCode, type ZodIssueOptionalMessage, ZodLazy, type ZodLazyDef, ZodLiteral, type ZodLiteralDef, ZodMap, type ZodMapDef, ZodNaN, type ZodNaNDef, ZodNativeEnum, type ZodNativeEnumDef, ZodNever, type ZodNeverDef, type ZodNonEmptyArray, type ZodNotFiniteIssue, type ZodNotMultipleOfIssue, ZodNull, type ZodNullDef, ZodNullable, type ZodNullableDef, type ZodNullableType, ZodNumber, type ZodNumberCheck, type ZodNumberDef, ZodObject, type ZodObjectDef, ZodOptional, type ZodOptionalDef, type ZodOptionalType, ZodParsedType, ZodPipeline, type ZodPipelineDef, ZodPromise, type ZodPromiseDef, type ZodRawShape, ZodReadonly, type ZodReadonlyDef, ZodRecord, type ZodRecordDef, ZodRef, type ZodRefDef, ZodType as ZodSchema, ZodSet, type ZodSetDef, ZodString, type ZodStringCheck, type ZodStringDef, ZodSymbol, type ZodSymbolDef, type ZodTooBigIssue, type ZodTooSmallIssue, ZodEffects as ZodTransformer, ZodTuple, type ZodTupleDef, type ZodTupleItems, ZodType, type ZodTypeAny, type ZodTypeDef, ZodUndefined, type ZodUndefinedDef, ZodUnion, type ZodUnionDef, type ZodUnionOptions, ZodUnknown, type ZodUnknownDef, type ZodUnrecognizedKeysIssue, type ZodUnresolvedReferenceIssue, ZodVoid, type ZodVoidDef, addIssueToContext, agent, aimodel, anyType as any, arrayType as array, type arrayOutputType, type baseObjectInputType, type baseObjectOutputType, bigIntType as bigint, booleanType as boolean, coerce, conversation, createZodEnum, cuid2Regex, cuidRegex, custom, datasource, dateType as date, type deoptional, discriminatedUnionType as discriminatedUnion, effectsType as effect, emailRegex, enumType as enum, enumUtil, errorUtil, event, functionType as function, getErrorMap, getParsedType, type TypeOf as infer, type inferFlattenedErrors, type inferFormattedError, type input, instanceOfType as instanceof, intent, intersectionType as intersection, ipv4Regex, ipv6Regex, isAborted, isAsync, isDirty, isEmojiRegex, isValid, jsonSchema as json, knowledgebase, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, type mergeTypes, message, nanType as nan, nativeEnumType as nativeEnum, neverType as never, type noUnrecognized, nullType as null, nullableType as nullable, numberType as number, objectType as object, type objectInputType, type objectOutputType, objectUtil, oboolean, onumber, optionalType as optional, ostring, type output, partialUtil, pipelineType as pipeline, preprocessType as preprocess, processCreateParams, promiseType as promise, quotelessJson, readonlyType as readonly, recordType as record, refType as ref, setType as set, setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, table, tablerow, effectsType as transformer, index as transforms, tupleType as tuple, type typeToFlattenedError, type typecast, ulidRegex, undefinedType as undefined, unionType as union, unknownType as unknown, user, util, uuidRegex, variable, voidType as void, z };
